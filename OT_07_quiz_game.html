<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Emoji Breaker ‚Äî Bible Edition</title>
<style>
  :root{
    --bg:#0f1226;
    --card:#171b3a;
    --ink:#eef2ff;
    --muted:#aab3ff;
    --accent:#7c4dff;
    --good:#37d67a;
    --bad:#ff5a5f;
    --gold:#ffd54a;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif;
    background: radial-gradient(1200px 800px at 50% -200px,#1a1f4a 0%,#0f1226 50%,#0b0e1b 100%) fixed;
    color:var(--ink); display:flex; align-items:center; justify-content:center;
  }
  .wrap{width:100%; max-width:900px; padding:16px}
  .card{
    background:linear-gradient(180deg,rgba(255,255,255,0.05),rgba(0,0,0,0.15));
    border:1px solid rgba(255,255,255,0.08);
    border-radius:16px; box-shadow:0 30px 60px rgba(0,0,0,.35);
    overflow:hidden;
  }
  header{padding:20px 20px 12px; display:flex; align-items:center; justify-content:space-between; gap:12px}
  /* Hide the header to give the canvas more height */
header{display:none}

  header h1{font-size:clamp(18px,3vw,22px); margin:0; letter-spacing:.3px}
  header .score{font-weight:700; color:var(--gold)}
  .view{display:none}
  .view.active{display:block}
  .section{padding:16px 20px 20px}
  .center{display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; gap:16px}
  .title{font-size:clamp(26px,5vw,42px); font-weight:800; line-height:1.05; letter-spacing:.2px}
  .subtitle{color:var(--muted)}
  .btn{
    appearance:none; border:0; border-radius:12px; padding:14px 18px; font-weight:800; letter-spacing:.3px;
    background:linear-gradient(180deg,#7f5aff,#6a4cff); color:white; cursor:pointer; box-shadow:0 10px 20px rgba(124,77,255,.35);
    transition:transform .06s ease, box-shadow .2s ease, filter .2s ease;
  }
  .btn:hover{filter:brightness(1.05)}
  .btn:active{transform:translateY(1px)}
  .btn.secondary{background:#2a2f64}
  .grid{
    display:grid; gap:12px; width:100%;
    grid-template-columns:repeat(2, minmax(0,1fr));
  }

.answer .lbl{flex:1; color:#f3f6ff; font-weight:700; letter-spacing:.2px}


.answer{
  background:#25306b; /* higher contrast */
  border:1px solid rgba(255,255,255,.18);
  padding:14px 16px;
  border-radius:12px;
  display:flex; align-items:center; gap:12px; cursor:pointer; text-align:left;
  font-size:18px; line-height:1.25; color:#f3f6ff; /* larger, brighter text */
  font-weight:700;
}

  .answer .emo{font-size:22px; width:28px; text-align:center}
  .answer:hover{filter:brightness(1.06)}
  .muted{color:var(--muted); font-size:.95rem}
  .hint{font-size:.9rem; color:#c9cdfa}
  .tag{display:inline-block; background:#23285c; padding:4px 10px; border-radius:999px; font-weight:700; letter-spacing:.2px; color:#cfd5ff}
  .spacer{height:8px}
  /* Canvas area */
  .gameWrap{position:relative; width:100%; background:#0a0d21; border-top:1px solid rgba(255,255,255,.06)}

/* small non-blocking toasts inside the game area */
.toast{
  position:absolute; left:50%; top:10px; transform:translateX(-50%);
  background:rgba(20,24,56,.92); color:#fff; padding:8px 12px; border-radius:999px;
  border:1px solid rgba(255,255,255,.15); box-shadow:0 8px 18px rgba(0,0,0,.35);
  font-weight:800; letter-spacing:.2px; pointer-events:none; opacity:1; transition:opacity .35s, transform .35s;
}
.toast.hide{ opacity:0; transform:translate(-50%,-6px); }


  canvas{display:block; width:100%; height:auto; background:linear-gradient(180deg,#0e1331 0,#0a0d21 100%)}
.bar{display:flex; gap:10px; align-items:center; justify-content:space-between; padding:12px 16px; background:#12163a; border-top:1px solid rgba(255,255,255,.06)}
  .bar .pill{background:#1c2252; padding:6px 10px; border-radius:999px}
  /* Modal */
  .modal{position:fixed; inset:0; display:none; align-items:center; justify-content:center; backdrop-filter:blur(6px); background:rgba(5,8,20,.55); z-index:50}
  .modal.show{display:flex}
  .modal .box{
    width:min(560px,92vw); background:#161a3a; border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:18px;
    text-align:center; box-shadow:0 30px 60px rgba(0,0,0,.5);
  }
  .modal .box h3{margin:.2rem 0 .6rem; font-size:1.4rem}
  .modal .box p{margin:.2rem 0 .8rem; color:#cbd1ff}
  .flex{display:flex; gap:12px; flex-wrap:wrap; align-items:center; justify-content:center}
  .bar small{color:#cbd1ff}
  /* Boss health */
  .hpBar{height:10px; background:#232a66; border:1px solid rgba(255,255,255,.1); border-radius:999px; overflow:hidden}
  .hpFill{height:100%; background:linear-gradient(90deg,#ff6a6a,#ff9b4a)}
  /* Responsive tweaks */
  @media (max-width:520px){
.grid{gap:10px}
.answer{padding:12px 14px; font-size:17px}
.answer .emo{font-size:22px}

  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <header>
        <h1>üéÆ Emoji Breaker ‚Äî Bible Edition</h1>
        <div class="score">Score: <span id="score">0</span></div>
      </header>

      <!-- VIEWS -->
      <div id="view-splash" class="view active">
        <div class="section center" style="min-height:38vh">
          <div class="title">Best in Vertical Mode üì±</div>
          <div class="subtitle">For the smoothest play, rotate your device to portrait.</div>
          <button class="btn" id="btnSplashOk">Okay, let‚Äôs go</button>
        </div>
      </div>

      <div id="view-title" class="view">
        <div class="section center" style="min-height:38vh">
          <div class="title">Emoji Breaker</div>
          <div class="subtitle">Answer Bible questions, then break the emoji!<br/><span class="tag">10 rounds + Boss</span></div>
          <div class="spacer"></div>
          <button class="btn" id="btnStart">Start</button>
        </div>
      </div>

      <div id="view-question" class="view">
        <div class="section">
          <div class="muted">Question <span id="qNum">1</span> / 10</div>
          <h2 id="qText" style="margin:.3rem 0 1rem; line-height:1.25"></h2>
          <div class="grid" id="answers"></div>
          <div class="spacer"></div>
          <div class="hint">Choose the best answer. +100 points if correct.</div>
        </div>
      </div>

      <div id="view-game" class="view">
<!-- (removed round strip to increase game area) -->

        <div class="gameWrap">
          <canvas id="game"></canvas>
        </div>
        <div class="bar">
          <div class="pill">‚è±Ô∏è Time: <span id="time">30</span>s</div>
          <div class="pill">üß± Broken: <span id="broken">0</span></div>
<div class="pill">üèÜ Score: <span id="scoreBar">0</span></div>
        </div>
      </div>

      <div id="view-boss" class="view">
<div class="section">
  <div class="hpBar"><div id="hpFill" class="hpFill" style="width:100%"></div></div>
</div>

        <div class="gameWrap">
          <canvas id="boss"></canvas>
        </div>
        <div class="bar">
          <div class="pill">‚ù§Ô∏è Boss Hits: <span id="bossHits">0</span> / 5</div>
          <div class="pill">üß± Shield Left: <span id="shieldLeft">‚Äî</span></div>
          <div class="pill">‚è±Ô∏è Miss ends round</div>
        </div>
      </div>

      <div id="view-end" class="view">
        <div class="section center" style="min-height:40vh">
          <div class="title">Great Job! üéâ</div>
          <p class="subtitle">
            Final Score: <b id="finalScore">0</b><br/>
            Emojis Broken: <b id="finalBroken">0</b><br/>
            Boss Hits: <b id="finalBoss">0</b> / 5
          </p>
          <div class="flex">
            <button class="btn" id="btnReplay">Play Again</button>
            <button class="btn secondary" id="btnTitle">Back to Title</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal -->
  <div id="modal" class="modal">
    <div class="box">
      <h3 id="mTitle">Title</h3>
      <p id="mBody">Body</p>
      <div class="flex">
        <button class="btn" id="mOk">OK</button>
      </div>
    </div>
  </div>

<script>
(()=>{
  // -----------------------------
  // Simple view / modal helpers
  // -----------------------------
  const $ = s => document.querySelector(s);
  const show = id => document.querySelectorAll('.view').forEach(v=>v.id===id?v.classList.add('active'):v.classList.remove('active'));
  const scoreEl = $('#score');
  let score = 0, totalBroken = 0;
  // --- Secret boss jump ---
const SECRET_KEY = 'b';
let SECRET_JUMP = false;

// --- Tuning: ball speed behavior ---
const BALL_ACCEL_PER_SEC = 0.018;   // continuous acceleration while the round runs
const PADDLE_HIT_SPEED_BOOST = 0.10; // extra kick every time the ball hits the paddle
const BALL_SPEED_MAX = 5.35;        // hard cap so it never gets too fast
// --- Power-up settings ---
const CLOCK_EMOJI = "‚è∞";
const DISCO_EMOJI = "ü™©";
const TIME_BONUS_SECONDS = 10;
const MAX_BALLS = 2; // cap multiball
// --- Boss round scoring ---
const SHIELD_POINTS = 10;     // points per shield brick
const BOSS_HIT_POINTS = 100;  // points per boss hit

  const modalEl = $('#modal'), mTitle = $('#mTitle'), mBody = $('#mBody'), mOk = $('#mOk');
  let modalResolve = null;
  function modal(title, body){
    mTitle.textContent = title;
    mBody.innerHTML = body;
    modalEl.classList.add('show');
    return new Promise(res=>{ modalResolve=res; });
  }
  mOk.addEventListener('click', ()=>{
    modalEl.classList.remove('show');
    if(modalResolve){ modalResolve(); modalResolve=null; }
  });
  // Secret key: press "b" to jump to boss
document.addEventListener('keydown', (e)=>{
  if (!e.key) return;
  if (e.key.toLowerCase() === SECRET_KEY){
    SECRET_JUMP = true;
    // If a modal is open, close AND resolve it so any awaiting code can continue
    if (modalEl.classList.contains('show')) {
      modalEl.classList.remove('show');
      if (modalResolve) { modalResolve(); modalResolve = null; }
    }
  }
});


// Non-blocking toast inside the current game view
function toast(msg){
  const host = document.querySelector('.view.active .gameWrap');
  if(!host) return;
  // remove any existing toast first
  const old = host.querySelector('.toast');
  if (old) old.remove();
  const t = document.createElement('div');
  t.className = 'toast';
  t.textContent = msg;
  host.appendChild(t);
  setTimeout(()=> t.classList.add('hide'), 1200);
  setTimeout(()=> t.remove(), 1700);
}

/*

 #####     #     #    #######     #####     #######    ###    #######    #     #     #####  
#     #    #     #    #          #     #       #        #     #     #    ##    #    #     # 
#     #    #     #    #          #             #        #     #     #    # #   #    #       
#     #    #     #    #####       #####        #        #     #     #    #  #  #     #####  
#   # #    #     #    #                #       #        #     #     #    #   # #          # 
#    #     #     #    #          #     #       #        #     #     #    #    ##    #     # 
 #### #     #####     #######     #####        #       ###    #######    #     #     #####  

*/

  const QUESTIONS = [

{
  q: "After the flood, what command did God give human beings?",
  ans: [
    ["üë∂", "Have children, fill the earth"],
    ["üóº", "Build a great tower"],
    ["üèôÔ∏è", "Stay in one city"],
    ["üèÜ", "Make a name for yourselves"]
  ],
  correctIndex: 0
},
{
  q: "After the flood, what did everyone on earth have in common?",
  ans: [
    ["üó£Ô∏è", "They spoke the same language"],
    ["üíº", "They had the same jobs"],
    ["üèôÔ∏è", "They lived in the same city"],
    ["üëó", "They wore the same clothes"]
  ],
  correctIndex: 0
},
{
  q: "What did the people decide to build?",
  ans: [
    ["üèôÔ∏è", "A tower that reached to the sky"],
    ["üö¢", "A huge ark"],
    ["‚õ™", "A temple for sacrifices"],
    ["üêÆ", "A golden calf"]
  ],
  correctIndex: 0
},
{
  q: "Why did they want to build a tower?",
  ans: [
    ["üèÜ", "To make a name for themselves, not be scattered"],
    ["üôè", "To worship God better"],
    ["üåä", "To protect from another flood"],
    ["‚ú®", "To study the stars"]
  ],
  correctIndex: 0
},
{
  q: "Why was God not pleased with their building project?",
  ans: [
    ["üö´", "They were disobeying His command"],
    ["üìè", "It was too tall"],
    ["üß±", "It used bricks"],
    ["‚òÄÔ∏è", "It blocked the sun"]
  ],
  correctIndex: 0
},
{
  q: "If the people worked together, what did God say they would be able to do?",
  ans: [
    ["üí™", "Anything they wanted"],
    ["üêæ", "Rule all the animals"],
    ["‚è≥", "Stop aging"],
    ["üå¥", "Find the Garden of Eden"]
  ],
  correctIndex: 0
},
{
  q: "What did God say He was going to do?",
  ans: [
    ["üîÄ", "Mix up their languages"],
    ["üåßÔ∏è", "Send another flood"],
    ["üî•", "Send fire from heaven"],
    ["üå™Ô∏è", "Destroy the city with a storm"]
  ],
  correctIndex: 0
},
{
  q: "When God mixed up their languages, what did they stop doing?",
  ans: [
    ["üèóÔ∏è", "Building the tower"],
    ["ü§ê", "Speaking at all"],
    ["üåæ", "Working the fields"],
    ["üíç", "Getting married"]
  ],
  correctIndex: 0
},
{
  q: "What did the people do after they stopped building the tower?",
  ans: [
    ["üåç", "Scattered over the earth"],
    ["üèôÔ∏è", "Stayed in Babel together"],
    ["üö¢", "Built ships to stay united"],
    ["üëë", "Chose one king to rule all"]
  ],
  correctIndex: 0
},
{
  q: "According to Revelation, what will happen in Jesus‚Äô forever kingdom?",
  ans: [
    ["üôå", "People from all languages will praise God"],
    ["üó£Ô∏è", "Only one language will remain"],
    ["üòá", "Only angels will praise God"],
    ["üó∫Ô∏è", "No nations will remain"]
  ],
  correctIndex: 0
}
]


  /*

#######    #     #    ######     
#          ##    #    #     #    
#          # #   #    #     #    
#####      #  #  #    #     #    
#          #   # #    #     #    
#          #    ##    #     #    
#######    #     #    ######     


*/


  // -----------------------------
  // Navigation state
  // -----------------------------
  let roundIndex = 0; // 0..9
  $('#btnStart').addEventListener('click', startGameFlow);
  $('#btnReplay').addEventListener('click', ()=>{ resetAll(); startGameFlow(); });
  $('#btnTitle').addEventListener('click', ()=>{ resetAll(); show('view-title'); });

  function resetAll(){
    score = 0; totalBroken = 0; roundIndex = 0; updateScore();
    bossState.reset();
    $('#finalScore').textContent = '0';
    $('#finalBroken').textContent = '0';
    $('#finalBoss').textContent = '0';
  }
function updateScore(){
  scoreEl && (scoreEl.textContent = score); // header is hidden now
  if (scoreBarEl) scoreBarEl.textContent = score; // show score in bottom-right pill
}

async function startGameFlow(){
  SECRET_JUMP = false; // reset secret flag each new run
  // Pick 10 unique themes for this run (random order)
  roundThemes = shuffle(THEMES).slice(0, 10);


  // Title ‚Üí questions flow
  show('view-question');
  await questionRoundLoop();
  // Boss

    await modal("Final Round", "Hit the boss 5 times to win! (Shield optional.)");
    await startBossBattle();
    // End
    showEnd();
  }

  async function questionRoundLoop(){
for(roundIndex=0; roundIndex<QUESTIONS.length; roundIndex++){
  if (SECRET_JUMP) break;

  // Set the theme for this round (unique per game)
  currentThemeEmojis = roundThemes[roundIndex] || EMOJIS;

  await showQuestion(QUESTIONS[roundIndex], roundIndex);
  if (SECRET_JUMP) break;

if (roundIndex === 0) {
  await modal("Break the Emojis!", `Use your mouse or your finger to move the paddle and bounce the ball!`);
  if (SECRET_JUMP) break;
}


  await playBreakerRound(roundIndex);
  if (SECRET_JUMP) break;
}


  }

  // -----------------------------
  // Question UI
  // -----------------------------
  const qNumEl = $('#qNum'), qTextEl = $('#qText'), answersEl = $('#answers'), rNumEl = $('#rNum');
function showQuestion(qo, idx){
  return new Promise(resolve=>{
    show('view-question');
    qNumEl.textContent = (idx+1);
    qTextEl.textContent = qo.q;
    answersEl.innerHTML = '';

    // Clean up helper so we don't leak listeners
    function cleanup(){
      document.removeEventListener('keydown', onSecret);
    }
    function onSecret(e){
      if (SECRET_JUMP){
        cleanup();
        resolve(); // bail out of the question immediately
      }
    }
    document.addEventListener('keydown', onSecret);

// Shuffle answer order but keep correctness tied to the original indices
const order = shuffle([0,1,2,3]);            // uses the shuffle() already in this file
const correctOriginal = qo.correctIndex;     // keep reference to the original correct index

order.forEach((ansIndex)=>{
  const [emo, label] = qo.ans[ansIndex];
  const isCorrect = (ansIndex === correctOriginal);

  const btn = document.createElement('button');
  btn.className = 'answer';
  btn.innerHTML = `<span class="emo">${emo}</span><span class="lbl">${label}</span>`;

  btn.addEventListener('click', async ()=>{
    if (isCorrect){
      score += 100; updateScore();
      await modal("‚úÖ Correct!", `Nice work!`);
    } else {
      const right = qo.ans[correctOriginal][1];
      await modal("‚ùå Incorrect", `Correct answer:<br><b>${right}</b>`);
    }
    cleanup();
    resolve();
  });

  answersEl.appendChild(btn);
});
  });
}


  // -----------------------------
  // Breaker Round (per question)
  // -----------------------------
  const canvas = $('#game'), ctx = canvas.getContext('2d');
const timeEl = $('#time'), brokenEl = $('#broken'), scoreBarEl = $('#scoreBar');

  // Resize canvas to a portrait-friendly rectangle
  function sizeGameCanvas(){
    const maxW = document.querySelector('.gameWrap').clientWidth;
const maxH = Math.min(window.innerHeight*0.75, 780);
    const aspect = 9/14; // tall-ish
let w = maxW;
    let h = Math.min(maxH, Math.round(w/aspect));
    canvas.width = Math.floor(w*2); canvas.height = Math.floor(h*2); // hi-dpi buffer
    canvas.style.height = `${h}px`; canvas.style.width = `${w}px`;
  }
  window.addEventListener('resize', ()=>{ if($('#view-game').classList.contains('active')) sizeGameCanvas(); });
  // Game objects
  const EMOJIS = ["üòÄ","‚≠ê","üß±","üçá","üçû","üêü","üïäÔ∏è","üìñ","üåà","üåü","ü™®","üß∫","üõ∂","üïØÔ∏è","ü•ñ","üéØ"];
  // --- Ten round themes (no repeats per game) ---

  const THEMES = [
  // 1) Space & stars
  ["üåå","ü™ê","üöÄ","üå†","üõ∞Ô∏è","üåü","üëΩ"],

  // 2) Ocean life
  ["üåä","üê†","üêü","üê¨","üêô","ü¶Ä","ü™º"],

// 3) Food mix
["üåÆ","üçî","üçï","üç£","ü•ó","üçú","üç¶"],


  // 4) Forest & camping
  ["üå≤","üèïÔ∏è","üî•","üß≠","ü™µ","ü™∫","üåø"],

  // 5) Sports mix
  ["‚öΩ","üèÄ","üéæ","üèà","‚öæ","ü•è","üèì"],

  // 6) Weather & seasons
  ["‚òÄÔ∏è","‚õÖ","üåßÔ∏è","‚õàÔ∏è","‚ùÑÔ∏è","üçÇ","üåà"],

  // 7) Music & stage
  ["üéµ","üé∂","üéß","üé§","üéπ","ü•Å","üé∏"],

  // 8) City & travel
  ["üöå","üöá","üöï","üóΩ","üåÜ","üèôÔ∏è","üó∫Ô∏è"],

  // 9) Cute animals
  ["üê±","üê∂","üê∞","ü¶ä","üêº","üê®","ü¶Å"],

  // 10) Fantasy & magic
  ["üßô‚Äç‚ôÇÔ∏è","ü™Ñ","üêâ","üßù‚Äç‚ôÄÔ∏è","üß™","üîÆ","‚ú®"]
];


// Shuffle helper
function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}

// Current round theme (fallback to EMOJIS)
let currentThemeEmojis = EMOJIS;
// Preselected themes for this game (10 unique, randomized order)
let roundThemes = [];

function makeGrid(){
  const cols = 9, rows = 4;
  const list = currentThemeEmojis && currentThemeEmojis.length ? currentThemeEmojis : EMOJIS;
  const grid = [];
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const emo = list[Math.floor(Math.random()*list.length)];
      grid.push({ c, r, alive:true, popT:0, emo, type:"normal" });
    }
  }
  // choose distinct special cells
  const total = grid.length;
  const iClock = Math.floor(Math.random()*total);
  let iDisco = Math.floor(Math.random()*total);
  if(iDisco === iClock) iDisco = (iDisco+1) % total;

  grid[iClock].emo = CLOCK_EMOJI; grid[iClock].type = "clock";
  grid[iDisco].emo = DISCO_EMOJI; grid[iDisco].type = "disco";

  return {cols, rows, bricks:grid};
}


// Limit bricks to the top ~40% of the canvas, with padding between bricks
// Keep brick size the same as a 10-column grid, but render only 9 columns.
// Center them so there's a 1/2-brick margin on each side, and move the grid
// down by one brick height to leave a full-brick space above.

function brickRect(grid, b, W, H){
  const pad = 10;         // gap between bricks
  const top = 20;         // top offset inside the canvas
  const bricksAreaH = Math.max(120, H * 0.40);

  // ---- Horizontal layout with HALF-BRICK outer margins ----
  // We want a half brick of empty space on the left and right.
  // That means: (cols+1)*bw + (cols-1)*pad = W
  //  -> bw = (W - (cols-1)*pad) / (cols + 1)
  const bw = (W - (grid.cols - 1) * pad) / (grid.cols + 1);
  const outer = bw * 0.5;                       // half-brick margin on each side

  // ---- Vertical sizing (same as before, with one-brick drop) ----
  const totalGapsY = (grid.rows - 1) * pad;
  const availableH = bricksAreaH - top;
  const bh = (availableH - totalGapsY) / grid.rows;

  const offsetY = bh + pad; // one full brick down (Arkanoid channel)

  // Brick position
  const x = outer + b.c * (bw + pad);
  const y = top + offsetY + b.r * (bh + pad);

  return {
    x, y, w: bw, h: bh,
    cx: x + bw/2,
    cy: y + bh*0.62,
    font: Math.min(bw, bh) * 0.65
  };
}







  function playBreakerRound(idx){
    return new Promise(resolve=>{
show('view-game'); if (rNumEl) rNumEl.textContent = (idx+1); sizeGameCanvas();
      let W = canvas.width, H = canvas.height;
      const grid = makeGrid();
      let broken = 0, running = true, tLeft = 30;
      let last = performance.now();

      // Paddle & ball
      const paddle = { w:W*0.18, h: H*0.02, x: W*0.41, y: H*0.90 };
const balls = [
  { x:W*0.5, y:H*0.7, r:Math.max(8, Math.min(W,H)*0.012), vx: W*0.22, vy: -H*0.28, speed:1, color:'#ffd54a', isSecondary:false }
];
let haveSecondary = false;
let rainbowHue = 0;


// Input (named handlers so we can remove them)
function setPaddle(clientX){
  const rect = canvas.getBoundingClientRect();
  const x = (clientX - rect.left) * (canvas.width / rect.width);
  paddle.x = Math.max(0, Math.min(W - paddle.w, x - paddle.w/2));
}
function onMouseMove(e){ setPaddle(e.clientX); }
function onTouchStart(e){ if(e.touches[0]) setPaddle(e.touches[0].clientX); }
function onTouchMove(e){ if(e.touches[0]) setPaddle(e.touches[0].clientX); }

canvas.addEventListener('mousemove', onMouseMove);
canvas.addEventListener('touchstart', onTouchStart, {passive:true});
canvas.addEventListener('touchmove', onTouchMove, {passive:true});



      // Timer
      timeEl.textContent = tLeft;
      const tickTimer = setInterval(()=>{
        tLeft--; if(tLeft<=0){ endRound("Time"); }
        timeEl.textContent = tLeft;
      }, 1000);

      function endRound(reason){
        if(!running) return;
        running = false;
        clearInterval(tickTimer);
        totalBroken += broken;
        brokenEl.textContent = broken;

canvas.removeEventListener('mousemove', onMouseMove);
canvas.removeEventListener('touchstart', onTouchStart);
canvas.removeEventListener('touchmove', onTouchMove);




        // small pause then resolve
        setTimeout(()=> resolve(), 450);
      }

      // Collision helpers
      function circleRectColl(cx,cy,r, rx,ry,rw,rh){
        const nx = Math.max(rx, Math.min(cx, rx+rw));
        const ny = Math.max(ry, Math.min(cy, ry+rh));
        const dx = cx - nx, dy = cy - ny;
        return dx*dx + dy*dy <= r*r;
      }

      function draw(){
        ctx.clearRect(0,0,W,H);
        // bg stars
        ctx.globalAlpha = 0.25; ctx.fillStyle = '#0f1440'; ctx.fillRect(0,0,W,H);
        ctx.globalAlpha = 1;

        // bricks
        for(const b of grid.bricks){
          if(!b.alive && b.popT<=0) continue;
          const r = brickRect(grid,b,W,H);
          if(b.alive){
            // brick frame
            ctx.fillStyle = '#1e2353';
            ctx.fillRect(r.x, r.y, r.w, r.h);
            ctx.strokeStyle = 'rgba(255,255,255,.08)';
            ctx.strokeRect(r.x, r.y, r.w, r.h);
          }
          // emoji
          const scale = b.popT>0 ? 1 + 0.6*(b.popT/1) : 1;
          ctx.font = `bold ${r.font*scale}px system-ui,Segoe UI Emoji,Apple Color Emoji`;
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText(b.emo, r.cx, r.cy);
          if(b.popT>0){ b.popT -= 0.06; }
        }

        // paddle
        ctx.fillStyle = '#6b62ff';
        ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);
  // balls
for(const b of balls){
  ctx.beginPath();
  if(b.isSecondary){
    rainbowHue = (rainbowHue + 3) % 360;
    ctx.fillStyle = `hsl(${rainbowHue}, 85%, 60%)`;
  }else{
    ctx.fillStyle = b.color;
  }
  ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
}

      }

      function step(dt){
  // move balls + accelerate
  for(const b of balls){
    b.x += b.vx*dt*b.speed;
    b.y += b.vy*dt*b.speed;
    b.speed = Math.min(BALL_SPEED_MAX, b.speed + BALL_ACCEL_PER_SEC * dt);
  }

  // walls & miss
  for(const b of balls){
    if(b.x<b.r){ b.x=b.r; b.vx=Math.abs(b.vx); }
    if(b.x>W-b.r){ b.x=W-b.r; b.vx=-Math.abs(b.vx); }
    if(b.y<b.r){ b.y=b.r; b.vy=Math.abs(b.vy); }
  }
  // remove any balls that fell; if none left, end round
  for(let i=balls.length-1;i>=0;i--){
    if(balls[i].y>H+balls[i].r*2) balls.splice(i,1);
  }
  if(balls.length===0){ endRound("Miss"); return; }

  // paddle bounces
  for(const b of balls){
    if(circleRectColl(b.x,b.y,b.r, paddle.x,paddle.y,paddle.w,paddle.h)){
      b.y = paddle.y - b.r;
      b.vy = -Math.abs(b.vy);
      const hit = (b.x - (paddle.x + paddle.w/2)) / (paddle.w/2);
      b.vx = (W*0.22)*hit;
      b.speed = Math.min(BALL_SPEED_MAX, b.speed + PADDLE_HIT_SPEED_BOOST);
    }
  }

  // brick collisions (first hit per frame)
  for(const b of balls){
    for(const brick of grid.bricks){
      if(!brick.alive) continue;
      const r = brickRect(grid,brick,W,H);
      if(circleRectColl(b.x,b.y,b.r, r.x,r.y,r.w,r.h)){
        brick.alive = false; brick.popT = 1.0; broken++; brokenEl.textContent = broken;

        // reflect
        const dx = (b.x - (r.x + r.w/2)) / (r.w/2);
        const dy = (b.y - (r.y + r.h/2)) / (r.h/2);
        if(Math.abs(dx) > Math.abs(dy)) b.vx *= -1; else b.vy *= -1;

        // POWER-UPS
        if(brick.type === "clock"){
          // +10 seconds toast
          timeEl.textContent = (parseInt(timeEl.textContent,10) + TIME_BONUS_SECONDS);
          // also bump the actual counter
          // (we track tLeft in closure; adjust it)
          tLeft += TIME_BONUS_SECONDS;
          toast(`+${TIME_BONUS_SECONDS}s ‚è∞`);
        } else if(brick.type === "disco"){
          if(!haveSecondary && balls.length < MAX_BALLS){
            // spawn a second ball from current position/velocity
            const nb = {
              x: b.x, y: b.y, r: b.r,
              vx: -b.vx, vy: b.vy, // send it a different way
              speed: b.speed, color: '#ffffff', isSecondary:true
            };
            balls.push(nb);
            haveSecondary = true;
            toast("Multiball! ü™©");
          }
        }
        break; // break only the inner bricks loop; next ball can still hit

      }
    }
  }
}


function loop(now){
  if(!running) return;
  if (SECRET_JUMP){ endRound("Secret"); return; }
  const dt = Math.min(0.035, (now-last)/1000); last = now;
  step(dt); draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(t=>{ last=t; loop(t); });

    });
  }

  // -----------------------------
  // Boss Battle
  // -----------------------------
  const bossCanvas = $('#boss'), bctx = bossCanvas.getContext('2d');
  
function sizeBossCanvas(){
  const wrap = document.querySelector('#view-boss .gameWrap');
  const maxW = wrap.clientWidth;
  const maxH = Math.min(window.innerHeight*0.75, 780);
  const aspect = 9/14; // match regular
let w = maxW;
  let h = Math.min(maxH, Math.round(w/aspect));
  bossCanvas.width = Math.floor(w*2); bossCanvas.height = Math.floor(h*2); // hi-dpi
  bossCanvas.style.width = `${w}px`; bossCanvas.style.height = `${h}px`;
}

  window.addEventListener('resize', ()=>{ if($('#view-boss').classList.contains('active')) sizeBossCanvas(); });

  const bossHudHits = $('#bossHits'), shieldLeftEl = $('#shieldLeft'), hpFill = $('#hpFill');
  const bossState = {
    hits:0, hp:5,
    reset(){ this.hits=0; this.hp=5; bossHudHits.textContent='0'; hpFill.style.width='100%'; }
  };

  function startBossBattle(){
    return new Promise(resolve=>{
      show('view-boss'); sizeBossCanvas();
      let W=bossCanvas.width, H=bossCanvas.height;
// Shield line = lowest row (r=3) of the regular 9√ó4 brick grid.
const shield = [];
const g = { cols:9, rows:4 };
for(let c=0;c<g.cols;c++){
  const r = brickRect(g, { c, r:3 }, W, H); // lowest row
  shield.push({
    x:r.x, y:r.y, w:r.w, h:r.h,
    alive:true, hp:2, // 2-hit shield
    emo: EMOJIS[c%EMOJIS.length],
    popT:0
  });
}


      // Boss
const boss = {
  x: W*0.5,
  // hover a bit above the lowest (shield) row; clamp so it doesn't go off-canvas
  y: Math.max(Math.min(H*0.28, shield[0].y - Math.min(W,H)*0.10), Math.min(W,H)*0.08),
  r: Math.min(W,H)*0.08,
  emo:"üòà",
  vx: W*0.09
};

      // Paddle/ball
      const paddle = { w: W*0.20, h: H*0.02, x: W*0.4, y: H*0.90 };
const ball = { x: W*0.5, y: H*0.7, r: Math.max(10, Math.min(W,H)*0.013), vx: W*0.22, vy: -H*0.28, speed:1, prevx: W*0.5, prevy: H*0.7 };

      function setPaddle(clientX){
        const rect = bossCanvas.getBoundingClientRect();
        const x = (clientX - rect.left) * (bossCanvas.width / rect.width);
        paddle.x = Math.max(0, Math.min(W - paddle.w, x - paddle.w/2));
      }
      function onBossMouseMove(e){ setPaddle(e.clientX); }
function onBossTouchStart(e){ if(e.touches[0]) setPaddle(e.touches[0].clientX); }
function onBossTouchMove(e){ if(e.touches[0]) setPaddle(e.touches[0].clientX); }

bossCanvas.addEventListener('mousemove', onBossMouseMove);
bossCanvas.addEventListener('touchstart', onBossTouchStart, {passive:true});
bossCanvas.addEventListener('touchmove', onBossTouchMove, {passive:true});


      let running=true, last=performance.now();
      let usedSecondChance = false; // allow exactly one respawn if the ball is lost


let bossDying = false;
let burst = [];
let burstT = 0; // seconds
let bossHitCooldown = 0;  // already present? keep just one copy

     function endBoss(){
  running=false;
  bossCanvas.removeEventListener('mousemove', onBossMouseMove);
  bossCanvas.removeEventListener('touchstart', onBossTouchStart);
  bossCanvas.removeEventListener('touchmove', onBossTouchMove);
  setTimeout(resolve, 500);
}

      function shieldAliveCount(){ return shield.reduce((n,s)=>n+(s.alive?1:0),0); }

      function circleRectColl(cx,cy,r, rx,ry,rw,rh){
        const nx = Math.max(rx, Math.min(cx, rx+rw));
        const ny = Math.max(ry, Math.min(cy, ry+rh));
        const dx = cx - nx, dy = cy - ny;
        return dx*dx + dy*dy <= r*r;
      }

      // Check if a moving point from (x1,y1)‚Üí(x2,y2) crosses a circle at (cx,cy) with radius r
function segmentCircleHit(x1,y1,x2,y2, cx,cy, r){
  const dx = x2 - x1, dy = y2 - y1;
  const fx = x1 - cx, fy = y1 - cy;
  const a = dx*dx + dy*dy;
  if (a === 0) return (fx*fx + fy*fy) <= r*r; // no movement, treat as point
  const b = 2*(fx*dx + fy*dy);
  const c = (fx*fx + fy*fy) - r*r;
  // Solve quadratic a*t^2 + b*t + c = 0 for t in [0,1]
  const disc = b*b - 4*a*c;
  if (disc < 0) return false;
  const s = Math.sqrt(disc);
  const t1 = (-b - s)/(2*a), t2 = (-b + s)/(2*a);
  return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);
}




// Segment‚Äìcircle time of impact. Returns earliest t in [0,1], or null if no hit.
function segmentCircleTOI(x1,y1,x2,y2, cx,cy, r){
  const dx = x2 - x1, dy = y2 - y1;
  const fx = x1 - cx, fy = y1 - cy;
  const a = dx*dx + dy*dy;
  const b = 2*(fx*dx + fy*dy);
  const c = fx*fx + fy*fy - r*r;
  const disc = b*b - 4*a*c;
  if (a === 0) return (c <= 0) ? 0 : null;      // no movement; treat as at-contact if inside
  if (disc < 0) return null;
  const s = Math.sqrt(disc);
  const t1 = (-b - s) / (2*a);
  const t2 = (-b + s) / (2*a);
  // earliest hit in range
  let t = null;
  if (t1 >= 0 && t1 <= 1) t = t1;
  else if (t2 >= 0 && t2 <= 1) t = t2;
  return t;
}


function easeOutQuad(t){ return 1 - (1 - t)*(1 - t); }

// Create N evenly spaced starburst rays
function createBurst(N=16){
  burst = Array.from({length:N}, (_,i)=>({ ang: (i/N)*Math.PI*2 }));
  burstT = 0;
}


      function draw(){
        bctx.clearRect(0,0,W,H);
          // boss instructions inside the canvas top
  bctx.save();
  bctx.fillStyle = 'rgba(255,255,255,0.9)';
  bctx.textAlign = 'center';
  bctx.textBaseline = 'top';
  bctx.font = `${Math.max(12, Math.floor(H*0.035))}px system-ui, Segoe UI, Arial, sans-serif`;
  bctx.fillText('Hit the Boss 5 times to win (shield optional)!', W/2, 8);
  bctx.restore();

        // bg
        bctx.globalAlpha=.25; bctx.fillStyle='#0f1440'; bctx.fillRect(0,0,W,H); bctx.globalAlpha=1;

        // shield
        for(const s of shield){
          if(!s.alive && s.popT<=0) continue;
  if(s.alive){
    const baseBlue = '#1e2353';
    const hitYellow = '#f5c84c';
    bctx.fillStyle = (s.hp === 1) ? hitYellow : baseBlue; bctx.fillRect(s.x, s.y, s.w, s.h);
    bctx.strokeStyle='rgba(255,255,255,.08)'; bctx.strokeRect(s.x, s.y, s.w, s.h);
  }

          const cx = s.x + s.w/2, cy = s.y + s.h*0.62, font = Math.min(s.w,s.h)*0.7*(s.popT>0?1+s.popT*0.6:1);
          bctx.font = `bold ${font}px system-ui,Segoe UI Emoji,Apple Color Emoji`;
          bctx.textAlign='center'; bctx.textBaseline='middle';
          bctx.fillText(s.emo, cx, cy);
          if(s.popT>0) s.popT -= 0.06;
        }

        // boss
// boss (pop + fade when dying)
let popScale = 1, bossAlpha = 1;
if (bossDying){
  // quick pop for ~0.12s, then fade
  popScale = 1 + Math.min(0.25, burstT * 2.0); // up to +25%
  bossAlpha = Math.max(0, 1 - Math.max(0, burstT - 0.15) / 0.6); // fade after 0.15s
}

// draw boss
bctx.save();
bctx.globalAlpha = bossAlpha;
bctx.font = `bold ${boss.r*1.8*popScale}px system-ui,Segoe UI Emoji,Apple Color Emoji`;
bctx.textAlign='center'; bctx.textBaseline='middle';
bctx.fillText(boss.emo, boss.x, boss.y);
bctx.restore();

// starburst during KO
if (bossDying){
  const prog = easeOutQuad(Math.min(1, burstT / 0.6));     // 0 ‚Üí 1 over ~0.6s
  const L = (Math.min(bossCanvas.width, bossCanvas.height)) * 0.18 * prog; // ray length
  const alpha = 0.9 * (1 - prog);
  bctx.save();
  bctx.globalAlpha = alpha;
  bctx.lineWidth = Math.max(2, 6 * (1 - prog));
  bctx.strokeStyle = '#ffd54a';
  for(const r of burst){
    const x2 = boss.x + Math.cos(r.ang) * L;
    const y2 = boss.y + Math.sin(r.ang) * L;
    bctx.beginPath();
    bctx.moveTo(boss.x, boss.y);
    bctx.lineTo(x2, y2);
    bctx.stroke();
  }
  bctx.restore();
}


        // paddle & ball
       // paddle & (ball hidden during KO)
bctx.fillStyle='#6b62ff'; bctx.fillRect(paddle.x,paddle.y,paddle.w,paddle.h);
if (!bossDying){
  bctx.beginPath(); bctx.fillStyle='#ffd54a';
  bctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2); bctx.fill();
}

      }

      function step(dt){
      bossHitCooldown = Math.max(0, bossHitCooldown - dt);
      let bossCollidedThisFrame = false;

      // If boss is dying, run the animation and exit early
if (bossDying){
  burstT += dt;
  // when animation finishes, end the boss round
  if (burstT >= 0.8){ endBoss(); return; }
  return;
}



      // move ball
ball.prevx = ball.x;            // ‚Üê add these two lines
ball.prevy = ball.y;            // ‚Üê to keep a correct swept segment
ball.x += ball.vx*dt*ball.speed;
ball.y += ball.vy*dt*ball.speed;

// boss horizontal motion: bounce within canvas (small margin)
const margin = Math.max(10, boss.r + 10);
boss.x += boss.vx * dt;
if (boss.x < margin){ boss.x = margin; boss.vx = Math.abs(boss.vx); }
if (boss.x > W - margin){ boss.x = W - margin; boss.vx = -Math.abs(boss.vx); }


      // continuous acceleration (capped)
      ball.speed = Math.min(BALL_SPEED_MAX, ball.speed + BALL_ACCEL_PER_SEC * dt);


        // walls
        if(ball.x<ball.r){ ball.x=ball.r; ball.vx=Math.abs(ball.vx); }
        if(ball.x>W-ball.r){ ball.x=W-ball.r; ball.vx=-Math.abs(ball.vx); }
        if(ball.y<ball.r){ ball.y=ball.r; ball.vy=Math.abs(ball.vy); }
        if(ball.y>H+ball.r*2){
  if(!usedSecondChance){
    usedSecondChance = true;
    // respawn a fresh ball just above the paddle
    ball.x = paddle.x + paddle.w/2;
    ball.y = paddle.y - ball.r - 6;
    ball.vx = 0;
    ball.vy = -Math.abs(H * 0.28); // launch upward at your usual speed scale
    ball.speed = 1;                 // reset speed scaling so it ramps again
    bossHitCooldown = 0;            // avoid immediate re-hit weirdness
    toast("Second chance! ‚úùÔ∏è");
    return; // keep the round going
  } else {
    endBoss(); return; // already used the extra ball ‚Üí round ends
  }
}


        // paddle
        if(circleRectColl(ball.x,ball.y,ball.r, paddle.x,paddle.y,paddle.w,paddle.h)){
          ball.y = paddle.y - ball.r;
          ball.vy = -Math.abs(ball.vy);
          const hit = (ball.x - (paddle.x + paddle.w/2)) / (paddle.w/2);
          ball.vx = (W*0.22)*hit;
        ball.speed = Math.min(BALL_SPEED_MAX, ball.speed + PADDLE_HIT_SPEED_BOOST);
        }

 
        // --- Boss collision FIRST (robust TOI), then shield ---

// Boss hits count even if the shield is still up ‚Äî robust TOI collision
const Rsum = boss.r + ball.r;
const toi = segmentCircleTOI(ball.prevx, ball.prevy, ball.x, ball.y, boss.x, boss.y, Rsum);

if (toi !== null && bossHitCooldown <= 0){
  bossHitCooldown = 0.15; // one contact = one hit
  bossCollidedThisFrame = true;

  // Contact point along the segment
  const cx = ball.prevx + (ball.x - ball.prevx) * toi;
  const cy = ball.prevy + (ball.y - ball.prevy) * toi;

  // Outward normal from boss center to contact
  let nx = cx - boss.x, ny = cy - boss.y;
  let nlen = Math.hypot(nx, ny) || 1;
  nx /= nlen; ny /= nlen;

  // Reflect velocity across the normal, preserving speed
  const speedMag = Math.hypot(ball.vx, ball.vy) || 0;
  const dot = ball.vx*nx + ball.vy*ny;
  ball.vx = ball.vx - 2*dot*nx;
  ball.vy = ball.vy - 2*dot*ny;

  // Re-normalize to original speed
  const newMag = Math.hypot(ball.vx, ball.vy) || 1;
  ball.vx = ball.vx / newMag * speedMag;
  ball.vy = ball.vy / newMag * speedMag;

  // Place ball just outside at impact and nudge outward (a bit stronger for HiDPI)
  const EPS = 6;
  ball.x = boss.x + nx * (Rsum + EPS);
  ball.y = boss.y + ny * (Rsum + EPS);

  // Advance the remainder of this frame along the new velocity (prevents "sticky" looks)
  const rem = (1 - toi);
  if (rem > 0){
    ball.x += ball.vx * dt * ball.speed * rem;
    ball.y += ball.vy * dt * ball.speed * rem;
  }

  // Reset prev to the new post-collision position
  ball.prevx = ball.x;
  ball.prevy = ball.y;

  // Count the hit and update UI
  score += BOSS_HIT_POINTS; updateScore();
  toast(`+${BOSS_HIT_POINTS} pts üòà`);

  bossState.hits = Math.min(5, bossState.hits+1);
  bossHudHits.textContent = bossState.hits;
  const pct = (1 - bossState.hits/5)*100;
  hpFill.style.width = `${pct}%`;

  if (bossState.hits >= 5){
    bossDying = true;
    createBurst(16);
    return; // step() will animate & call endBoss()
  }
}

// Only try shield bricks if we DIDN'T already collide with the boss this frame
if (!bossCollidedThisFrame){
  // shield collisions (2-hit: blue -> yellow -> break)
  for(const s of shield){
    if(!s.alive) continue;
    if(circleRectColl(ball.x,ball.y,ball.r, s.x,s.y,s.w,s.h)){
      // reflect as before
      const dx = (ball.x - (s.x + s.w/2)) / (s.w/2);
      const dy = (ball.y - (s.y + s.h/2)) / (s.h/2);
      if(Math.abs(dx)>Math.abs(dy)) ball.vx*=-1; else ball.vy*=-1;

      if (s.hp > 1){
        // first hit: turn yellow, keep alive
        s.hp = 1;
        s.popT = 0.6; // tiny pop flash if you like
      } else {
        // second hit: break + points
        s.alive = false;
        s.popT = 1.0;
        score += SHIELD_POINTS; updateScore();
        toast(`+${SHIELD_POINTS} pts üõ°Ô∏è`);
      }
      break; // one shield brick per frame
    }
  }
}


// update HUD after shield/boss handling
const left = shieldAliveCount();
shieldLeftEl.textContent = left;




      }

      function loop(now){
        if(!running) return;
        const dt = Math.min(0.035,(now-last)/1000); last=now;
        step(dt); draw();
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(t=>{ last=t; loop(t); });
    });
  }

  function showEnd(){
    $('#finalScore').textContent = score;
    $('#finalBroken').textContent = totalBroken;
    $('#finalBoss').textContent = bossState.hits;
    show('view-end');
  }

  // -----------------------------
  // Initial title after splash modal confirming controls
  // -----------------------------
  (async function boot(){
    await new Promise(r=> setTimeout(r, 50)); // allow DOM paint
    // After splash OK, we show title (handled by btn)
    // Show a quick tip when entering title
document.getElementById('btnSplashOk').addEventListener('click', async ()=>{
  // move to Title immediately so it feels like we "started"
  show('view-title');
  // then show the quick welcome tip on top
  await modal("Welcome!", "Answer each question. Then use the paddle to bounce the ball and break the emoji.<br><br><b>Tip:</b> Touch or move your mouse to control the paddle.");
}, {once:true});

  })();

})();
</script>
</body>
</html>
