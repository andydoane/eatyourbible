<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Emoji Hunt ‚Äî Educational Game</title>
<style>
  :root{
    --bg:#0f172a;            /* slate-900 */
    --panel:#111827;         /* gray-900 */
    --panel-soft:#1f2937;    /* gray-800 */
    --accent:#22c55e;        /* green-500 */
    --accent-2:#38bdf8;      /* sky-400 */
    --warn:#f59e0b;          /* amber-500 */
    --danger:#ef4444;        /* red-500 */
    --text:#e5e7eb;          /* gray-200 */
    --muted:#94a3b8;         /* slate-400 */
    --btn:#334155;           /* slate-700 */
    --btn-hover:#3f4b63;     /* slightly lighter */
    --shadow: 0 12px 24px rgba(0,0,0,.35);
    --radius: 18px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol", sans-serif;
    color:var(--text);
    background: radial-gradient(1200px 800px at 50% -10%, #1e293b, #0b1224 60%, #060b16 100%);
    display:flex;
    align-items:center;
    justify-content:center;
    -webkit-tap-highlight-color: transparent;
    user-select:none;
    touch-action: manipulation;
  }
  .app{
    width:min(100vw, 900px);
    height:min(100vh, 1600px);
    padding: clamp(10px, 2vmin, 18px);
    display:flex;
    align-items:stretch;
    justify-content:center;
  }
  .card{
    background:linear-gradient(180deg, var(--panel), var(--panel-soft));
    border:1px solid #1f2937;
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    width:100%;
    overflow:hidden;
    display:flex;
    flex-direction:column;
  }
  header.topbar{
    display:flex; align-items:center; justify-content:space-between;
    padding: clamp(10px, 2.5vmin, 18px) clamp(12px, 3vmin, 24px);
    background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.01));
    border-bottom:1px solid #1f2937;
    gap:10px;
  }
  .brand{
    font-weight:800; letter-spacing:.3px;
    font-size: clamp(16px, 2.5vmin, 20px);
    display:flex; align-items:center; gap:.5ch;
  }
  .pill{
    background:#0b1224; border:1px solid #1f2937; border-radius:999px;
    padding:.35rem .75rem; font-size: clamp(12px, 2vmin, 14px); color:var(--muted);
  }
  .content{
    flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center;
    padding: clamp(14px, 4vmin, 28px);
    gap: clamp(12px, 2.5vmin, 20px);
  }
  .screen{display:none; width:100%; height:100%;}
  .screen.active{display:flex; flex-direction:column;}
  h1,h2,h3{margin:.2em 0}
  h1{
    font-size: clamp(28px, 6.5vmin, 42px);
    line-height:1.05;
    text-align:center;
    background: linear-gradient(90deg, #a5b4fc, #60a5fa, #34d399);
    -webkit-background-clip:text; background-clip:text; color:transparent;
  }
  h2{ font-size:clamp(20px, 4.5vmin, 28px); text-align:center; color:#dbeafe }
  p.lead{ color:var(--muted); text-align:center; font-size:clamp(14px, 3.5vmin, 18px)}
  .stack{ display:flex; flex-direction:column; gap: clamp(10px, 2.5vmin, 16px); width:100%; }
  .row{ display:flex; flex-wrap:wrap; gap: clamp(8px, 2vmin, 12px); justify-content:center; }
  button{
    appearance:none; border:none; cursor:pointer; color:var(--text);
    background:var(--btn); padding: clamp(10px, 2.7vmin, 16px) clamp(14px, 3.5vmin, 22px);
    border-radius: 12px; font-weight:700; letter-spacing:.2px;
    box-shadow: 0 4px 0 rgba(0,0,0,.35);
    transition: transform .05s ease, background .15s ease, box-shadow .15s ease, opacity .15s ease;
    font-size: clamp(14px, 3.7vmin, 18px);
  }
  button:hover{ background:var(--btn-hover) }
  button:active{ transform: translateY(1px); box-shadow: 0 2px 0 rgba(0,0,0,.35) }
  .btn-accent{ background: linear-gradient(180deg, #22c55e, #16a34a); }
  .btn-warn{ background: linear-gradient(180deg, #f59e0b, #d97706); }
  .btn-danger{ background: linear-gradient(180deg, #ef4444, #dc2626); }
  .btn-ghost{
    background: transparent; border:1px dashed #334155; color:#cbd5e1;
  }
  .panel-soft{
    background:rgba(255,255,255,.03); border:1px solid #1f2937; border-radius:12px;
    padding: clamp(10px, 2.7vmin, 18px);
  }
  .center{ text-align:center }
  .emoji{ font-size: clamp(20px, 7vmin, 48px); line-height:1 }
  .answers{
    display:grid; gap: clamp(8px, 2.4vmin, 14px);
    grid-template-columns: repeat(2, minmax(0,1fr));
    width:100%;
  }
  .answer{
    display:flex; align-items:center; justify-content:center; gap:.6ch;
    min-height: clamp(44px, 8vmin, 64px);
    text-wrap:balance; text-align:center;
  }
  .hud{
    display:flex; gap:8px; align-items:center; justify-content:center; flex-wrap:wrap;
    color:#cbd5e1; font-weight:700;
  }
  .hud .stat{ background:#0b1224; border:1px solid #1f2937; padding:.4rem .7rem; border-radius:10px; }
  .grid{
    width:100%;
    max-width: min(100%, 800px);
    aspect-ratio: 1/1;
    display:grid;
    grid-template-columns: repeat(6, 1fr);
    grid-auto-rows: 1fr;
    gap: clamp(4px, 1.25vmin, 10px);
    padding: clamp(8px, 2vmin, 14px);
    background:rgba(255,255,255,.03);
    border:1px solid #1f2937; border-radius:12px;
  }
  .cell{
    display:flex; align-items:center; justify-content:center;
    background: #0b1224;
    border:1px solid #1f2937; border-radius:10px;
    font-size: clamp(18px, 6.2vmin, 40px);
    transition: transform .06s ease, background .15s ease, opacity .15s ease;
    touch-action: manipulation;
  }
  .cell.correct.popped{ background: rgba(34,197,94,.18); transform: scale(.94); }
  .cell.wrong.flash{ background: rgba(239,68,68,.25); }
  .footer-cta{ margin-top:auto; display:flex; justify-content:center }
  /* Modal */
  .modal-backdrop{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center;
    background:rgba(3,6,17,.6); backdrop-filter: blur(2px);
    z-index:50; padding: 20px;
  }
  .modal-backdrop.show{ display:flex }
  .modal{
    width:min(560px, 96vw);
    background: linear-gradient(180deg, #0f172a, #0b1224 70%);
    border:1px solid #1f2937; border-radius:16px;
    box-shadow: var(--shadow);
    padding: clamp(16px, 4vmin, 22px);
    display:flex; flex-direction:column; gap:12px; text-align:center;
  }
  .modal h3{ font-size: clamp(18px, 4.8vmin, 26px) }
  .modal p{ color:#cbd5e1; font-size: clamp(14px, 3.8vmin, 18px) }
  /* Responsive hint at top */
  .hint{
    font-size: clamp(12px, 2.5vmin, 14px); color:var(--muted); text-align:center;
  }
  /* Make buttons comfortably large on touch devices */
  @media (hover:none){
    button{ padding: 14px 18px }
  }
</style>
</head>
<body>
  <div class="app">
    <div class="card">
      <header class="topbar">
        <div class="brand"><span class="emoji" aria-hidden="true">üìñ</span>Emoji Hunt</div>
        <div class="hud">
          <div class="stat" id="hudScore">Score: 0</div>
          <div class="stat" id="hudTimer" style="display:none">Time: 20</div>
         <div class="stat" id="hudQ">Q: 0/0</div>

        </div>
      </header>

      <!-- Screens -->
      <main class="content">

        <!-- Splash (orientation prompt) -->
        <section id="screen-splash" class="screen active">
          <div class="stack center">
            <h1>Best in <span style="color:#60a5fa">Vertical</span> Mode</h1>
            <p class="lead">You can play in any orientation, but portrait is easiest on phones.</p>
            <div class="row">
              <button class="btn-accent" id="btn-splash-ok">Okay, let‚Äôs play!</button>
            </div>
          </div>
        </section>

        <!-- Title -->
        <section id="screen-title" class="screen">
          <div class="stack center">
            <h1>Emoji Hunt</h1>
            <p class="lead">Answer the question, then tap every matching emoji in the grid before time runs out. Finish all questions to unlock the bonus round!</p>
            <div class="row" style="justify-content:center">
              <button class="btn-accent" id="btn-start">Start Game</button>
              <button class="btn-ghost" id="btn-how">How to Play</button>
            </div>
            <div class="panel-soft hint">
              Tip: Each grid has 36 squares with an equal number of the four answer emojis (9 each).
            </div>
          </div>
        </section>

        <!-- Question -->
        <section id="screen-question" class="screen">
          <div class="stack" style="gap: clamp(14px, 3.5vmin, 18px)">
            <h2 id="qText">Question goes here</h2>
            <div class="answers" id="answers"></div>
          </div>
        </section>

        <!-- Grid mini-game -->
        <section id="screen-grid" class="screen">
          <div class="stack">
            <h2 id="gridTitle">Find all the ‚Ä¶</h2>
            <div class="row" style="justify-content:center; gap:10px; margin-bottom:4px;">
              <div class="pill">Time left: <span id="gridTime">20</span>s</div>
              <div class="pill">Remaining: <span id="gridRemaining">9</span></div>
            </div>
            <div class="grid" id="grid"></div>
          </div>
        </section>

        <!-- Bonus round (slot machine) -->
        <section id="screen-bonus" class="screen">
          <div class="stack center">
            <h2>Bonus Round üé∞</h2>
           <p class="lead">Reels start automatically. Tap each emoji box to stop it‚Äîmatch three to win a bonus!</p>

            <div class="panel-soft" style="display:flex; gap:14px; justify-content:center; align-items:center; flex-wrap:wrap">
              <div class="reelbox" style="display:flex; gap:12px; align-items:center">
                <div class="panel-soft" style="width:90px; height:90px; display:flex; align-items:center; justify-content:center; font-size:52px" id="reel0">üçí</div>
             
              </div>
              <div class="reelbox" style="display:flex; gap:12px; align-items:center">
                <div class="panel-soft" style="width:90px; height:90px; display:flex; align-items:center; justify-content:center; font-size:52px" id="reel1">üçã</div>
                
              </div>
              <div class="reelbox" style="display:flex; gap:12px; align-items:center">
                <div class="panel-soft" style="width:90px; height:90px; display:flex; align-items:center; justify-content:center; font-size:52px" id="reel2">üçá</div>
                
              </div>
            </div>
             <div class="panel-soft" style="font-size:14px; color:#cbd5e1">
              Payouts (all three match): 7Ô∏è‚É£ +500 ‚Ä¢ üîî +300 ‚Ä¢ üçá +250 ‚Ä¢ üçí +200 ‚Ä¢ üçã +150
            </div>
          </div>
        </section>

        <!-- End screen -->
        <section id="screen-end" class="screen">
          <div class="stack center">
            <h1>Great job!</h1>
            <p class="lead">Your final score:</p>
            <div class="emoji" id="finalScore" style="font-size: clamp(28px, 9vmin, 72px)">0</div>
            <div class="row" style="justify-content:center">
              <button class="btn-accent" id="btn-play-again">Play Again</button>
              <button class="btn-ghost" id="btn-title">Back to Title</button>
            </div>
          </div>
        </section>

      </main>
    </div>
  </div>

  <!-- Modal -->
  <div class="modal-backdrop" id="modal">
    <div class="modal">
      <h3 id="modalTitle">Title</h3>
      <p id="modalMsg">Message</p>
      <div class="row" style="justify-content:center">
        <button class="btn-accent" id="modalOk">OK</button>
      </div>
    </div>
  </div>

<script>
(()=> {
  // -----------------------------
  // Data (questions with emojis)
  // -----------------------------
  // Each option has text and emoji; `correct` is the index of the correct option.

/* 
   ____    _    _   ______    _____   _______   _____    ____    _   _    _____ 
  / __ \  | |  | | |  ____|  / ____| |__   __| |_   _|  / __ \  | \ | |  / ____|
 | |  | | | |  | | | |__    | (___      | |      | |   | |  | | |  \| | | (___  
 | |  | | | |  | | |  __|    \___ \     | |      | |   | |  | | | . ` |  \___ \ 
 | |__| | | |__| | | |____   ____) |    | |     _| |_  | |__| | | |\  |  ____) |
  \___\_\  \____/  |______| |_____/     |_|    |_____|  \____/  |_| \_| |_____/ 


*/


const QUESTIONS = [
  {
    prompt: "What did God say would happen if they ate from the Tree of the Knowledge of Good and Evil?",
    options: [
      { text: "They‚Äôd die", emoji: "üíÄ" },
      { text: "They‚Äôd become angels", emoji: "üòá" },
      { text: "They‚Äôd turn into gods", emoji: "üóø" },
      { text: "They‚Äôd be kings", emoji: "üëë" }
    ],
    correct: 0
  },
  {
    prompt: "Who was the serpent who came to Eve?",
    options: [
      { text: "The devil", emoji: "üëø" },
      { text: "Just a normal snake", emoji: "üêç" },
      { text: "A talking bird", emoji: "üê¶" },
      { text: "An angel", emoji: "üëº" }
    ],
    correct: 0
  },
  {
    prompt: "What did the serpent say to Eve?",
    options: [
      { text: "You won‚Äôt die; you‚Äôll know good and evil like God", emoji: "üß†" },
      { text: "God told me to bring you fruit", emoji: "üçé" },
      { text: "God isn‚Äôt real", emoji: "üôÖ‚Äç‚ôÇÔ∏è" },
      { text: "You should build a boat", emoji: "üõ∂" }
    ],
    correct: 0
  },
  {
    prompt: "After talking with the serpent, what did Eve do?",
    options: [
      { text: "Ate the fruit and gave some to her husband", emoji: "üçé" },
      { text: "Ran away", emoji: "üèÉ‚Äç‚ôÄÔ∏è" },
      { text: "Built an altar", emoji: "üïØÔ∏è" },
      { text: "Threw the fruit away", emoji: "üóëÔ∏è" }
    ],
    correct: 0
  },
  {
    prompt: "What did Adam and Eve realize after eating? What did they do?",
    options: [
      { text: "Realized they were naked; made clothes and hid", emoji: "ü´£" },
      { text: "They learned to read", emoji: "üìñ" },
      { text: "They built a house", emoji: "üè†" },
      { text: "They named the animals", emoji: "ü¶ì" }
    ],
    correct: 0
  },
  {
    prompt: "What curses did God give to the serpent?",
    options: [
      { text: "To crawl on his belly, to be crushed by a son of Eve", emoji: "üêç" },
      { text: "To lose all color", emoji: "üé®" },
      { text: "To become a fish", emoji: "üêü" },
      { text: "To turn into a bird", emoji: "üê¶" }
    ],
    correct: 0
  },
  {
    prompt: "What curses did God give to the woman?",
    options: [
      { text: "Great pain during childbirth and battles with her husband", emoji: "üë∂" },
      { text: "No more food", emoji: "üçΩÔ∏è" },
      { text: "Never sleep again", emoji: "üò¥" },
      { text: "She couldn‚Äôt talk", emoji: "ü§ê" }
    ],
    correct: 0
  },
  {
    prompt: "What curses did God give the man?",
    options: [
      { text: "Frustrating and hard work, and death", emoji: "üßë‚Äçüåæ" },
      { text: "Fear of heights", emoji: "ü™ú" },
      { text: "Lose his memory", emoji: "üß†" },
      { text: "Must sail forever", emoji: "‚õµ" }
    ],
    correct: 0
  },
  {
    prompt: "After giving them curses, what did God do to the man and woman?",
    options: [
      { text: "Clothed them with animal skins, drove them out of the garden", emoji: "üß•" },
      { text: "Let them stay in the garden", emoji: "üè°" },
      { text: "Gave them a car", emoji: "üöó" },
      { text: "Sent them back in time", emoji: "‚è≥" }
    ],
    correct: 0
  },
  {
    prompt: "Who was the mysterious son of Eve who came to crush the serpent? How did he do it?",
    options: [
      { text: "Jesus‚ÄîHe defeated sin by dying on the cross and rising from the dead", emoji: "‚úùÔ∏è" },
      { text: "Moses", emoji: "üìú" },
      { text: "David", emoji: "üéØ" },
      { text: "Noah", emoji: "üõ∂" }
    ],
    correct: 0
  }
];



/*
  ______   _   _   _____  
 |  ____| | \ | | |  __ \ 
 | |__    |  \| | | |  | |
 |  __|   | . ` | | |  | |
 | |____  | |\  | | |__| |
 |______| |_| \_| |_____/ 

*/





  // Slot machine emoji (fixed order, skill timing)
  const SLOT_ORDER = ["üçí","üçã","üçá","üîî","7Ô∏è‚É£"];

  const REEL_BASE_MS = 240; // increase to slow down; decrease to speed up

const PAYOUTS = { "üçí":200, "üçã":150, "üçá":250, "üîî":300, "7Ô∏è‚É£":500 };


  // -----------------------------
  // State
  // -----------------------------
  let score = 0;
  let qIndex = 0;

  // Grid mini-game
  const GRID_SIZE = 6; // 6x6
  const TOTAL_CELLS = GRID_SIZE * GRID_SIZE; // 36
  const PER_EMOJI = TOTAL_CELLS / 4; // 9 of each emoji
  let targetEmoji = "üçû";
  let remainingCorrect = PER_EMOJI;
  let gridTimer = null;
  let timeLeft = 20;

  // Bonus round (reels)
  let reelIntervals = [null, null, null];
  let reelRunning = [false,false,false];
  let reelIndex = [0,1,2]; // starting positions in SLOT_ORDER

  // -----------------------------
  // Elements
  // -----------------------------
  const screens = {
    splash:  document.getElementById('screen-splash'),
    title:   document.getElementById('screen-title'),
    question:document.getElementById('screen-question'),
    grid:    document.getElementById('screen-grid'),
    bonus:   document.getElementById('screen-bonus'),
    end:     document.getElementById('screen-end'),
  };
  const hudScore = document.getElementById('hudScore');
  const hudTimer = document.getElementById('hudTimer');
  const hudQ = document.getElementById('hudQ');
hudQ.textContent = `Q: 0/${QUESTIONS.length}`;


  const btnSplashOk = document.getElementById('btn-splash-ok');
  const btnStart = document.getElementById('btn-start');
  const btnHow = document.getElementById('btn-how');

  const qText = document.getElementById('qText');
  const answersBox = document.getElementById('answers');

  const gridEl = document.getElementById('grid');
  const gridTitle = document.getElementById('gridTitle');
  const gridTime = document.getElementById('gridTime');
  const gridRemaining = document.getElementById('gridRemaining');

  const reel0 = document.getElementById('reel0');
  const reel1 = document.getElementById('reel1');
  const reel2 = document.getElementById('reel2');
[reel0, reel1, reel2].forEach((el, i) => {
  el.addEventListener('click', () => stopReel(i));
});


  const finalScore = document.getElementById('finalScore');
  const btnPlayAgain = document.getElementById('btn-play-again');
  const btnTitle = document.getElementById('btn-title');

  // Modal
  const modal = document.getElementById('modal');
  const modalTitle = document.getElementById('modalTitle');
  const modalMsg = document.getElementById('modalMsg');
  const modalOk = document.getElementById('modalOk');
  let modalCallback = null;

  // -----------------------------
  // Helpers
  // -----------------------------
  function showScreen(key){
    Object.values(screens).forEach(s => s.classList.remove('active'));
    screens[key].classList.add('active');
  }

  function updateHUD(){
    hudScore.textContent = `Score: ${score}`;
    hudQ.textContent = `Q: ${Math.min(qIndex+1, QUESTIONS.length)}/${QUESTIONS.length}`;
  }

  function shuffle(arr){
    for(let i = arr.length - 1; i > 0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function openModal(title, msg, onOk=null){
    modalTitle.textContent = title;
    modalMsg.textContent = msg;
    modal.classList.add('show');
    modalCallback = onOk || null;
  }
  function closeModal(){
    modal.classList.remove('show');
    const cb = modalCallback;
    modalCallback = null;
    if(typeof cb === 'function') cb();
  }

  function startGame(){
    score = 0;
    qIndex = 0;
    updateHUD();
    showQuestion();
  }

  // -----------------------------
  // Question Flow
  // -----------------------------
  function showQuestion(){
    showScreen('question');
    hudTimer.style.display = 'none';
    const q = QUESTIONS[qIndex];
    qText.textContent = q.prompt;

    answersBox.innerHTML = '';
    q.options.forEach((opt, i)=>{
      const btn = document.createElement('button');
      btn.className = 'answer';
      btn.innerHTML = `<span class="emoji" aria-hidden="true">${opt.emoji}</span> ${opt.text}`;
      btn.addEventListener('click', ()=>handleAnswer(i));
      answersBox.appendChild(btn);
    });
    updateHUD();
  }

  function handleAnswer(choiceIndex){
    const q = QUESTIONS[qIndex];
    const isCorrect = (choiceIndex === q.correct);
    if(isCorrect){
      score += 100;
      updateHUD();
      openModal("Correct! ‚úÖ", "Great job! Now get ready for the emoji hunt.", () => {
        // Tell them what to find, then go to grid
        const target = q.options[q.correct].emoji;
        openModal("Find them!", `Find all the ${target} emojis!`, ()=>{
          startGrid(q);
        });
      });
    } else {
      score = Math.max(0, score - 50);
      updateHUD();
      openModal("Not quite ‚ùå", "Keep going! You‚Äôll nail the grid round.", () => {
        const target = q.options[q.correct].emoji;
        openModal("Find them!", `Find all the ${target} emojis!`, ()=>{
          startGrid(q);
        });
      });
    }
  }

  // -----------------------------
  // Grid Mini-Game
  // -----------------------------

 
// -----------------------------
// SoundFX (WebAudio) ‚Äî sampler-accurate pops + buzz
// -----------------------------
let _audioCtx = null;
function ensureAudio(){
  if(!_audioCtx){
    _audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if(_audioCtx.state === 'suspended'){
    _audioCtx.resume();
  }
  return _audioCtx;
}

// Simple sustained tone (used for buzz)
function tone({type='sine', f=880, dur=0.14, g=0.28}){
  return new Promise(res=>{
    const c = ensureAudio(); if(!c) return res();
    const o = c.createOscillator(), V = c.createGain();
    o.type = type; o.frequency.value = f;
    V.gain.setValueAtTime(0.0001, c.currentTime);
    V.gain.exponentialRampToValueAtTime(g, c.currentTime+0.01);
    V.gain.exponentialRampToValueAtTime(0.0001, c.currentTime+dur);
    o.connect(V); V.connect(c.destination);
    o.start(); o.stop(c.currentTime + dur + 0.02);
    o.onended = res;
  });
}

// ‚ÄúPop‚Äù = short tone with quick decay + pitch sweep (+ optional lowpass and micro-click)
function pop({type='sine', f0=900, f1=600, dur=0.10, gain=0.8, lowpass=null, click=false}={}){
  return new Promise(res=>{
    const c = ensureAudio(); if(!c) return res();
    const o = c.createOscillator();
    const V = c.createGain();
    let out = V;

    o.type = type;
    o.frequency.setValueAtTime(f0, c.currentTime);
    o.frequency.exponentialRampToValueAtTime(Math.max(40, f1), c.currentTime + dur*0.85);

    // amplitude: fast attack, fast decay
    V.gain.setValueAtTime(0.0001, c.currentTime);
    V.gain.exponentialRampToValueAtTime(gain, c.currentTime + 0.008);
    V.gain.exponentialRampToValueAtTime(0.0001, c.currentTime + dur);

    if (lowpass){
      const lp = c.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.setValueAtTime(lowpass, c.currentTime);
      V.connect(lp); out = lp;
    }

    if (click){
      const C = c.createGain();
      const t0 = c.currentTime;
      C.gain.setValueAtTime(0.0001, t0);
      C.gain.linearRampToValueAtTime(0.25, t0 + 0.003);
      C.gain.linearRampToValueAtTime(0.0001, t0 + 0.02);
      const n = c.createOscillator();
      n.type = 'square'; n.frequency.setValueAtTime(2000, t0);
      n.connect(C); C.connect(c.destination);
      n.start(t0); n.stop(t0 + 0.03);
    }

    o.connect(V); out.connect(c.destination);
    o.start();
    o.stop(c.currentTime + dur + 0.02);
    o.onended = res;
  });
}

// Named sounds (matching your sampler)
const Sounds = {
  "Pop ‚Äì short sine blip": () => pop({type:'sine',     f0:900,  f1:650, dur:0.09, gain:0.80}),
  "Pop ‚Äì bright bubble":   () => pop({type:'sine',     f0:1200, f1:500, dur:0.12, gain:0.75}),
  "Pop ‚Äì soft thup":       () => pop({type:'triangle', f0:520,  f1:320, dur:0.12, gain:0.70, lowpass:1200}),
  "Pop ‚Äì plucky up":       () => pop({type:'sine',     f0:500,  f1:950, dur:0.10, gain:0.70}),
  "Bad ‚Äì low buzz":        () => tone({type:'sawtooth',f:220,            dur:0.18, g:0.28})
};

// Random picker for correct pops ‚Äî never repeat back-to-back
const CORRECT_KEYS = [
  "Pop ‚Äì short sine blip",
  "Pop ‚Äì bright bubble",
  "Pop ‚Äì soft thup",
  "Pop ‚Äì plucky up"
];
let _lastCorrectKey = null;

function playCorrectRandomNoRepeat(){
  ensureAudio();
  const pool = CORRECT_KEYS.filter(k => k !== _lastCorrectKey);
  const key = pool[Math.floor(Math.random() * pool.length)];
  _lastCorrectKey = key;
  return Sounds[key]();
}
function playWrongBuzz(){
  ensureAudio();
  return Sounds["Bad ‚Äì low buzz"]();
}

window.SoundFX = {
  playCorrect: playCorrectRandomNoRepeat,
  playWrong: playWrongBuzz
};

function startGrid(q){


    showScreen('grid');
    const fourEmojis = q.options.map(o => o.emoji);
    targetEmoji = q.options[q.correct].emoji;
    gridTitle.textContent = `Find all the ${targetEmoji} emojis`;
    remainingCorrect = PER_EMOJI;
    gridRemaining.textContent = remainingCorrect;
    timeLeft = 20;
    gridTime.textContent = timeLeft;
    hudTimer.style.display = 'block';
    document.getElementById('hudTimer').textContent = `Time: ${timeLeft}`;

    // Build equal distribution (9 of each emoji), then shuffle
    const pool = [];
    for(let i=0;i<4;i++){
      for(let j=0;j<PER_EMOJI;j++){
        pool.push(fourEmojis[i]);
      }
    }
    shuffle(pool);

    // Render cells
    gridEl.innerHTML = '';
    pool.forEach(emo=>{
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.textContent = emo;
      cell.dataset.emoji = emo;
      cell.addEventListener('click', ()=> onCellClick(cell));
      gridEl.appendChild(cell);
    });

    // Start timer
    if(gridTimer) clearInterval(gridTimer);
    gridTimer = setInterval(()=>{
      timeLeft--;
      gridTime.textContent = timeLeft;
      document.getElementById('hudTimer').textContent = `Time: ${timeLeft}`;
      if(timeLeft<=0){
        endGrid(false);
      }
    }, 1000);

}
  function onCellClick(cell){
    const emo = cell.dataset.emoji;
    if(cell.classList.contains('popped')) return;

    if(emo === targetEmoji){
      cell.classList.add('correct','popped');
      remainingCorrect--;
      gridRemaining.textContent = remainingCorrect;
      score += 10; // per correct
      updateHUD();
      SoundFX.playCorrect();
      if(remainingCorrect<=0){
        // Finished early ‚Äî add time bonus (5 points per second left)
        const bonus = Math.max(0, timeLeft * 5);
        score += bonus;
        updateHUD();

        endGrid(true, bonus);
      }
    } else {
      // penalty and quick flash
      score = Math.max(0, score - 25);
      updateHUD();
      SoundFX.playWrong();
      cell.classList.add('wrong','flash');
      setTimeout(()=> cell.classList.remove('flash'), 150);
    }
  }

  function endGrid(completedEarly, bonus=0){
    if(gridTimer) clearInterval(gridTimer);
    gridTimer = null;
    hudTimer.style.display = 'none';
    const msg = completedEarly
      ? `You found them all! Time bonus: +${bonus} points.`
      : `Time's up! Keep going ‚Äî you‚Äôve got this.`;
    openModal(completedEarly ? "Nice work! üéâ" : "Time Up ‚è∞", msg, ()=>{
      qIndex++;
      if(qIndex < QUESTIONS.length){
        showQuestion();
      } else {
        // Go to bonus
        showScreen('bonus');
resetReels();
startReels();

      }
    });
  }

  // Optional Skip button (useful for demos / accessibility)

  // -----------------------------
  // Bonus Round (Skill Slots)
  // -----------------------------
  function resetReels(){
    [reel0,reel1,reel2].forEach((r,i)=>{
      reelIndex[i] = i % SLOT_ORDER.length;
      r.textContent = SLOT_ORDER[reelIndex[i]];
    });
    reelRunning = [false,false,false];
  }

  function startReels(){
    // Start each with slight offset speeds to make timing matter
    const speeds = [REEL_BASE_MS, REEL_BASE_MS + 40, REEL_BASE_MS + 80];

    [0,1,2].forEach(i=>{
      reelRunning[i] = true;
      reelIntervals[i] = setInterval(()=>{
        reelIndex[i] = (reelIndex[i] + 1) % SLOT_ORDER.length;
        const emoji = SLOT_ORDER[reelIndex[i]];
        [reel0,reel1,reel2][i].textContent = emoji;
      }, speeds[i]);
    });
    
  }

  function stopReel(i){
    if(!reelRunning[i]) return;
    clearInterval(reelIntervals[i]);
    reelIntervals[i] = null;
    reelRunning[i] = false;

    // When all stopped, score result
    if(!reelRunning[0] && !reelRunning[1] && !reelRunning[2]){
      const vals = [reel0.textContent, reel1.textContent, reel2.textContent];
      let bonus = 0;
      if(vals[0] === vals[1] && vals[1] === vals[2]){
        bonus = PAYOUTS[vals[0]] || 0;
        score += bonus;
        updateHUD();
        openModal("Jackpot! üéâ", `All three ${vals[0]} ‚Äî bonus +${bonus}!`, ()=> {
          showEnd();
        });
      } else {
        // Small consolation for playing
        bonus = 50;
        score += bonus;
        updateHUD();
        openModal("Nice try! ‚≠ê", `No match this time. Consolation +${bonus}.`, ()=> {
          showEnd();
        });
      }
    }
  }

  function showEnd(){
  // stop any reels just in case
  [0,1,2].forEach(i => {
    if (reelIntervals[i]) {
      clearInterval(reelIntervals[i]);
      reelIntervals[i] = null;
      reelRunning[i] = false;
    }
  });

    showScreen('end');
    finalScore.textContent = score.toString();
  }

  // -----------------------------
  // Event wiring
  // -----------------------------
  btnSplashOk.addEventListener('click', ()=> showScreen('title'));
  btnHow.addEventListener('click', ()=>{
    openModal("How to Play", "Answer each question. Then tap every matching emoji in the 6√ó6 grid before time runs out. Finishing early gives a time bonus. At the end, try the skill-based bonus round: time your taps to match three!", null);
  });
  btnStart.addEventListener('click', startGame);

  modalOk.addEventListener('click', closeModal);

  // Bonus controls

  btnPlayAgain.addEventListener('click', ()=>{
    showScreen('title');
  });
  btnTitle.addEventListener('click', ()=>{
    showScreen('title');
  });

// Secret skip: press "G" to jump straight to the bonus round
document.addEventListener('keydown', (e) => {
  if (e.key === 'g' || e.key === 'G') {
    // clean up any running grid timer and hide HUD timer
    try { if (gridTimer) { clearInterval(gridTimer); gridTimer = null; } } catch(_) {}
    hudTimer.style.display = 'none';

    // go straight to the bonus and start reels
    showScreen('bonus');
    resetReels();
    startReels();
  }
});


  // Initialize HUD and reels
  updateHUD();
  resetReels();
})();
</script>
</body>
</html>


