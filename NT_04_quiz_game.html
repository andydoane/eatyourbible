<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ğŸ”´ Emoji Drop â¬‡ï¸</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <style>
    :root {
      --bg: #0f172a;
      --panel: rgba(15, 23, 42, 0.95);
      --accent: #f97316;
      --correct: #22c55e;
      --incorrect: #ef4444;
      --text: #e2e8f0;
      --well1: #0ea5e9;
      --well2: #fbbf24;
      --well3: #f43f5e;
      --ui-z: 100;
      --game-z: 50;
      --app-h: 100vh;
    }
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    body {
      margin: 0;
      background: var(--bg);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: var(--text);
      height: var(--app-h);
      overflow: hidden;
    }
    #app {
      position: relative;
      width: 100vw;
      height: var(--app-h);
      max-width: 650px; /* PC just scales up, centered */
      margin: 0 auto;
      background: radial-gradient(circle at top, #1f2937 0%, #020617 50%, #000 100%);
    }
    .screen {
      position: absolute;
      inset: 0;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 1.2rem;
      gap: 1rem;
    }
    .screen.active {
      display: flex;
    }
    .card {
      background: var(--panel);
      border: 2px solid rgba(248, 250, 252, 0.05);
      border-radius: 1.25rem;
      padding: 1.25rem 1.5rem;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
      text-align: center;
      width: min(92vw, 500px);
    }
    h1, h2, h3 {
      margin: 0.2rem 0;
    }
    button {
      background: var(--accent);
      border: none;
      color: white;
      padding: 0.8rem 1.2rem;
      border-radius: 0.85rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.1s;
      width: 100%;
      max-width: 420px;
    }
    button:active {
      transform: scale(0.97);
    }
    .question-options {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      width: 100%;
    }
    .answer-btn {
      background: rgba(15, 118, 110, 0.2);
      border: 1px solid rgba(148, 163, 184, 0.3);
      display: flex;
      align-items: center;
      gap: 0.6rem;
      justify-content: flex-start;
    }
    .answer-emoji {
      font-size: 1.4rem;
    }

    /* Game screen */
    #gameScreen {
      background: transparent;
      align-items: stretch;
      justify-content: flex-start;
      padding: 0;
      height: var(--app-h);
    }
    #gameHUD {
      position: absolute;
      top: 0.35rem;
      left: 0.35rem;
      right: 0.35rem;
      display: flex;
      justify-content: space-between;
      gap: 0.35rem;
      z-index: var(--ui-z);
      font-size: 0.7rem;
    }
    .hud-box {
      background: rgba(15, 23, 42, 0.4);
      border: 1px solid rgba(248, 250, 252, 0.05);
      border-radius: 0.75rem;
      padding: 0.4rem 0.55rem;
      min-width: 4.5rem;
      text-align: center;
    }
    #gameField {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
    }

    #clearBonus {
    position: absolute;
    inset: 0;
    z-index: 1200;
    display: none;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    }
    #clearBonus.active {
    display: flex;
    }
    .clear-bonus-bg {
    position: absolute;
    inset: 0;
    background: linear-gradient(120deg, #f43f5e, #f97316, #fbbf24, #22c55e, #3b82f6, #8b5cf6);
    background-size: 400% 400%;
    animation: bonus-rainbow 2s linear infinite;
    opacity: 0.5;
    }
    @keyframes bonus-rainbow {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
    }
    .clear-bonus-text {
    position: relative;
    font-size: clamp(3rem, 8vw, 5.5rem);
    font-weight: 900;
    color: #fff;
    text-shadow: 0 0 28px rgba(0,0,0,0.7);
    transform: scale(1);
    animation: bonus-pop 0.6s ease-out;
    }
    @keyframes bonus-pop {
    0% { transform: scale(0.2); opacity: 0; }
    50% { transform: scale(1.05); opacity: 1; }
    100% { transform: scale(1); }
    }


    .peg {
    position: absolute;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    transition: transform 0.25s, opacity 0.25s;
    }


    .peg.hit {
      transform: scale(0.1) rotate(35deg);
      opacity: 0;
    }

    .debug-peg-hitbox {
    outline: 2px dashed rgba(255, 0, 0, 0.6);
    border-radius: 999px;
    }

    .debug-ball-hitbox {
    outline: 2px solid rgba(0, 255, 0, 0.7);
    border-radius: 999px;
    }



    .ball {
    position: absolute;
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;       /* no white marble */
    border-radius: 999px;
    z-index: calc(var(--game-z) + 5);
    }

    
    #arrow {
      position: absolute;
      top: 3.2rem;
      width: 1.25rem;
      height: 1.25rem;
      z-index: calc(var(--game-z) + 6);
      font-size: 1.4rem;
      text-shadow: 0 2px 5px rgba(0,0,0,.5);
    }

    #bottomWells {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 2.6rem;           /* shorter bar */
    min-height: 0;            /* we control it now */
    display: flex;
    z-index: calc(var(--game-z) + 2);
    }

    @supports (padding: max(0px)) {
  #bottomWells {
    padding-bottom: env(safe-area-inset-bottom);
  }
}



    .well {
    border-top: 3px solid rgba(248, 250, 252, 0.4);
    display: flex;
    align-items: center;              /* center vertically */
    justify-content: center;
    color: #0f172a;
    font-size: 0.75rem;
    font-weight: 700;
    position: relative;
    overflow: hidden;
    line-height: 1;                   /* tighter text */
    }


/* special / bomb pegs glow */
.peg-special,
.peg-bomb {
}
.peg-special::before,
.peg-bomb::before {
  content: "";
  position: absolute;
  inset: -6px;
  border-radius: 999px;
  background: radial-gradient(circle, rgba(255,255,255,0.35) 0%, rgba(255,255,255,0) 70%);
  animation: pegPulse 1.1s ease-in-out infinite;
  z-index: -1;
}
@keyframes pegPulse {
  0% { transform: scale(0.85); opacity: 0.6; }
  50% { transform: scale(1.15); opacity: 1; }
  100% { transform: scale(0.85); opacity: 0.6; }
}

/* moving platform */
.moving-platform {
  position: absolute;
  background: rgba(248, 250, 252, 0.9);
  border: 1px solid rgba(15, 23, 42, 0.35);
  border-radius: 0.5rem;
  z-index: calc(var(--game-z) + 4);
  pointer-events: none;
}

/* side bumpers */
.side-bumper {
  position: absolute;
  background: linear-gradient(90deg, #f43f5e, #f97316, #fbbf24, #22c55e, #3b82f6, #8b5cf6);
  background-size: 300% 300%;
  animation: bumperPulse 1.6s linear infinite;
  border-radius: 999px;
  filter: drop-shadow(0 4px 10px rgba(0,0,0,0.45));
  z-index: calc(var(--game-z) + 3);
  pointer-events: none;
}
@keyframes bumperPulse {
  0%   { background-position: 0% 50%; opacity: 1; }
  50%  { background-position: 100% 50%; opacity: 0.9; }
  100% { background-position: 0% 50%; opacity: 1; }
}


/* big confetti */
.confetti-piece {
  position: absolute;
  width: 10px;
  height: 14px;
  opacity: 0;
  animation: confettiPop 0.7s ease-out forwards;
}
@keyframes confettiPop {
  0% { transform: translate(0,0) rotate(0deg); opacity: 1; }
  100% { transform: translate(var(--tx), var(--ty)) rotate(var(--rot)); opacity: 0; }
}


    .well-score-burst {
      position: absolute;
      bottom: 0.35rem;
      font-weight: 700;
      color: #fff;
      text-shadow: 0 3px 10px rgba(0,0,0,0.6);
      animation: popUp 0.7s ease-out forwards;
      left: 50%;
      transform: translateX(-50%);
    }
    @keyframes popUp {
      0% {transform: translate(-50%, 40%); opacity: 0;}
      50% {opacity: 1;}
      100% {transform: translate(-50%, -120%); opacity: 0;}
    }

    /* combo popups */
    #comboPopup {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      pointer-events: none;
    }
    #comboPopup.active {
      display: flex;
    }

    .combo-box {
      background: rgba(15, 23, 42, 0.9);
      border: 2px solid rgba(248, 250, 252, 0.2);
      border-radius: 1rem;
      padding: 1rem 1.25rem;
      text-align: center;
      animation: comboPop 0.4s ease-out;
      width: 75vw;              /* ğŸ‘ˆ 75% of screen */
      max-width: 500px;         /* ğŸ‘ˆ donâ€™t get too huge on desktop */
      box-sizing: border-box;
    }

        .combo-title {
        /* big on phones, capped on desktop */
        font-size: min(9vw, 3.3rem);
        font-weight: 800;
        margin-bottom: 0.35rem;
        line-height: 1;
        }
        .combo-points {
        /* even bigger number */
        font-size: min(12vw, 4.6rem);
        font-weight: 900;
        letter-spacing: 0.04em;
        line-height: 0.95;
        }

    @keyframes comboPop {
      0% { transform: scale(.3); opacity: 0; }
      60% { transform: scale(1.05); opacity: 1; }
      100% { transform: scale(1); }
    }


    .popup {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999;
      background: rgba(0, 0, 0, 0.5);
      padding: 1rem;
    }
    .popup.active {
      display: flex;
    }
    .popup-content {
      background: #1f2937;
      border: 2px solid rgba(226, 232, 240, 0.1);
      border-radius: 1.2rem;
      padding: 1.1rem 1.2rem 1rem;
      text-align: center;
      width: min(90vw, 350px);
    }

    #emojiRainContainer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: 9999;
    }
    .rain-emoji {
      position: absolute;
      top: -5rem;
      font-size: 2rem;
      animation: fall 2.2s linear forwards;
    }
    @keyframes fall {
      to { transform: translateY(110vh); opacity: 0; }
    }

    /* orientation helper (just visual hint) */
    @media (orientation: landscape) {
      .landscape-hint {
        display: block;
      }
    }
    .landscape-hint {
      display: none;
      position: absolute;
      top: .5rem;
      right: .5rem;
      background: rgba(248,113,113,.18);
      border: 1px solid rgba(248, 113, 113, .6);
      padding: .25rem .5rem;
      border-radius: .5rem;
      font-size: .65rem;
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Splash -->
    <div id="splashScreen" class="screen active">
      <div class="card">
        <h1>ğŸ“± Vertical Mode</h1>
        <p>This game is best in vertical (portrait) mode.</p>
        <button id="splashOkayBtn">Okay!</button>
      </div>
    </div>

    <!-- Title -->
    <div id="titleScreen" class="screen">
      <div class="card">
        <h1>ğŸ”´ Emoji Drop â¬‡ï¸</h1>
        <p>Answer Bible questions âœ drop balls âœ smash emoji âœ score big.</p>
        <button id="startBtn">Go fullscreen and start</button>
      </div>
    </div>

    <!-- Question -->
    <div id="questionScreen" class="screen">
      <div class="card" id="questionCard">
        <h2 id="questionText">Question goes here</h2>
        <div id="questionNumber" style="margin-bottom:.5rem;font-size:.75rem;opacity:.7;">Question 1 of 10</div>
        <div class="question-options" id="answerOptions"></div>
      </div>
    </div>

    <!-- Game -->
    <div id="gameScreen" class="screen">
      <div id="gameHUD">
        <div class="hud-box" id="hudRound">Round 1 / 10</div>
        <div class="hud-box" id="hudBalls">Balls: 5</div>
        <div class="hud-box" id="hudScore">Score: 0</div>
      </div>
      <div id="gameField"></div>

        <div id="bottomWells">
        <div class="well" data-score="1000" style="flex: 1; background: rgba(14,165,233,0.85);">1K</div>
        <div class="well" data-score="5000" style="flex: 1; background: rgba(251,191,36,0.85);">5K</div>
        <div class="well" data-score="10000" data-extraball="1" style="flex: .5; background: rgba(244,63,94,0.85);">10K</div>
        <div class="well" data-score="5000" style="flex: 1; background: rgba(251,191,36,0.85);">5K</div>
        <div class="well" data-score="1000" style="flex: 1; background: rgba(14,165,233,0.85);">1K</div>
        </div>

      

      <div class="landscape-hint">portrait game</div>
    </div>

    <!-- End Screen -->
    <div id="endScreen" class="screen">
      <div class="card">
        <h1>Game Over</h1>
        <p id="finalScoreText">You scored 0 points.</p>
        <p id="finalQA">Correct: 0 Â· Incorrect: 0</p>
        <button onclick="location.reload()">Play again</button>
      </div>
    </div>

    <!-- Popup -->
    <div id="popup" class="popup">
      <div class="popup-content">
        <h3 id="popupTitle">Popup</h3>
        <p id="popupMessage">Popup text</p>
        <button id="popupBtn">OK</button>
      </div>
    </div>

    <!-- Emoji rain -->
    <div id="emojiRainContainer"></div>

    <!-- Clear-all bonus overlay -->
    <div id="clearBonus">
      <div class="clear-bonus-bg"></div>
      <div class="clear-bonus-text">100,000!</div>
    </div>

    <!-- Combo popup (moved OUT of clearBonus) -->
    <div id="comboPopup">
      <div class="combo-box">
        <div class="combo-title" id="comboTitle">COMBO BONUS</div>
        <div class="combo-points" id="comboPoints">10,000</div>
      </div>
    </div>


        

  </div>

  <script>
    /**********************
     * TWEAKABLE SETTINGS *
     **********************/
    const SETTINGS = {
      arrowSpeed: 1.6,           // how fast the arrow sweeps left-right
      gravity: 1200,             // px / s^2
      bounceStrength: 420,       // how hard balls bounce off pegs
      pegRadius: 20,             // match .peg size
      ballRadius: 15,
      rows: 8,                   // number of emoji rows
      rowSpacing: 70,            // vertical spacing
      topOffset: 110,            // where pegs start
      ballCountPerRound: 5,
      scorePerHit: 300,          // per emoji hit
      emojiHitFX: ["âœ¨","ğŸ’¥","ğŸ‰","âš¡","ğŸŒˆ"],
        emojiRainCount: 30,
        launchSpeed: 520,
        launchStartY: 50,
        specialEmoji: "ğŸ’",
        bombEmoji: "ğŸ’£",
        bombRadius: 120,
        platformSpeed: 90
};

const BALL_EMOJI = ["ğŸ”´","ğŸ¥","ğŸ±","ğŸ©","ğŸ€","ğŸ§¿","ğŸ","ğŸŒ","ğŸª","âš½"];
let currentBallEmoji = "ğŸ”´";

function isIOS() {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) || 
    (navigator.userAgent.includes("Mac") && "ontouchend" in document);
}

function updateAppHeightForIOS() {
  if (!isIOS()) return;
  const h = window.innerHeight;
  document.documentElement.style.setProperty("--app-h", h + "px");
}

window.addEventListener("resize", updateAppHeightForIOS);
window.addEventListener("orientationchange", updateAppHeightForIOS);
document.addEventListener("DOMContentLoaded", updateAppHeightForIOS);



  /*

 #####     #     #    #######     #####     #######    ###    #######    #     #     #####  
#     #    #     #    #          #     #       #        #     #     #    ##    #    #     # 
#     #    #     #    #          #             #        #     #     #    # #   #    #       
#     #    #     #    #####       #####        #        #     #     #    #  #  #     #####  
#   # #    #     #    #                #       #        #     #     #    #   # #          # 
#    #     #     #    #          #     #       #        #     #     #    #    ##    #     # 
 #### #     #####     #######     #####        #       ###    #######    #     #     #####  

*/

const QUESTIONS = [
  {
    text: "Where did the wise men come from?",
    answers: [
      { label: "From the east", emoji: "ğŸŒ…", correct: true },
      { label: "From Egypt", emoji: "ğŸœï¸", correct: false },
      { label: "From Rome", emoji: "ğŸ›ï¸", correct: false },
      { label: "From Nazareth", emoji: "ğŸ˜ï¸", correct: false }
    ]
  },
  {
    text: "Why did the wise men follow the star to Jerusalem?",
    answers: [
      { label: "A king of the Jews was born", emoji: "â­", correct: true },
      { label: "They wanted treasure", emoji: "ğŸ’°", correct: false },
      { label: "They were chasing soldiers", emoji: "ğŸ—¡ï¸", correct: false },
      { label: "They were lost", emoji: "ğŸ§­", correct: false }
    ]
  },
  {
    text: "Who was Herod?",
    answers: [
      { label: "The king over the Jewish people", emoji: "ğŸ‘‘", correct: true },
      { label: "A traveling wise man", emoji: "ğŸ§³", correct: false },
      { label: "A Roman soldier", emoji: "ğŸ—¡ï¸", correct: false },
      { label: "A prophet", emoji: "ğŸ“œ", correct: false }
    ]
  },
  {
    text: "Where did Scripture say the Messiah would be born?",
    answers: [
      { label: "In Bethlehem", emoji: "ğŸ ", correct: true },
      { label: "In Nazareth", emoji: "ğŸ˜ï¸", correct: false },
      { label: "In Jerusalem", emoji: "ğŸ›ï¸", correct: false },
      { label: "In Egypt", emoji: "ğŸœï¸", correct: false }
    ]
  },
  {
    text: "What did Herod tell the wise men to do?",
    answers: [
      { label: "Find the child and tell me", emoji: "ğŸ“œ", correct: true },
      { label: "Go home right away", emoji: "ğŸ¡", correct: false },
      { label: "Destroy the star", emoji: "ğŸ’¥", correct: false },
      { label: "Bring the child to the palace", emoji: "ğŸ°", correct: false }
    ]
  },
  {
    text: "How did the wise men find Jesusâ€™ house?",
    answers: [
      { label: "The star stopped over it", emoji: "ğŸŒŸ", correct: true },
      { label: "People showed them", emoji: "ğŸ—£ï¸", correct: false },
      { label: "They followed camels", emoji: "ğŸª", correct: false },
      { label: "They guessed", emoji: "ğŸ¤”", correct: false }
    ]
  },
  {
    text: "What did the wise men do when they found Jesus?",
    answers: [
      { label: "Worshiped and gave gifts", emoji: "ğŸ", correct: true },
      { label: "Built a house for him", emoji: "ğŸ§±", correct: false },
      { label: "Crowned him king", emoji: "ğŸ‘‘", correct: false },
      { label: "Took him to Herod", emoji: "ğŸ°", correct: false }
    ]
  },
  {
    text: "What warning did God give the wise men?",
    answers: [
      { label: "Donâ€™t go back to Herod", emoji: "âš ï¸", correct: true },
      { label: "Donâ€™t take your gifts", emoji: "ğŸ", correct: false },
      { label: "Donâ€™t follow the star", emoji: "ğŸŒŸ", correct: false },
      { label: "Donâ€™t leave Bethlehem", emoji: "ğŸš«", correct: false }
    ]
  },
  {
    text: "What did the angel tell Joseph to do?",
    answers: [
      { label: "Escape to Egypt", emoji: "ğŸœï¸", correct: true },
      { label: "Stay in Bethlehem", emoji: "ğŸ ", correct: false },
      { label: "Go to Herod", emoji: "ğŸ°", correct: false },
      { label: "Sail to Rome", emoji: "â›µ", correct: false }
    ]
  },
  {
    text: "After Herod died, what did Josephâ€™s family do?",
    answers: [
      { label: "Returned to Nazareth", emoji: "ğŸ¡", correct: true },
      { label: "Stayed in Egypt", emoji: "ğŸœï¸", correct: false },
      { label: "Moved to Jerusalem", emoji: "ğŸ›ï¸", correct: false },
      { label: "Went back to Bethlehem", emoji: "ğŸŒŸ", correct: false }
    ]
  }
];



/*

#######    #     #    ######     
#          ##    #    #     #    
#          # #   #    #     #    
#####      #  #  #    #     #    
#          #   # #    #     #    
#          #    ##    #     #    
#######    #     #    ######     


*/


        const ROUND_EMOJI_SETS = [
        ["ğŸ","ğŸŠ","ğŸ‡","ğŸ‰","ğŸ“","ğŸ¥","ğŸ’","ğŸ"],
        ["ğŸ¶","ğŸ±","ğŸ­","ğŸ¦Š","ğŸ»","ğŸ¼","ğŸ¨","ğŸ¸"],
        ["ğŸš—","ğŸš•","ğŸšŒ","ğŸš“","ğŸš‘","ğŸš’","ğŸšœ","ğŸï¸"],
        ["âš½","ğŸ€","ğŸˆ","ğŸ¾","ğŸ","ğŸ¥","ğŸ‰","ğŸ¥"],
        ["ğŸŒˆ","â­","â˜ï¸","ğŸŒ™","âš¡","â˜€ï¸","ğŸŒ¤ï¸","ğŸŒ§ï¸"],
        ["ğŸˆ","ğŸ‰","ğŸŠ","ğŸ","ğŸª…","ğŸ¯","ğŸ®","ğŸµ"],
        ["ğŸ”","ğŸŸ","ğŸ•","ğŸŒ­","ğŸ—","ğŸ¥","ğŸ¥¨","ğŸª"],
        ["ğŸŒ¸","ğŸŒ¼","ğŸŒ»","ğŸŒ·","ğŸŒ¹","ğŸ€","ğŸŒµ","ğŸ"],
        ["ğŸ˜€","ğŸ˜","ğŸ˜‚","ğŸ¥³","ğŸ˜","ğŸ¤©","ğŸ˜œ","ğŸ˜‡"], 
        ["ğŸ§±","ğŸª™","ğŸ””","ğŸ","ğŸ’","ğŸ§Š","ğŸ§ƒ","ğŸ§ "]
        ];

    /**********************
     * STATE
     **********************/
    let currentQuestionIndex = 0;
    let totalScore = 0;
    let correctCount = 0;
    let incorrectCount = 0;

    let lastTimestamp = 0; 

    let ballsLeft = SETTINGS.ballCountPerRound;
    let hasShownDropPopup = false;   // show "Drop time!" only once
    let clearedAllThisRound = false; // we'll use this in step 2
    let bonusBallNextRound = 0;      // +1 if last question was correct
    let clearBonusShown = false;     // prevents double celebration
    let bumpers = []; // left/right little paddles
    // combo for the CURRENT shot (main ball + any bonus balls it spawns)
    let currentComboHits = 0;
    let currentComboMult = 1;




    let activeBalls = []; 
    let pegs = [];
    let gameWidth = 0;
    let gameHeight = 0;
    let gameFieldEl = null;
    let wells = [];
    let gameRunning = false;
    let awaitingDrop = false;
    let debugHitboxes = false;
    let currentPegSize = 32; // will be updated each round
    let roundEnding = false; // <-- prevents multiple finishRound calls




    /**********************
     * ELEMENTS
     **********************/
    const splashScreen = document.getElementById("splashScreen");
    const titleScreen = document.getElementById("titleScreen");
    const questionScreen = document.getElementById("questionScreen");
    const gameScreen = document.getElementById("gameScreen");
    const endScreen = document.getElementById("endScreen");
    const questionTextEl = document.getElementById("questionText");
    const questionNumberEl = document.getElementById("questionNumber");
    const answerOptionsEl = document.getElementById("answerOptions");
    const popup = document.getElementById("popup");
    const popupTitle = document.getElementById("popupTitle");
    const popupMessage = document.getElementById("popupMessage");
    const popupBtn = document.getElementById("popupBtn");
    const hudRound = document.getElementById("hudRound");
    const hudBalls = document.getElementById("hudBalls");
    const hudScore = document.getElementById("hudScore");
    const emojiRainContainer = document.getElementById("emojiRainContainer");

    /**********************
     * SCREEN CONTROLS
     **********************/
    function showScreen(screenEl) {
      [splashScreen, titleScreen, questionScreen, gameScreen, endScreen].forEach(s => s.classList.remove("active"));
      screenEl.classList.add("active");
    }

    document.getElementById("splashOkayBtn").addEventListener("click", () => {
      showScreen(titleScreen);
    });

    document.getElementById("startBtn").addEventListener("click", async () => {
      // try fullscreen (may fail quietly)
      const el = document.documentElement;
      if (el.requestFullscreen) {
        try { await el.requestFullscreen(); } catch (e) {}
      }
      startQuestions();
    });

    popupBtn.addEventListener("click", () => {
      popup.classList.remove("active");
      if (popup.dataset.next === "startGame") {
        beginGameRound();
      }
    });

    function showPopup(title, msg, next = "") {
      popupTitle.textContent = title;
      popupMessage.textContent = msg;
      popup.dataset.next = next;
      popup.classList.add("active");
    }

    /**********************
     * QUESTIONS
     **********************/
    function startQuestions() {
      currentQuestionIndex = 0;
      showNextQuestion();
    }

    function showNextQuestion() {
      if (currentQuestionIndex >= QUESTIONS.length) {
        endGame();
        return;
      }
      const q = QUESTIONS[currentQuestionIndex];
      questionTextEl.textContent = q.text;
      questionNumberEl.textContent = `Question ${currentQuestionIndex + 1} of ${QUESTIONS.length}`;
      answerOptionsEl.innerHTML = "";
      // create a shuffled copy
      const shuffled = q.answers.slice().sort(() => Math.random() - 0.5);
      shuffled.forEach(ans => {
        const btn = document.createElement("button");
        btn.className = "answer-btn";
        btn.innerHTML = `<span class="answer-emoji">${ans.emoji}</span> ${ans.label}`;
        btn.addEventListener("click", () => handleAnswer(ans.correct, q.answers.find(a => a.correct).label));
        answerOptionsEl.appendChild(btn);
      });
      showScreen(questionScreen);
    }

    function handleAnswer(isCorrect, rightAnswerLabel) {
        if (isCorrect) {
        correctCount++;
        totalScore += 500; // bonus for correct question
        bonusBallNextRound = 1;        // <-- give 1 extra ball for the NEXT round
        showPopup("ğŸŸ¡ğŸŸ¢Bonus Ball! ğŸ”´ğŸ”µ", "Correct answer â€“ you've earned a bonus ball!", "startGame");
        } else {
        bonusBallNextRound = 0;        // <-- no extra ball next round
        incorrectCount++;
        showPopup("Not quite âŒ", "The right answer was: " + rightAnswerLabel, "startGame");
        }

    }

    /**********************
     * GAME ROUND
     **********************/
    function beginGameRound() {
    showScreen(gameScreen);
    setupGameForRound(currentQuestionIndex);
    currentBallEmoji = BALL_EMOJI[currentQuestionIndex % BALL_EMOJI.length];

    ballsLeft = SETTINGS.ballCountPerRound + bonusBallNextRound;
    bonusBallNextRound = 0; // we used it, so clear it
    activeBalls = [];
    updateHUD();

    gameRunning = true;
    awaitingDrop = true;
    roundEnding = false;
    clearedAllThisRound = false;
    clearBonusShown = false;

    

    if (!hasShownDropPopup) {
    showPopup("Drop time!", "Tap or click anywhere to aim your shot. Break as many emoji as you can.", "");
    hasShownDropPopup = true;
    }

    
    }


     


    function setupGameForRound(roundIndex) {
      gameFieldEl = document.getElementById("gameField");
      gameWidth = gameFieldEl.clientWidth;
      gameHeight = gameFieldEl.clientHeight;
      gameFieldEl.innerHTML = ""; // clear any old pegs / balls
      pegs = [];

        const pegSize = gameWidth / 13;
        currentPegSize = pegSize;
        SETTINGS.pegRadius = pegSize / 2;
        SETTINGS.ballRadius = pegSize / 2;



      // make pegs
      const emojiSet = ROUND_EMOJI_SETS[roundIndex % ROUND_EMOJI_SETS.length];
      for (let r = 0; r < SETTINGS.rows; r++) {
        const isEven = r % 2 === 0;
        const cols = isEven ? 6 : 5;
        const y = SETTINGS.topOffset + r * SETTINGS.rowSpacing;
        for (let c = 0; c < cols; c++) {
          const xGap = gameWidth / (cols + 1);
          const x = xGap * (c + 1);
          const pegEl = document.createElement("div");
          pegEl.className = "peg";
          pegEl.style.width = pegSize + "px";
          pegEl.style.height = pegSize + "px";
          pegEl.style.fontSize = (pegSize * 0.8) + "px";
          pegEl.style.left = (x - pegSize / 2) + "px";
          pegEl.style.top = (y - pegSize / 2) + "px";
          pegEl.textContent = emojiSet[(r * 7 + c) % emojiSet.length];
          gameFieldEl.appendChild(pegEl);
          pegs.push({ x, y, el: pegEl, hit: false });
        }
      }

  // after we have all pegs, mark 1 special and 1 bomb
  if (pegs.length > 1) {
    const specialIndex = Math.floor(Math.random() * pegs.length);
    let bombIndex = Math.floor(Math.random() * pegs.length);
    while (bombIndex === specialIndex) {
      bombIndex = Math.floor(Math.random() * pegs.length);
    }

    // special
    const sp = pegs[specialIndex];
    sp.type = "special";
    sp.el.textContent = SETTINGS.specialEmoji;
    sp.el.classList.add("peg-special");

    // bomb
    const bp = pegs[bombIndex];
    bp.type = "bomb";
    bp.el.textContent = SETTINGS.bombEmoji;
    bp.el.classList.add("peg-bomb");
  }

  // get wells
  wells = Array.from(document.querySelectorAll("#bottomWells .well"));

  // build moving platform above wells
  const wellsBar = document.getElementById("bottomWells");
  const wellsBarRect = wellsBar.getBoundingClientRect();
  const wellsBarHeight = wellsBarRect.height;
  const totalFlex = wells.reduce((acc, w) => acc + parseFloat(w.style.flex), 0);
  const wideWellWidth = gameWidth * (1 / totalFlex); // width of a flex:1 well
  const platformHeight = wellsBarHeight / 2;

  const platformEl = document.createElement("div");
  platformEl.className = "moving-platform";
  platformEl.style.width = wideWellWidth + "px";
  platformEl.style.height = platformHeight + "px";
  platformEl.style.left = (gameWidth / 2 - wideWellWidth / 2) + "px";
  platformEl.style.bottom = (wellsBarHeight + wellsBarHeight / 2 - platformHeight / 2) + "px";
  gameFieldEl.appendChild(platformEl);

  movingPlatform = {
    x: gameWidth / 2 - wideWellWidth / 2,
    y: gameHeight - wellsBarHeight - (wellsBarHeight / 2),
    width: wideWellWidth,
    height: platformHeight,
    el: platformEl,
    dir: 1
  };

    // build side bumpers (aligned with row 3 and row 6)
    bumpers = [];
    const bumperRows = [2, 5]; // 0-based: 3rd and 6th row
    const bumperLen = currentPegSize*1.3;        // ğŸ‘ˆ Bumper length
    const bumperThick = currentPegSize * 0.45;


  bumperRows.forEach((rowIdx) => {
    const rowY = SETTINGS.topOffset + rowIdx * SETTINGS.rowSpacing;

    // LEFT bumper
    const leftEl = document.createElement("div");
    leftEl.className = "side-bumper";
    leftEl.style.width = bumperLen + "px";
    leftEl.style.height = bumperThick + "px";
    leftEl.style.left = (-currentPegSize * 0.4) + "px";
    leftEl.style.top = (rowY - bumperThick / 2) + "px";
    leftEl.style.transform = "rotate(12deg)";
    gameFieldEl.appendChild(leftEl);

    bumpers.push({
      x: -currentPegSize * 0.4,
      y: rowY - bumperThick / 2,
      width: bumperLen,
      height: bumperThick,
      side: "left",
      el: leftEl
    });

    // geometry for left bumper (angled +12deg)
    (() => {
    const b = bumpers[bumpers.length - 1];
    const angleDeg = 12;
    const ang = angleDeg * Math.PI / 180;
    const cx = b.x + b.width / 2;
    const cy = b.y + b.height / 2;
    const dirX = Math.cos(ang), dirY = Math.sin(ang);
    b.p1 = { x: cx - dirX * (b.width / 2), y: cy - dirY * (b.width / 2) };
    b.p2 = { x: cx + dirX * (b.width / 2), y: cy + dirY * (b.width / 2) };
    b.radius = b.height / 2; // capsule radius = half thickness
    })();


    // RIGHT bumper
    const rightX = gameWidth - bumperLen + (currentPegSize * 0.4);
    const rightEl = document.createElement("div");
    rightEl.className = "side-bumper";
    rightEl.style.width = bumperLen + "px";
    rightEl.style.height = bumperThick + "px";
    rightEl.style.left = rightX + "px";
    rightEl.style.top = (rowY - bumperThick / 2) + "px";
    rightEl.style.transform = "rotate(-12deg)";
    gameFieldEl.appendChild(rightEl);

    bumpers.push({
      x: rightX,
      y: rowY - bumperThick / 2,
      width: bumperLen,
      height: bumperThick,
      side: "right",
      el: rightEl
    });

    // geometry for right bumper (angled -12deg)
    (() => {
    const b = bumpers[bumpers.length - 1];
    const angleDeg = -12;
    const ang = angleDeg * Math.PI / 180;
    const cx = b.x + b.width / 2;
    const cy = b.y + b.height / 2;
    const dirX = Math.cos(ang), dirY = Math.sin(ang);
    b.p1 = { x: cx - dirX * (b.width / 2), y: cy - dirY * (b.width / 2) };
    b.p2 = { x: cx + dirX * (b.width / 2), y: cy + dirY * (b.width / 2) };
    b.radius = b.height / 2;
    })();


  });
}






    function updateHUD() {
      hudRound.textContent = `Round ${currentQuestionIndex + 1} / ${QUESTIONS.length}`;
      hudBalls.textContent = `Balls: ${ballsLeft}`;
      hudScore.textContent = `Score: ${totalScore}`;
    }

    // drop ball when player taps
    gameScreen.addEventListener("pointerdown", (e) => {
      if (!gameRunning) return;
      if (!awaitingDrop) return;
      if (ballsLeft <= 0) return;

      const rect = gameFieldEl.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;

      spawnBallToward(clickX, clickY);
    });


    function spawnBallToward(targetX, targetY) {
      const startX = gameWidth / 2;
      const startY = SETTINGS.launchStartY;

      // if this is a brand-new shot (no balls flying), start a fresh combo
      if (activeBalls.length === 0) {
        currentComboHits = 0;
        currentComboMult = 1;
      }

    const ballEl = document.createElement("div");
    ballEl.className = "ball";
    gameFieldEl.appendChild(ballEl);
    ballEl.textContent = currentBallEmoji;
    ballEl.style.width = currentPegSize + "px";
    ballEl.style.height = currentPegSize + "px";
    ballEl.style.fontSize = (currentPegSize * 0.8) + "px";

    

    const dx = targetX - startX;
    const dy = targetY - startY;
    const len = Math.sqrt(dx * dx + dy * dy) || 1;
    const speed = SETTINGS.launchSpeed;

    const vx = (dx / len) * speed;
    const vy = (dy / len) * speed;

    const ball = {
        x: startX,
        y: startY,
        vx: vx,
        vy: vy,
        el: ballEl
    };

    activeBalls.push(ball);

    ballsLeft -= 1;
    awaitingDrop = false;
    updateHUD();
    if (debugHitboxes) updateDebugVisuals();
    }


function spawnBonusBallAtTop() {
  if (!gameFieldEl) return;
  const randX = Math.random() * (gameWidth - SETTINGS.ballRadius * 2) + SETTINGS.ballRadius;

    const ballEl = document.createElement("div");
    ballEl.className = "ball";
    gameFieldEl.appendChild(ballEl);
    ballEl.textContent = currentBallEmoji;
    ballEl.style.width = currentPegSize + "px";
    ballEl.style.height = currentPegSize + "px";
    ballEl.style.fontSize = (currentPegSize * 0.8) + "px";


  


  const ball = {
    x: randX,
    y: SETTINGS.launchStartY,
    vx: (Math.random() - 0.5) * 90,
    vy: 140,
    el: ballEl
  };

  activeBalls.push(ball);
  if (debugHitboxes) updateDebugVisuals();
}


    /**********************
     * MAIN LOOP
     **********************/
    function loop(timestamp) {
      if (!lastTimestamp) lastTimestamp = timestamp;
      const dt = Math.min((timestamp - lastTimestamp) / 1000, 0.035);
      lastTimestamp = timestamp;

    if (gameRunning) {
    // move platform
    if (movingPlatform) {
        movingPlatform.x += movingPlatform.dir * SETTINGS.platformSpeed * dt;
        if (movingPlatform.x < 0) {
        movingPlatform.x = 0;
        movingPlatform.dir = 1;
        } else if (movingPlatform.x + movingPlatform.width > gameWidth) {
        movingPlatform.x = gameWidth - movingPlatform.width;
        movingPlatform.dir = -1;
        }
        movingPlatform.el.style.left = movingPlatform.x + "px";
    }

    // update all balls
    for (let i = activeBalls.length - 1; i >= 0; i--) {
        const b = activeBalls[i];
        updateBall(b, dt);
    }

    // if we have no balls flying AND no balls left to drop, end the round (once)
    if (activeBalls.length === 0 && ballsLeft <= 0 && !roundEnding) {
        roundEnding = true;
        setTimeout(() => {
        finishRound();
        }, 350);
    }
    }



      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

        function updateBall(ball, dt) {
        // remember where we were
        const prevX = ball.x;
        const prevY = ball.y;

        // physics
        ball.vy += SETTINGS.gravity * dt;

        ball.x += ball.vx * dt;
        ball.y += ball.vy * dt;


      // walls
      if (ball.x < SETTINGS.ballRadius) {
        ball.x = SETTINGS.ballRadius;
        ball.vx *= -0.7;
      } else if (ball.x > gameWidth - SETTINGS.ballRadius) {
        ball.x = gameWidth - SETTINGS.ballRadius;
        ball.vx *= -0.7;
      }

        // side bumper collisions (capsule vs circle, matches visual angle)
        for (let i = 0; i < bumpers.length; i++) {
        const b = bumpers[i];
        const rBall = SETTINGS.ballRadius;
        const rCap  = b.radius; // bumper thickness/2

        // segment A->B (centerline)
        const ax = b.p1.x, ay = b.p1.y;
        const bx = b.p2.x, by = b.p2.y;
        const abx = bx - ax, aby = by - ay;
        const abLen2 = abx * abx + aby * aby;

        // closest point on segment to ball center
        let t = 0.5;
        if (abLen2 > 0) {
            t = ((ball.x - ax) * abx + (ball.y - ay) * aby) / abLen2;
        }
        t = clamp(t, 0, 1);
        const px = ax + abx * t;
        const py = ay + aby * t;

        // vector from closest point to ball center
        let dx = ball.x - px;
        let dy = ball.y - py;
        const dist = Math.hypot(dx, dy);
        const minDist = rBall + rCap;

        if (dist < minDist) {
            // collision normal points from bumper to ball
            let nx, ny;
            if (dist > 1e-6) {
            nx = dx / dist; ny = dy / dist;
            } else {
            // fallback normal: push toward center of field
            nx = (b.side === "left") ? 1 : -1;
            ny = 0;
            }

            // positional correction (separate by penetration along normal)
            const pen = (minDist - dist);
            ball.x += nx * pen;
            ball.y += ny * pen;

            // reflect velocity about the normal (with a friendly bounce)
            const restitution = 0.85;
            const [nvx, nvy] = reflect(ball.vx, ball.vy, nx, ny, restitution);
            ball.vx = nvx;
            ball.vy = nvy;

            // tiny extra lift so it doesn't feel dead-flat
            ball.vy -= 20;

            // gentle bias toward the center (purely for feel)
            if (b.side === "left") {
            ball.vx = Math.max(ball.vx, ball.vx + 30);
            } else {
            ball.vx = Math.min(ball.vx, ball.vx - 30);
            }
        }
        }





        // moving platform collision (swept so fast balls don't fall through)
        if (movingPlatform) {
        const topY = movingPlatform.y;
        const platLeft = movingPlatform.x;
        const platRight = movingPlatform.x + movingPlatform.width;

        const prevBottom = prevY + SETTINGS.ballRadius;
        const currBottom = ball.y + SETTINGS.ballRadius;

        // only if we're moving downward
        if (ball.vy > 0) {
            // did we cross the platform top between last frame and now?
            const crossedDownThroughTop = (prevBottom <= topY) && (currBottom >= topY);

            // are we horizontally over the platform (with a little forgiveness)?
            const overPlatform =
            ball.x >= platLeft - SETTINGS.ballRadius &&
            ball.x <= platRight + SETTINGS.ballRadius;

            if (crossedDownThroughTop && overPlatform) {
            // snap to the top and bounce
            ball.y = topY - SETTINGS.ballRadius;
            ball.vy = -SETTINGS.bounceStrength * 0.85;
            }
        }
        }









    // collisions with pegs
    for (let i = 0; i < pegs.length; i++) {
    const peg = pegs[i];
    if (peg.hit) continue;
    const dx = ball.x - peg.x;
    const dy = ball.y - peg.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < SETTINGS.ballRadius + SETTINGS.pegRadius * 0.6) {
        // bounce like before
        ball.vy = -SETTINGS.bounceStrength;
        ball.vx += dx * 2;

        peg.hit = true;
        peg.el.classList.add("hit");

            // --- COMBO LOGIC for this shot (main + bonus balls) ---
          // every peg we hit during this shot increments the shared counter
          currentComboHits += 1;

          // check thresholds
          if (currentComboHits === 10) {
            // COMBO BONUS
            showCombo("COMBO BONUS", "10,000");
            totalScore += 10000;
            currentComboMult = 2;  // from now on, pegs = 2x
            } else if (currentComboHits === 20) {
            // MEGA COMBO
            showCombo("MEGA COMBO", "50,000");
            totalScore += 50000;
            currentComboMult = 5;  // from now on, pegs = 5x
            // ğŸ‘‡ NEW: drop an extra ball for the mega
            spawnBonusBallAtTop();
            }


          // score THIS peg with current combo multiplier
          const pegPoints = SETTINGS.scorePerHit * currentComboMult;
          totalScore += pegPoints;
          updateHUD();

        

        // after hitting this peg, check if we cleared the board
        if (pegs.every(p => p.hit)) {
        clearedAllThisRound = true;

        // show the big bonus once
        if (!clearBonusShown) {
            totalScore += 100000;
            updateHUD();
            showClearBonus();
            clearBonusShown = true;
        }

        // â¬‡ï¸ force the round to be "done shooting"
        ballsLeft = 0;          // no more shots this round
        awaitingDrop = false;   // don't wait for tap
        updateHUD();

        // when this ball finishes and lands in a well, the loop condition
        // (activeBalls.length === 0 && ballsLeft <= 0) will be true
        // and the round will end automatically
        }


        


        // special behaviors
        if (peg.type === "special") {
        makeBigConfetti(peg.x, peg.y);
        spawnBonusBallAtTop();
        } else if (peg.type === "bomb") {
        makeBigConfetti(peg.x, peg.y);
        explodeBombAt(peg.x, peg.y);
        } else {
        makeSpark(peg.x, peg.y);
        }

        setTimeout(() => {
        if (peg.el && peg.el.parentNode) peg.el.parentNode.removeChild(peg.el);
        }, 300);
    }
    }

      // update DOM
      if (ball.el) {
        ball.el.style.left = (ball.x - SETTINGS.ballRadius) + "px";
        ball.el.style.top = (ball.y - SETTINGS.ballRadius) + "px";
      }

      if (debugHitboxes) updateDebugVisuals();


      // bottom / wells
      if (ball.y > gameHeight - 10) {
        landInWell(ball);
      }
    }

   function landInWell(ball) {
  if (!ball.el) return;
  ball.el.remove();

  // remove from activeBalls
  const idx = activeBalls.indexOf(ball);
  if (idx !== -1) {
    activeBalls.splice(idx, 1);
  }

  // figure out which well we landed in
  const x = ball.x;
  const totalFlex = wells.reduce((acc, w) => acc + parseFloat(w.style.flex), 0);
  const width = gameWidth;
  let cumulative = 0;
  let chosen = wells[0];
  for (let w of wells) {
    const f = parseFloat(w.style.flex);
    const segmentWidth = width * (f / totalFlex);
    if (x >= cumulative && x <= cumulative + segmentWidth) {
      chosen = w;
      break;
    }
    cumulative += segmentWidth;
  }
  const score = parseInt(chosen.dataset.score || "0", 10);
  totalScore += score;

  // score popup
  const burst = document.createElement("div");
  burst.className = "well-score-burst";
  burst.textContent = "+" + score;
  chosen.appendChild(burst);
  setTimeout(() => {
    burst.remove();
  }, 800);

  // extra ball from middle
  if (chosen.dataset.extraball === "1") {
    ballsLeft += 1;
  }

  updateHUD();

  // if we still have balls to drop AND there are no balls flying, let player drop again
  if (ballsLeft > 0 && activeBalls.length === 0) {
    awaitingDrop = true;
  }
}

    

    function finishRound() {
    // if player cleared every peg in this round, big bonus!
    if (clearedAllThisRound && !clearBonusShown) {
    totalScore += 100000;
    updateHUD();
    showClearBonus();
    clearBonusShown = true;
    }


    // move to next question
    currentQuestionIndex++;
    gameRunning = false;
    showNextQuestion();
    }



    /**********************
     * FX
     **********************/
    function makeSpark(x, y) {
      const fx = document.createElement("div");
      fx.style.position = "absolute";
      fx.style.left = (x - 14) + "px";
      fx.style.top = (y - 14) + "px";
      fx.style.zIndex = 9999;
      fx.textContent = SETTINGS.emojiHitFX[Math.floor(Math.random() * SETTINGS.emojiHitFX.length)];
      fx.style.transition = "transform .4s, opacity .4s";
      gameFieldEl.appendChild(fx);
      requestAnimationFrame(() => {
        fx.style.transform = "translateY(-18px) scale(1.5)";
        fx.style.opacity = "0";
      });
      setTimeout(() => fx.remove(), 450);
    }

    // --- geometry helpers for capsule collisions ---
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function reflect(vx, vy, nx, ny, restitution) {
      // reflect velocity about normal n, with bounce factor
      const vn = vx * nx + vy * ny;
      if (vn >= 0) return [vx, vy]; // already moving away
      const k = (1 + restitution) * vn;
      return [vx - k * nx, vy - k * ny];
    }


    function makeBigConfetti(x, y) {
      for (let i = 0; i < 18; i++) {
        const piece = document.createElement("div");
        piece.className = "confetti-piece";
        piece.style.left = (x - 6) + "px";
        piece.style.top = (y - 6) + "px";
        const dx = (Math.random() - 0.5) * 160;
        const dy = (Math.random() - 0.5) * 160;
        const rot = (Math.random() * 360) + "deg";
        piece.style.setProperty("--tx", dx + "px");
        piece.style.setProperty("--ty", dy + "px");
        piece.style.setProperty("--rot", rot);
        piece.style.background = ["#f97316","#f43f5e","#3b82f6","#22c55e","#eab308"][i % 5];
        gameFieldEl.appendChild(piece);
        setTimeout(() => piece.remove(), 750);
      }
    }

function explodeBombAt(x, y) {
  for (let i = 0; i < pegs.length; i++) {
    const p = pegs[i];
    if (p.hit) continue;

    const dx = p.x - x;
    const dy = p.y - y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist <= SETTINGS.bombRadius) {
      // mark peg hit
      p.hit = true;
      p.el.classList.add("hit");

      // bomb hits ALSO count toward this shot's combo
      currentComboHits += 1;

      // 10-hit combo from bomb
      if (currentComboHits === 10) {
        showCombo("COMBO BONUS", "10,000");
        totalScore += 10000;
        currentComboMult = 2;
      }
      // 20-hit mega combo from bomb
      else if (currentComboHits === 20) {
        showCombo("MEGA COMBO", "50,000");
        totalScore += 50000;
        currentComboMult = 5;
        // extra ball for MEGA
        spawnBonusBallAtTop();
      }

      // score this peg using CURRENT combo multiplier
      const pegPoints = SETTINGS.scorePerHit * currentComboMult;
      totalScore += pegPoints;

      makeSpark(p.x, p.y);

      // remove DOM peg after animation
      setTimeout(() => {
        if (p.el && p.el.parentNode) {
          p.el.parentNode.removeChild(p.el);
        }
      }, 300);
    }
  }

  updateHUD();

  // big boom at center
  makeBigConfetti(x, y);
}



    function showCombo(title, pointsText) {
      const popup = document.getElementById("comboPopup");
      const tEl = document.getElementById("comboTitle");
      const pEl = document.getElementById("comboPoints");
      if (!popup || !tEl || !pEl) return;

      tEl.textContent = title;
      pEl.textContent = pointsText;
      popup.classList.add("active");

      // if this is the big one, make it rain ğŸ‰
      if (title === "MEGA COMBO") {
        const rainBox = document.getElementById("emojiRainContainer");
        if (rainBox) {
          for (let i = 0; i < 20; i++) {
            const drop = document.createElement("div");
            drop.className = "rain-emoji";
            // reuse a round emoji if you have ROUND_EMOJI_SETS, else just use ğŸ’¥
            let em = "ğŸ’¥";
            if (typeof ROUND_EMOJI_SETS !== "undefined" && ROUND_EMOJI_SETS.length > 0) {
              const set = ROUND_EMOJI_SETS[Math.floor(Math.random() * ROUND_EMOJI_SETS.length)];
              em = set[0] || em;
            }
            drop.textContent = em;
            drop.style.left = Math.random() * 100 + "vw";
            drop.style.animationDelay = (Math.random() * 0.6) + "s";
            rainBox.appendChild(drop);
            setTimeout(() => drop.remove(), 2500);
          }
        }
      }

      setTimeout(() => {
        popup.classList.remove("active");
      }, 1100);
    }




    function endGame() {
      showScreen(endScreen);
      document.getElementById("finalScoreText").textContent = "You scored " + totalScore.toLocaleString() + " points.";
      document.getElementById("finalQA").textContent = "Correct: " + correctCount + " Â· Incorrect: " + incorrectCount;

      // emoji rain
      for (let i = 0; i < SETTINGS.emojiRainCount; i++) {
        const re = document.createElement("div");
        re.className = "rain-emoji";
        re.textContent = ROUND_EMOJI_SETS[Math.floor(Math.random() * ROUND_EMOJI_SETS.length)][0];
        re.style.left = Math.random() * 100 + "vw";
        re.style.animationDelay = (Math.random() * 1.2) + "s";
        emojiRainContainer.appendChild(re);
        setTimeout(() => re.remove(), 2500);
      }
    }


    function showClearBonus() {
    const overlay = document.getElementById("clearBonus");
    if (!overlay) return;

    overlay.classList.add("active");
    overlay.style.display = "flex";

    // extra emoji rain on bonus
    for (let i = 0; i < 25; i++) {
        const re = document.createElement("div");
        re.className = "rain-emoji";
        re.textContent = ROUND_EMOJI_SETS[Math.floor(Math.random() * ROUND_EMOJI_SETS.length)][0];
        re.style.left = Math.random() * 100 + "vw";
        re.style.animationDelay = (Math.random() * 0.6) + "s";
        emojiRainContainer.appendChild(re);
        setTimeout(() => re.remove(), 2500);
    }

    // hide after a bit
    setTimeout(() => {
        overlay.classList.remove("active");
        overlay.style.display = "none";
    }, 2200);
    }
    


    

    /**********************
     * RESIZE
     **********************/
    document.addEventListener("keydown", (e) => {
    if (e.key === "h" || e.key === "H") {
        debugHitboxes = !debugHitboxes;
        updateDebugVisuals();
    }
    });

    function updateDebugVisuals() {
    // pegs
    pegs.forEach(p => {
        if (!p.el) return;
        if (debugHitboxes) {
        p.el.classList.add("debug-peg-hitbox");
        } else {
        p.el.classList.remove("debug-peg-hitbox");
        }
    });

    // balls
    activeBalls.forEach(b => {
    if (debugHitboxes) {
        b.el.classList.add("debug-ball-hitbox");
    } else {
        b.el.classList.remove("debug-ball-hitbox");
    }
    });

    }




    window.addEventListener("resize", () => {
      // if we are currently in a game, rebuild pegs to match new size
      if (gameScreen.classList.contains("active")) {
        setupGameForRound(currentQuestionIndex);
      }
    });
  </script>
</body>
</html>
