<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bible Verse Memory</title>
  <style>
    :root{
      --bg:#0b1220;
      --card:#0f1b33;
      --card2:#0c162b;
      --text:#eef2ff;
      --muted:#b9c2dd;
      --line:#223255;
      --primary:#7c3aed;
      --primary2:#6d28d9;
      --good:#22c55e;
      --warn:#f59e0b;
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius: 22px;
      --tap: 44px;
      --slide-ms: 1000ms;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 700px at 20% 10%, rgba(124,58,237,.25), transparent 60%),
                  radial-gradient(900px 600px at 80% 30%, rgba(34,197,94,.16), transparent 55%),
                  var(--bg);
      color:var(--text);
      overflow-x:hidden;
    }

    .app{
      min-height:100%;
      display:flex;
      flex-direction:column;
      align-items:center;
      padding: 18px 14px 110px;
    }

    .shell{
      width:min(980px, 100%);
      margin: 0 auto;
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 8px 2px 14px;
    }
    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      user-select:none;
    }
    .logo{
      width:40px;height:40px;
      border-radius:14px;
      background: linear-gradient(145deg, rgba(124,58,237,.9), rgba(34,197,94,.65));
      box-shadow: 0 10px 22px rgba(0,0,0,.25);
      display:grid;
      place-items:center;
      font-weight:800;
      letter-spacing:.5px;
    }
    .brand .title{
      display:flex;
      flex-direction:column;
      line-height:1.05;
    }
    .brand .title b{ font-size:14px; }
    .brand .title span{ font-size:12px; color:var(--muted); }

    .top-actions{
      display:flex;
      align-items:center;
      gap:10px;
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border: 1px solid rgba(255,255,255,.07);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card-inner{
      padding: 18px 18px 16px;
    }

    .kicker{
      font-size:12px;
      letter-spacing:.18em;
      text-transform:uppercase;
      color: var(--muted);
      margin: 0 0 10px;
    }
    h1{
      margin:0 0 10px;
      font-size: clamp(24px, 4.2vw, 38px);
      letter-spacing:-.02em;
    }
    p{
      margin: 0 0 12px;
      color: var(--muted);
      font-size: clamp(15px, 1.2vw, 18px);
      line-height:1.55;
    }

    .verse-box{
      background: rgba(0,0,0,.20);
      border: 1px solid rgba(255,255,255,.07);
      border-radius: 18px;
      padding: 16px 14px;
      margin: 10px 0 6px;
    }
    .verse-ref{
      font-size: 13px;
      color: var(--muted);
      margin-bottom: 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .progress{
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
    }
    .progress-bar{
      height: 10px;
      background: rgba(255,255,255,.07);
      border-radius: 999px;
      overflow:hidden;
      margin-top: 8px;
      margin-bottom: 18px;
    }
    .progress-bar > div{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(124,58,237,.9), rgba(34,197,94,.75));
      border-radius:999px;
      transition: width .25s ease;
    }

    .verse{
    font-size: clamp(25px, 2.8vw, 50px);

    line-height: 1.55;
    color: var(--text);
    text-align: center; 
    text-wrap: balance;
    /* ‚úÖ Don't break inside words */
    overflow-wrap: normal;
    word-break: normal;
    hyphens: none;
    }

    .token-space{ white-space: normal; }


    .hintable{
    /* ‚úÖ behave like text */
    display:inline;
    padding: 0 .18em;
    margin: 0 .03em;
    border-radius: .45em;

    border: 1px solid rgba(255,255,255,.12);
    background: rgba(124,58,237,.12);
    color: var(--text);

    cursor:pointer;
    user-select:none;
    -webkit-tap-highlight-color: transparent;

    /* keep it aligned with surrounding words */
    vertical-align: baseline;
    line-height: inherit;
    white-space: nowrap; /* keep the emoji/blank together */
    }

    .hintable:hover{ background: rgba(124,58,237,.18); border-color: rgba(255,255,255,.18); }
    .hintable:active{ transform: scale(.98); }

    .hintable.emoji{
    font-size: 1.05em;
    padding: 0 .2em;
    background: rgba(34,197,94,.14);
    }

    .hintable.emoji:hover{ background: rgba(34,197,94,.19); }

    .hintable.underscore{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    background: rgba(245,158,11,.12);
    }

    .hintable.underscore:hover{ background: rgba(245,158,11,.16); }

    .controls{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 14px;
    }

    button, .btn{
      appearance:none;
      border: none;
      border-radius: 16px;
      padding: 12px 14px;
      font-weight: 700;
      color: white;
      background: linear-gradient(180deg, var(--primary), var(--primary2));
      cursor:pointer;
      min-height: var(--tap);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      -webkit-tap-highlight-color: transparent;
      box-shadow: 0 12px 22px rgba(124,58,237,.25);
      transition: transform .06s ease, filter .12s ease, opacity .12s ease;
    }
    button:hover, .btn:hover{ filter: brightness(1.06); }
    button:active, .btn:active{ transform: scale(.99); }
    button:disabled{ opacity:.5; cursor:not-allowed; }

    .btn.secondary{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      box-shadow:none;
      color: var(--text);
    }
    .btn.ghost{
      background: transparent;
      border: 1px solid rgba(255,255,255,.12);
      box-shadow:none;
    }
    .btn.small{
      padding: 9px 12px;
      border-radius: 14px;
      font-weight: 700;
      font-size: 13px;
      min-height: 38px;
    }

    .sticky-bar{
      position: fixed;
      left:0; right:0; bottom:0;
      padding: 12px 14px 14px;
      background: linear-gradient(180deg, rgba(11,18,32,0), rgba(11,18,32,.85) 20%, rgba(11,18,32,.95));
      backdrop-filter: blur(10px);
    }
    .sticky-inner{
      width: min(980px, 100%);
      margin:0 auto;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
    }
    .sticky-left{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .sticky-right{
      display:flex;
      gap:10px;
      align-items:center;
    }

    /* Modal */
    .overlay{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 16px;
      z-index: 1000;
    }
    .overlay.show{ display:flex; }
    .modal{
      width: min(560px, 100%);
      background: rgba(15,27,51,.98);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 22px;
      box-shadow: 0 20px 70px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .modal .m-inner{
      padding: 16px 16px 14px;
    }
    .modal h2{
      margin: 0 0 8px;
      font-size: 18px;
      letter-spacing:-.01em;
    }
    .modal p{
      margin: 0 0 12px;
      color: var(--muted);
    }
    .modal .m-actions{
      display:flex;
      gap:10px;
      justify-content:flex-end;
      flex-wrap:wrap;
      padding: 0 16px 16px;
    }

    /* Big centered reveal inside the modal */
    .reveal-big{
    min-height: 180px;              /* gives it a ‚Äúcentered‚Äù stage */
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    font-weight: 900;
    letter-spacing: .04em;
    text-transform: uppercase;
    font-size: clamp(26px, 6vw, 44px);
    line-height: 1.15;
    }



    /* Small helper text */
    /* Scripture copyright notice */
        .scripture-credit{
        margin-top: 10px;
        font-size: 11px;
        line-height: 1.4;
        color: var(--muted);
        text-align: center;
        opacity: 0.85;
        }


    .tip{
      margin-top: 12px;
      padding: 12px 12px;
      border-radius: 16px;
      border: 1px dashed rgba(255,255,255,.16);
      background: rgba(255,255,255,.03);
      color: var(--muted);
      font-size: 14px;
      line-height: 1.45;
    }

    @media (max-width: 375px){
    .verse{ line-height: 1.45; }
    }

    /* Desktop ‚Äúbig screen‚Äù breathing room */
    @media (min-width: 900px){
      .card-inner{ padding: 26px 26px 20px; }
      .verse-box{ padding: 18px 18px; }
    }


    /* --- Card cross-slide transition (two-layer) --- */
    .card-stage{
    position: relative;
    overflow: hidden;
    }

    /* a temporary clone of the old page, sits on top */
    .page-clone{
    position: absolute !important;
    inset: 0;
    z-index: 2;
    pointer-events: none; /* don‚Äôt allow clicks mid-animation */
    }

    /* the real screenRoot slides underneath/into place */
    .page-live{
    position: relative;
    z-index: 1;
    will-change: transform, opacity;
    }

    /* movement classes */
    .slide-from-right{ transform: translateX(110%); }
    .slide-from-left { transform: translateX(-110%); }
    .slide-to-left   { transform: translateX(-110%); }
    .slide-to-right  { transform: translateX(110%); }

    .slide-anim{
    /* duration must match SLIDE_MS in JS */
    transition: transform var(--slide-ms) cubic-bezier(.2,.8,.2,1);

    }


    /* --- Extra Practice: Scrambled Phrases --- */
    .phrase-stage{
    position: relative;
    margin-top: 14px;
    height: 360px;
    border-radius: 18px;
    border: 1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.18);
    overflow: hidden;
    }

    .phrase-chip{
    position: absolute;
    max-width: calc(100% - 28px);
    padding: 12px 14px;
    border-radius: 16px;
    border: 1px solid rgba(255,255,255,.14);
    background: rgba(124,58,237,.16);
    color: var(--text);
    font-weight: 800;
    cursor: pointer;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    box-shadow: 0 10px 18px rgba(0,0,0,.22);
    transition: transform .08s ease, filter .12s ease, opacity .12s ease;
    }

    .phrase-chip:hover{ filter: brightness(1.06); }
    .phrase-chip:active{ transform: scale(.99); }

    .phrase-chip.correct{
    background: rgba(34,197,94,.18);
    border-color: rgba(34,197,94,.35);
    }

    .phrase-chip.wrong{
    background: rgba(245,158,11,.18);
    border-color: rgba(245,158,11,.35);
    }

    .phrase-progress{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 10px;
    margin-top: 10px;
    color: var(--muted);
    font-size: 13px;
    }

/* reserved ‚Äúbuilt verse‚Äù area */
.phrase-built{
  margin-top: 12px;
  padding: 12px 12px;
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.18);
}

.phrase-built-label{
  font-size: 12px;
  letter-spacing: .14em;
  text-transform: uppercase;
  color: var(--muted);
  margin-bottom: 10px;
}

.phrase-slots{
  display:flex;
  flex-wrap:wrap;
  gap:10px;
}

.phrase-slot{
  padding: 10px 12px;
  border-radius: 16px;
  border: 1px dashed rgba(255,255,255,.16);
  background: rgba(255,255,255,.03);
  color: rgba(185,194,221,.9);
  font-weight: 800;
  min-height: 44px;
  display:flex;
  align-items:center;
}

.phrase-slot.filled{
  border-style: solid;
  background: rgba(34,197,94,.10);
  border-color: rgba(34,197,94,.22);
  color: var(--text);
}







  </style>
</head>

<body>
  <div class="app">
    <div class="shell">
      <header>
        <div class="brand">
          <div class="logo">üìò</div>
          <div class="title">
            <b>Verse Memory</b>
          </div>
        </div>
        <div class="top-actions">
          <button id="btnRestartTop" class="btn ghost small" type="button" title="Restart">Restart</button>
        </div>
      </header>

        <main class="card" role="main" aria-live="polite">
        <div class="card-stage" id="cardStage">
            <div class="card-inner" id="screenRoot">
            <!-- Rendered by JS -->
            </div>
        </div>
        </main>

    </div>
  </div>

  <!-- Sticky controls -->
  <div class="sticky-bar" id="stickyBar" style="display:none;">
    <div class="sticky-inner">
      <div class="sticky-left" id="stickyLeft"></div>
      <div class="sticky-right" id="stickyRight"></div>
    </div>
  </div>

  <!-- Modal overlay -->
  <div class="overlay" id="overlay" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="modal">
      <div class="m-inner">
        <h2 id="modalTitle">Modal</h2>
        <div id="modalBody">Body</div>

      </div>
      <div class="m-actions" id="modalActions"></div>
    </div>
  </div>

  <audio id="audio" preload="none"></audio>

<script>
/* =========================================================
   OPTION A CONFIG (edit these only)
   ========================================================= */
const SLIDE_MS = 1000; // animation duration in milliseconds
document.documentElement.style.setProperty(
  "--slide-ms",
  `${SLIDE_MS}ms`
);


const VERSE_ID   = "john_3_16";
const VERSE_REF = verseIdToRef(VERSE_ID);
const APP_TITLE = `Let's memorize ${VERSE_REF.replace(" (NIV)", "")}`;
const AUDIO_FILE = `verse_audio/${VERSE_ID}.mp3`;
document.title = `Bible Verse Memory ‚Ä¢ ${VERSE_REF}`;


const VERSE_TEXT = "For God so loved the world that he gave his one and only Son, that whoever believes in him shall not perish but have eternal life.";


const HIDE_PLAN = [
  // Emoji phase (each step adds one more)
  { type: "emoji", word: "loved",  occurrence: 1, emoji: "‚ù§Ô∏è" },
  { type: "emoji", word: "God",    occurrence: 1, emoji: "üëë" },
  { type: "emoji", word: "Son",    occurrence: 1, emoji: "üë¶" },
  { type: "emoji", word: "gave",   occurrence: 1, emoji: "üéÅ" },
  { type: "emoji", word: "world",  occurrence: 1, emoji: "üåç" },

  // Underscore phase (after emojis, each step adds one more)
  { type: "underscore", word: "whoever",  occurrence: 1 },
  { type: "underscore", word: "believes", occurrence: 1 },
  { type: "underscore", word: "perish",   occurrence: 1 },
  { type: "underscore", word: "eternal",  occurrence: 1 },
  { type: "underscore", word: "life",     occurrence: 1 },
];

/* =========================================================
   EXTRA PRACTICE GAMES (add more later)
   ========================================================= */
const EXTRA_GAMES = [
  {
    id: "scrambled_phrases",
    title: "Put the Verse in Order",
    description: "Tap the phrases in the correct order.",
  },
  {
    id: "falling_words",
    title: "Falling Words",
    description: "Say each word as it falls from the sky.",
  },
  {
    id: "missing_words",
    title: "Missing Words",
    description: "Type the missing words from memory.",
  }
];



function verseIdToRef(verseId){
  const parts = verseId.split("_");

  const book = parts[0][0].toUpperCase() + parts[0].slice(1);
  const chapter = parts[1];

  const verses = parts.slice(2);
  let versePart;

  if (verses.length === 1){
    versePart = verses[0];
  } else {
    versePart = `${verses[0]}‚Äì${verses[1]}`;
  }

  return `${book} ${chapter}:${versePart} (NIV)`;
}


/* =========================================================
   APP LOGIC
   ========================================================= */
const screenRoot = document.getElementById("screenRoot");
const stickyBar  = document.getElementById("stickyBar");
const stickyLeft = document.getElementById("stickyLeft");
const stickyRight= document.getElementById("stickyRight");

const overlay     = document.getElementById("overlay");
const modalTitle  = document.getElementById("modalTitle");
const modalBody   = document.getElementById("modalBody");
const modalActions= document.getElementById("modalActions");

const audioEl = document.getElementById("audio");
audioEl.src = AUDIO_FILE;

document.getElementById("btnRestartTop").addEventListener("click", () => restart());

const AppState = {
    
  screen: "title", // title | instructions | full | step | final | done | extraGate | extraMenu | extraGame
  stepIndex: 0,    // 0..HIDE_PLAN.length (step pages are 1..HIDE_PLAN.length)
  extraGameId: null, // which extra practice game is selected
  extraGameState: null, // holds state for extra practice games
  hintCountFinal: 0,
  revealedOnFinal: new Set(), // token indices revealed on final page
    isAnimating: false,

};

const TokenType = {
  SPACE: "space",
  WORD: "word",
  PUNCT: "punct",
  OTHER: "other",
};

function tokenize(text){
  // Captures spaces, words (with optional apostrophes), numbers, and punctuation
  const re = /(\s+|[A-Za-z]+(?:'[A-Za-z]+)?|[0-9]+|[^\sA-Za-z0-9]+)/g;
  const raw = text.match(re) || [];
  return raw.map(t => {
    if (/^\s+$/.test(t)) return { type: TokenType.SPACE, text: t };
    if (/^[A-Za-z]+(?:'[A-Za-z]+)?$/.test(t)) return { type: TokenType.WORD, text: t };
    if (/^[0-9]+$/.test(t)) return { type: TokenType.WORD, text: t }; // treat numbers as "word-like"
    if (/^[^\sA-Za-z0-9]+$/.test(t)) return { type: TokenType.PUNCT, text: t };
    return { type: TokenType.OTHER, text: t };
  });
}

const tokens = tokenize(VERSE_TEXT);

/**
 * Precompute which token index each HIDE_PLAN entry targets (by word + occurrence).
 * This avoids any guesswork at render time.
 */
const planResolved = resolveHidePlanToTokenIndices(tokens, HIDE_PLAN);

function resolveHidePlanToTokenIndices(tokens, plan){
  const wordPositionsByLower = new Map();

  tokens.forEach((tok, idx) => {
    if (tok.type !== TokenType.WORD) return;
    const key = tok.text.toLowerCase();
    if (!wordPositionsByLower.has(key)) wordPositionsByLower.set(key, []);
    wordPositionsByLower.get(key).push(idx);
  });

  return plan.map((item, i) => {
    const key = String(item.word).toLowerCase();
    const list = wordPositionsByLower.get(key) || [];
    const occ = item.occurrence ?? 1;
    const tokenIndex = list[occ - 1];

    if (tokenIndex === undefined){
      console.warn(`HIDE_PLAN item #${i} could not find word="${item.word}" occurrence=${occ}.`);
    }

    return { ...item, tokenIndex };
  });
}

/* ---------- Rendering helpers ---------- */
function clearNode(node){
  while(node.firstChild) node.removeChild(node.firstChild);
}

function el(tag, attrs = {}, children = []) {
  const node = document.createElement(tag);

  for (const [k, v] of Object.entries(attrs)) {
    // ‚úÖ skip null / undefined / false attributes
    if (v === null || v === undefined || v === false) continue;

    if (k === "class") node.className = v;
    else if (k === "text") node.textContent = v;
    else if (k.startsWith("on") && typeof v === "function") node.addEventListener(k.slice(2), v);
    else node.setAttribute(k, v === true ? "" : v); // allow boolean attrs
  }

  for (const c of children) node.appendChild(c);
  return node;
}


function setSticky(show, leftButtons=[], rightButtons=[]){
  stickyBar.style.display = show ? "block" : "none";
  clearNode(stickyLeft);
  clearNode(stickyRight);
  leftButtons.forEach(b => stickyLeft.appendChild(b));
  rightButtons.forEach(b => stickyRight.appendChild(b));
}

function setNavDisabled(disabled){
  // Disable all sticky bar buttons
  document.querySelectorAll("#stickyBar button").forEach(b => b.disabled = disabled);

  // Also disable the top Restart button so it can‚Äôt interrupt transitions
  const restartBtn = document.getElementById("btnRestartTop");
  if (restartBtn) restartBtn.disabled = disabled;
}


function btn(label, opts = {}) {
  const { primary=true, small=false, ghost=false, onClick, disabled=false, title="" } = opts;
  let cls = "btn";
  if (!primary) cls += " secondary";
  if (ghost) cls += " ghost";
  if (small) cls += " small";

  const attrs = { class: cls, type:"button", title, onclick: onClick, text: label };
  if (disabled) attrs.disabled = true; // only add when true

  return el("button", attrs);
}


function showModal({ title, body, actions = [] }) {

  /* ----- TITLE ----- */
  if (title) {
    modalTitle.style.display = "";
    modalTitle.textContent = title;
  } else {
    modalTitle.style.display = "none";
  }

  /* ----- BODY ----- */
  modalBody.innerHTML = "";

  if (typeof body === "string") {
    modalBody.textContent = body;
  } else if (body instanceof Node) {
    modalBody.appendChild(body);
  }

  /* ----- ACTIONS ----- */
  clearNode(modalActions);
  actions.forEach(a => modalActions.appendChild(a));

  overlay.classList.add("show");

  /* ----- ACCESSIBILITY ----- */
  const firstBtn = modalActions.querySelector("button");
  if (firstBtn) firstBtn.focus();
}


function closeModal(){
  overlay.classList.remove("show");
}

overlay.addEventListener("click", (e) => {
  if (e.target === overlay) closeModal();
});

document.addEventListener("keydown", (e) => {
  if (e.key === "Escape" && overlay.classList.contains("show")) closeModal();
});

function navigateWithTransition(direction, applyStateChange){
      // Prevent double-taps during animation
  if (AppState.isAnimating) return;
  AppState.isAnimating = true;
  setNavDisabled(true);

  // direction: "forward" | "back"
  const stage = document.getElementById("cardStage");

  // Respect reduced motion
  const prefersReduced = window.matchMedia("(prefers-reduced-motion: reduce)").matches;

  // 1) Make a visual clone of what‚Äôs currently on screen
  const clone = screenRoot.cloneNode(true);
  clone.removeAttribute("id");
  clone.classList.add("page-clone");
  clone.classList.remove("page-live");
  stage.appendChild(clone);

  // 2) Update state + render the new page into the REAL screenRoot
  applyStateChange();
  render();

  // 3) Set up starting positions
  // Clone slides OUT; screenRoot starts OFFSCREEN then slides IN
  const inFrom  = (direction === "back") ? "slide-from-left" : "slide-from-right";
  const outTo   = (direction === "back") ? "slide-to-right"  : "slide-to-left";

  // Ensure base classes
  screenRoot.classList.add("page-live");

  // Reduced motion = crossfade (no sliding)
  if (prefersReduced){
    clone.style.transition = "opacity 240ms ease";
    screenRoot.style.transition = "opacity 240ms ease";

    clone.style.opacity = "1";
    screenRoot.style.opacity = "0";

    // next frame: fade
    requestAnimationFrame(() => {
      clone.style.opacity = "0";
      screenRoot.style.opacity = "1";
    });

    window.setTimeout(() => {
      clone.remove();
      // cleanup inline styles
      screenRoot.style.transition = "";
      screenRoot.style.opacity = "";
        AppState.isAnimating = false;
  setNavDisabled(false);

    }, Math.max(240, SLIDE_MS * 0.25));


    return;
  }

  // Normal motion = cross-slide
  // Put incoming page offscreen (no transition yet)
  screenRoot.classList.remove("slide-from-left","slide-from-right","slide-to-left","slide-to-right","slide-anim");
  screenRoot.classList.add(inFrom);

  // Force the browser to "notice" the starting position
  screenRoot.offsetWidth; // <-- forces reflow (normal trick)

  // Now animate both at the same time
  clone.classList.add("slide-anim", outTo);
  screenRoot.classList.add("slide-anim");
  screenRoot.classList.remove(inFrom); // returns to transform: none (0 position)

  // 4) Cleanup after animation finishes
  window.setTimeout(() => {
    clone.remove();
    screenRoot.classList.remove("slide-anim","slide-to-left","slide-to-right");
      AppState.isAnimating = false;
  setNavDisabled(false);    
  }, SLIDE_MS + 50);

}




/* ---------- Audio ---------- */
function resetAudioForNewPage(){
  try {
    audioEl.pause();
    audioEl.currentTime = 0;
    // Optional but helpful: forces the browser to treat the next play as a fresh start
    audioEl.load();
  } catch (e) {}
}


function toggleAudio(){
  if (!audioEl.src){
    showModal({
      title: "Audio not set",
      body: "No mp3 file is configured yet.",
      actions: [btn("OK", { onClick: () => closeModal() })]
    });
    return;
  }

  if (audioEl.paused){
    audioEl.play()
      .then(() => render())   // ‚úÖ update button text after playback starts
      .catch(() => {
        showModal({
          title: "Audio can‚Äôt play yet",
          body: "Your browser blocked playback. Tap the button again, or make sure the mp3 file is available.",
          actions: [btn("OK", { onClick: () => closeModal() })]
        });
      });
  } else {
    audioEl.pause();
    render();                 // ‚úÖ update button text after pausing
  }
}


audioEl.addEventListener("ended", () => render()); // refresh button label if you want
audioEl.addEventListener("play",  () => render());
audioEl.addEventListener("pause", () => render());

/* ---------- Verse rendering ---------- */

function buildRevealBody(leftText, wordText){
  const wrap = el("div", { class: "reveal-big" });

  const word = el("span", {
    text: String(wordText).toUpperCase()
  });

  wrap.appendChild(word);
  return wrap;
}



function underscoresForWord(word){
  if (!word) return "";
  // Keep first character, underscore the rest (letters/digits)
  const first = word[0];
  const restLen = Math.max(0, word.length - 1);
  return first + "_".repeat(restLen);
}

function buildTargetMap(activePlanItems){
  // tokenIndex -> plan item
  const map = new Map();
  activePlanItems.forEach(item => {
    if (typeof item.tokenIndex === "number") map.set(item.tokenIndex, item);
  });
  return map;
}

function renderVerse({mode, activeCount=0, onHint=null}){
  // mode: "full" | "steps" | "final"
  const container = el("div", { class: "verse" });
  const activeItems = planResolved.slice(0, activeCount);
  const targets = buildTargetMap(activeItems);

  tokens.forEach((tok, idx) => {
    if (tok.type === TokenType.SPACE){
    container.appendChild(document.createTextNode(tok.text));
    return;
    }


    if (tok.type !== TokenType.WORD){
      container.appendChild(el("span", { text: tok.text }));
      return;
    }

    if (mode === "full"){
      container.appendChild(el("span", { text: tok.text }));
      return;
    }

    if (mode === "final"){
      // Everything becomes first-letter + underscores and is hintable
      const disguised = underscoresForWord(tok.text);
      const node = el("span", {
        class: "hintable underscore",
        role: "button",
        tabindex: "0",
        "aria-label": "Tap to reveal word",
        text: disguised,
        onclick: () => {
          if (onHint) onHint(idx, tok.text);
            showModal({
            title: "",
            body: buildRevealBody(disguised, tok.text),
            actions: [btn("Close", { primary:false, onClick: () => closeModal() })]
            });

        }
      });
      node.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") node.click();
      });
      container.appendChild(node);
      return;
    }

    // mode === "steps"
    const target = targets.get(idx);
    if (!target){
      container.appendChild(el("span", { text: tok.text }));
      return;
    }

    if (target.type === "emoji"){
      const node = el("span", {
        class: "hintable emoji",
        role: "button",
        tabindex: "0",
        "aria-label": "Tap to reveal word",
        text: target.emoji || "‚ùì",
        onclick: () => {
          if (onHint) onHint(idx, tok.text);
            showModal({
            title: "",
            body: buildRevealBody(target.emoji || "‚ùì", tok.text),

            actions: [btn("Close", { primary:false, onClick: () => closeModal() })]
            });

        }
      });
      node.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") node.click();
      });
      container.appendChild(node);
      return;
    }

    // underscore target
    const disguised = underscoresForWord(tok.text);
    const node = el("span", {
      class: "hintable underscore",
      role: "button",
      tabindex: "0",
      "aria-label": "Tap to reveal word",
      text: disguised,
      onclick: () => {
        if (onHint) onHint(idx, tok.text);
        showModal({
        title: "",
        body: buildRevealBody(disguised, tok.text),
        actions: [btn("Close", { primary:false, onClick: () => closeModal() })]
        });

      }
    });
    node.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") node.click();
    });
    container.appendChild(node);
  });

  return container;
}

/* =========================================================
   EXTRA PRACTICE: SCRAMBLED PHRASES GAME
   ========================================================= */

function shuffleArray(arr){
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function randInt(min, max){
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Build phrases of 2‚Äì4 words from your existing `tokens` array.
function buildPhrasesFromTokens(){
  const wordsOnly = tokens.filter(t => t.type === TokenType.WORD).map(t => t.text);

  const phrases = [];
  let i = 0;

  while (i < wordsOnly.length){
    const remaining = wordsOnly.length - i;

    // Choose 2‚Äì4 word phrase length, but don‚Äôt exceed remaining words
    const len = Math.min(randInt(2, 4), remaining);

    const phrase = wordsOnly.slice(i, i + len).join(" ");
    phrases.push(phrase);
    i += len;
  }

  return phrases;
}

// Place phrase chips randomly inside the stage WITHOUT overlap,
// and optionally reuse saved positions so chips stay put across renders.
function placeChipsRandomly(stageEl, chipEls, opts = {}){
  const { positions = null, padding = 12, maxAttemptsPerChip = 250 } = opts;

  // Put all chips at 0,0 so the browser can measure them
  chipEls.forEach(chip => {
    chip.style.left = "0px";
    chip.style.top = "0px";
  });

  // We need one layout frame so sizes exist
  requestAnimationFrame(() => {
    const stageRect = stageEl.getBoundingClientRect();
    const stageW = stageRect.width;
    const stageH = stageRect.height;

    // Helper: rectangle overlap test
    function overlaps(a, b){
      return !(a.x + a.w <= b.x || b.x + b.w <= a.x || a.y + a.h <= b.y || b.y + b.h <= a.y);
    }

    // Already-placed rectangles
    const placedRects = [];

    chipEls.forEach((chip) => {
      const key = chip.dataset.key; // we will set this on each chip (phrase index)
      const chipRect = chip.getBoundingClientRect();
      const w = chipRect.width;
      const h = chipRect.height;

      const maxX = Math.max(padding, stageW - w - padding);
      const maxY = Math.max(padding, stageH - h - padding);

      // 1) If we have a saved position for this chip, try it first
      if (positions && key && positions[key]){
        const saved = positions[key];
        const proposed = { x: saved.x, y: saved.y, w, h };

        // Clamp to stage bounds (in case stage size changed)
        proposed.x = Math.max(padding, Math.min(proposed.x, maxX));
        proposed.y = Math.max(padding, Math.min(proposed.y, maxY));

        const hits = placedRects.some(r => overlaps(proposed, r));
        if (!hits){
          chip.style.left = `${proposed.x}px`;
          chip.style.top  = `${proposed.y}px`;
          placedRects.push(proposed);

          // Keep the clamped value saved
          positions[key] = { x: proposed.x, y: proposed.y };
          return;
        }
        // If saved position overlaps, fall through to find a new one
      }

      // 2) Find a non-overlapping random position
      let found = false;
      let x = padding, y = padding;

      for (let attempt = 0; attempt < maxAttemptsPerChip; attempt++){
        x = randInt(padding, Math.floor(maxX));
        y = randInt(padding, Math.floor(maxY));

        const proposed = { x, y, w, h };
        const hits = placedRects.some(r => overlaps(proposed, r));
        if (!hits){
          placedRects.push(proposed);
          found = true;
          break;
        }
      }

      // If we can‚Äôt find a perfect non-overlap, we still place it (rare on small screens)
      chip.style.left = `${x}px`;
      chip.style.top  = `${y}px`;

      if (positions && key){
        positions[key] = { x, y };
      }
    });
  });
}


function startScrambledPhrasesGame(){
  const phrases = buildPhrasesFromTokens();

  AppState.extraGameState = {
    gameId: "scrambled_phrases",
    phrases,
    order: phrases.map((_, i) => i),  // correct order is 0..n-1
    shuffledOrder: shuffleArray(phrases.map((_, i) => i)),
    expectedIndex: 0,
    placed: [],
    positions: {}, // phraseIdx -> {x,y} locked positions
    roundsTotal: 4,   // change to 3‚Äì5 if you want
    roundNum: 1,
    message: "",
  };
}


function renderScrambledPhrasesGame(){
  // Initialize if needed
  if (!AppState.extraGameState || AppState.extraGameState.gameId !== "scrambled_phrases"){
    startScrambledPhrasesGame();
  }

  const st = AppState.extraGameState;

  // Make sure we have a "placed" array (what has been placed into slots)
  if (!Array.isArray(st.placed)){
    st.placed = []; // will store phrase indices in correct order as user taps them
  }

  screenRoot.appendChild(el("div", { class:"kicker", text:"Extra Practice" }));
  screenRoot.appendChild(el("h1", { text:"Put the verse in order" }));
  screenRoot.appendChild(el("p", { text:"Tap the phrases in the correct order. Each correct phrase moves into the top area." }));

  // Progress
  const progressRow = el("div", { class:"phrase-progress" }, [
    el("div", { text: `Round ${st.roundNum} of ${st.roundsTotal}` }),
    el("div", { text: `Placed: ${st.placed.length} / ${st.phrases.length}` }),
  ]);
  screenRoot.appendChild(progressRow);

  // ---- Built (reserved) area ----
  const built = el("div", { class:"phrase-built" }, [
    el("div", { class:"phrase-built-label", text:"Your verse" })
  ]);

  const slots = el("div", { class:"phrase-slots" });

  // Create one slot per phrase. Filled slots show the phrase text.
  for (let i = 0; i < st.phrases.length; i++){
    const filledPhraseIdx = st.placed[i];
    const isFilled = typeof filledPhraseIdx === "number";

    slots.appendChild(
      el("div", {
        class: "phrase-slot" + (isFilled ? " filled" : ""),
        text: isFilled ? st.phrases[filledPhraseIdx] : "‚Ä¶"
      })
    );
  }

  built.appendChild(slots);
  screenRoot.appendChild(built);

  // Optional message
  if (st.message){
    screenRoot.appendChild(el("div", { class:"tip", text: st.message }));
  }

  // ---- Scrambled area ----
  const stage = el("div", { class:"phrase-stage", id:"phraseStage" });
  screenRoot.appendChild(stage);

  // Build chips ONLY for phrases not yet placed
  const remainingPhraseIdxs = st.shuffledOrder.filter(idx => !st.placed.includes(idx));

  const chips = [];
  remainingPhraseIdxs.forEach((phraseIdx) => {
    const phraseText = st.phrases[phraseIdx];

    const chip = el("div", {
      class: "phrase-chip",
      role: "button",
      tabindex: "0",
      text: phraseText,
      onclick: () => onTapPhrase(phraseIdx, chip),
    });
    chip.dataset.key = String(phraseIdx);


    chip.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") chip.click();
    });

    stage.appendChild(chip);
    chips.push(chip);
  });

  // Random positions (chips stay in place unless rerendered)
  placeChipsRandomly(stage, chips, { positions: st.positions });


  // Bottom controls
  const c = el("div", { class:"controls" }, [
    btn("Restart Round", {
      primary:false,
      onClick: () => {
        st.expectedIndex = 0;
        st.placed = [];
        st.message = "";
        st.positions = {};
        st.shuffledOrder = shuffleArray(st.phrases.map((_, i) => i));
        render();
      }
    }),
    btn("Back to Title", {
      primary:false,
      onClick: () => {
        AppState.extraGameId = null;
        AppState.extraGameState = null;
        AppState.screen = "title";
        render();
      }
    }),
  ]);

  screenRoot.appendChild(c);
  setSticky(false);

  // ---------- click handler ----------
  function onTapPhrase(phraseIdx, chipEl){
    const correctPhraseIdx = st.order[st.expectedIndex];

    // Correct phrase
    if (phraseIdx === correctPhraseIdx){
      // Add to placed
      st.placed.push(phraseIdx);
      st.expectedIndex += 1;
      st.message = "";

      // Remove the chip from the scrambled area without moving the others
      // (We remove from DOM now, and we also rerender to update top slots.)
      try { chipEl.remove(); } catch (e) {}

      // Completed all phrases
      if (st.expectedIndex >= st.phrases.length){
  // First, re-render so the last slot visibly fills
  render();

  // Then, show the modal on the next frame (after paint)
  requestAnimationFrame(() => {
    showModal({
      title: "Good job! üéâ",
      body: "You put the whole verse in order.",
      actions: [
        btn("Play again", {
          onClick: () => {
            closeModal();
            startScrambledPhrasesGame();
            render();
          }
        }),
        btn("Back to Title", {
          primary:false,
          onClick: () => {
            closeModal();
            AppState.extraGameId = null;
            AppState.extraGameState = null;
            AppState.screen = "title";
            render();
          }
        })
      ]
    });
  });

  return;
}


      // Re-render so the reserved area updates
      render();
      return;
    }

    // Wrong phrase: feedback flash
    chipEl.classList.add("wrong");
    window.setTimeout(() => chipEl.classList.remove("wrong"), 220);
  }
}



/* ---------- Screens ---------- */
function render(){
  clearNode(screenRoot);

  // Default sticky controls off; each screen configures it.
  setSticky(false);

  if (AppState.screen === "title") return renderTitle();
  if (AppState.screen === "instructions") return renderInstructions();
  if (AppState.screen === "full") return renderFullVerse();
  if (AppState.screen === "step") return renderStep();
  if (AppState.screen === "final") return renderFinal();
  if (AppState.screen === "done") return renderDone();
  if (AppState.screen === "extraGate") return renderExtraGate();
  if (AppState.screen === "extraMenu") return renderExtraMenu();
  if (AppState.screen === "extraGame") return renderExtraGame();


}

function renderTitle(){
  screenRoot.appendChild(el("div", { class:"kicker", text:"Welcome" }));
  screenRoot.appendChild(el("h1", { text: APP_TITLE }));
  screenRoot.appendChild(el("p", { text:"You‚Äôll read the verse out loud, then practice again as some words turn into emojis and blanks." }));

  const c = el("div", { class:"controls" }, [
    btn("Get Started", {
      onClick: () => {
        resetAudioForNewPage();
        AppState.screen = "instructions";
        render();
      }
    }),

    btn("Extra Practice", {
      primary:false,
      onClick: () => {
        resetAudioForNewPage();
        AppState.screen = "extraGate";
        render();
      }
    }),
  ]);



  
  screenRoot.appendChild(c);
}


function renderInstructions(){
  screenRoot.appendChild(el("div", { class:"kicker", text:"Instructions" }));
  screenRoot.appendChild(el("h1", { text:"How It Works" }));
  screenRoot.appendChild(el("h3", { text:"üî¥ On each page, read the verse out loud. " }));
  screenRoot.appendChild(el("h3", { text:"üî¥ Each time you click 'Next,' a different word from the verse will be replaced with emojis or blanks." }));
  screenRoot.appendChild(el("h3", { text:"üî¥ Try your best to say the verse again, even with these missing words." }));

  const c = el("div", { class:"controls" }, [
    btn("Continue", {
      onClick: () => {
        resetAudioForNewPage();
        AppState.screen = "full";
        render();
      }
    }),
    btn("Back", {
      primary:false,
      onClick: () => {
        resetAudioForNewPage();
        AppState.screen = "title";
        render();
      }
    })
  ]);

  screenRoot.appendChild(c);
}


function renderVerseCardHeader({stepLabel=null, stepProgress=null} = {}){
  const row = el("div", { class:"verse-ref" });
  row.appendChild(el("div", { text: VERSE_REF }));

  if (stepLabel){
    row.appendChild(el("div", { class:"progress", text: stepLabel }));
  } else {
    row.appendChild(el("div", { class:"progress", text: "" }));
  }

  const box = el("div", { class:"verse-box" });
  box.appendChild(row);

  if (typeof stepProgress === "number"){
    const bar = el("div", { class:"progress-bar" }, [
      el("div", { })
    ]);
    bar.firstChild.style.width = `${Math.max(0, Math.min(100, stepProgress))}%`;
    box.appendChild(bar);
  }

  return box;
}

function renderFullVerse(){
  screenRoot.appendChild(el("div", { class:"kicker", text:"Step 1" }));
  screenRoot.appendChild(el("h1", { text:"Read the verse" }));
  screenRoot.appendChild(el("p", { text:"Read it slowly. You can tap ‚ÄúRead it to Me‚Äù to listen." }));

  const box = renderVerseCardHeader({ stepLabel:"Full verse", stepProgress: 0 });
  box.appendChild(renderVerse({mode:"full"}));
  box.appendChild(
  el("div", {
    class: "scripture-credit",
    text: "Scripture taken from the Holy Bible, New International Version¬Æ (NIV¬Æ). ¬© 1973, 1978, 1984, 2011 by Biblica, Inc. Used by permission."
  })
);
screenRoot.appendChild(box);


  // Sticky bar: audio + next
  setSticky(true,
    [
      btn(audioEl.paused ? "üîä Read it to Me" : "Pause Reading", { primary:false, onClick: () => toggleAudio() })
    ],
    [
        btn("Start Practice", {
        onClick: () => {
        resetAudioForNewPage();
        navigateWithTransition("forward", () => {
            AppState.screen = "step";
            AppState.stepIndex = 1;
        });
        }

        })

    ]
  );
}

function renderStep(){
  const totalSteps = HIDE_PLAN.length;
  const step = AppState.stepIndex; // 1..totalSteps

  screenRoot.appendChild(el("div", { class:"kicker", text:`Practice` }));
  screenRoot.appendChild(el("h1", { text:"Say it again" }));
  screenRoot.appendChild(el("p", { text:"If you forget a hidden word, tap it to reveal the answer." }));

  const label = `Page ${step} of ${totalSteps}`;
  const progressPct = (step / (totalSteps + 1)) * 100;

  const box = renderVerseCardHeader({ stepLabel: label, stepProgress: progressPct });

  box.appendChild(renderVerse({
    mode: "steps",
    activeCount: step,
    onHint: () => { /* optional: track hints per-step later */ }
  }));
  screenRoot.appendChild(box);

  const isLast = (step >= totalSteps);

setSticky(true,
  [
    btn(audioEl.paused ? "üîä Read it to Me" : "Pause Reading", { primary:false, onClick: () => toggleAudio() }),

    btn("Back", {
      primary:false,
      onClick: () => {
        resetAudioForNewPage();
        navigateWithTransition("back", () => {
          if (step <= 1){
            AppState.screen = "full";
          } else {
            AppState.stepIndex = step - 1;
          }
        });
      }
    })
  ],
  [
    btn(isLast ? "Next" : "Next", {
      onClick: () => {
        resetAudioForNewPage();
        navigateWithTransition("forward", () => {
          if (isLast){
            AppState.screen = "final";
            AppState.hintCountFinal = 0;
            AppState.revealedOnFinal.clear();
          } else {
            AppState.stepIndex = step + 1;
          }
        });
      }
    })
  ]
);
}

function renderFinal(){
  screenRoot.appendChild(el("div", { class:"kicker", text:"Final" }));
  screenRoot.appendChild(el("h1", { text:"No hints‚Ä¶ if you can!" }));
  screenRoot.appendChild(el("p", { text:"Try to say the whole verse out loud. If you get stuck, tap a word to reveal it‚Äîthen try again." }));

  const totalSteps = HIDE_PLAN.length;
  const progressPct = ((totalSteps + 1) / (totalSteps + 1)) * 100;

  const box = renderVerseCardHeader({ stepLabel: "All blanks", stepProgress: progressPct });

  box.appendChild(renderVerse({
    mode: "final",
    onHint: (tokenIndex) => {
      // Count each token reveal once (so repeated taps don‚Äôt inflate)
      if (!AppState.revealedOnFinal.has(tokenIndex)){
        AppState.revealedOnFinal.add(tokenIndex);
        AppState.hintCountFinal += 1;
      }
    }
  }));

  screenRoot.appendChild(box);

  setSticky(true,
    [
      btn(audioEl.paused ? "üîä Read it to Me" : "Pause Reading", { primary:false, onClick: () => toggleAudio() }),
        btn("Back", {
        primary:false,
            onClick: () => {
            resetAudioForNewPage();
            navigateWithTransition("back", () => {
                AppState.screen = "step";
                AppState.stepIndex = HIDE_PLAN.length;
            });
            }

        })

    ],
    [
      btn("Next", {
        onClick: () => {
          if (AppState.hintCountFinal > 0){
            showModal({
              title: "Let‚Äôs try that again!",
              body: `Looks like you needed ${AppState.hintCountFinal} hint${AppState.hintCountFinal === 1 ? "" : "s"}. Try saying the verse again without tapping any words.`,
              actions: [
                btn("Try Again", {
                  onClick: () => {
                    closeModal();
                    AppState.hintCountFinal = 0;
                    AppState.revealedOnFinal.clear();
                    render();
                  }
                })
              ]
            });
            return;
          }

          showModal({
            title: "How Did You Do?",
            body: "Could you say the verse without any hints?",
            actions: [
              btn("Yes!", {
                onClick: () => {
                  closeModal();
                  AppState.screen = "done";
                  render();
                }
              }),
              btn("Let Me Try Again", {
                primary:false,
                onClick: () => {
                  closeModal();
                  AppState.hintCountFinal = 0;
                  AppState.revealedOnFinal.clear();
                  render();
                }
              })
            ]
          });
        }
      })
    ]
  );
}

function renderDone(){
  screenRoot.appendChild(el("div", { class:"kicker", text:"Nice work!" }));
  screenRoot.appendChild(el("h1", { text:"You did it üéâ" }));
  screenRoot.appendChild(el("p", { text:"Want to practice again or try a new verse later? (You‚Äôll be able to swap verses by editing the config block.)" }));

  const c = el("div", { class:"controls" }, [
    btn("Practice Again", {
      onClick: () => {
        AppState.screen = "full";
        AppState.stepIndex = 0;
        AppState.hintCountFinal = 0;
        AppState.revealedOnFinal.clear();
        render();
      }
    }),
    btn("Back to Title", {
      primary:false,
      onClick: () => {
        restart();
      }
    })
  ]);
  screenRoot.appendChild(c);

  setSticky(false);
}

/* =========================================================
   EXTRA PRACTICE SCREENS
   ========================================================= */

function renderExtraGate(){
  screenRoot.appendChild(el("div", { class:"kicker", text:"Extra Practice" }));
  screenRoot.appendChild(el("h1", { text:"Stop ‚úã" }));
  screenRoot.appendChild(el("p", { text:"This section is for people who have already learned the verse." }));

  const c = el("div", { class:"controls" }, [
    btn("I've learned the verse", {
      onClick: () => {
        AppState.screen = "extraMenu";
        render();
      }
    }),
    btn("I haven't learned the verse", {
      primary:false,
      onClick: () => {
        AppState.screen = "title";
        render();
      }
    })
  ]);

  screenRoot.appendChild(c);
  setSticky(false);
}


function renderExtraMenu(){
  screenRoot.appendChild(el("div", { class:"kicker", text:"Extra Practice" }));
  screenRoot.appendChild(el("h1", { text:"Choose an activity" }));
  screenRoot.appendChild(el("p", { text:"Pick a game below. You can add more games later." }));

  const list = el("div", { class:"controls" });

  EXTRA_GAMES.forEach(game => {
    const card = el("div", { class:"card", style:"box-shadow:none; margin-top:12px;" }, [
      el("div", { class:"card-inner" }, [
        el("h2", { text: game.title }),
        el("p", { text: game.description }),
        btn("Start", {
          onClick: () => {
            resetAudioForNewPage();
            AppState.extraGameId = game.id;
            AppState.screen = "extraGame";
            render();
          }
        }),
      ])
    ]);

    list.appendChild(card);
  });

  screenRoot.appendChild(list);

  const backRow = el("div", { class:"controls" }, [
    btn("Back to Title", {
      primary:false,
      onClick: () => {
        AppState.screen = "title";
        render();
      }
    })
  ]);

  screenRoot.appendChild(backRow);
  setSticky(false);
}


function renderExtraGame(){
  const game = EXTRA_GAMES.find(g => g.id === AppState.extraGameId);

  screenRoot.appendChild(el("div", { class:"kicker", text:"Extra Practice" }));

  if (!game){
    screenRoot.appendChild(el("h1", { text:"Game not found" }));
    screenRoot.appendChild(el("p", { text:"Returning to the menu." }));
    AppState.screen = "extraMenu";
    render();
    return;
  }

  if (AppState.extraGameId === "scrambled_phrases"){
    return renderScrambledPhrasesGame();
  }

  if (AppState.extraGameId === "falling_words"){
    screenRoot.appendChild(el("h1", { text: game.title }));
    screenRoot.appendChild(el("p", { text: game.description }));
    screenRoot.appendChild(el("div", { class:"tip", text:"Coming next: Falling Words." }));
  } 
  else if (AppState.extraGameId === "missing_words"){
    screenRoot.appendChild(el("h1", { text: game.title }));
    screenRoot.appendChild(el("p", { text: game.description }));
    screenRoot.appendChild(el("div", { class:"tip", text:"Coming next: Missing Words." }));
  } 
  else {
    screenRoot.appendChild(el("h1", { text: game.title }));
    screenRoot.appendChild(el("p", { text: game.description }));
    screenRoot.appendChild(el("div", { class:"tip", text:"This game isn‚Äôt implemented yet." }));
  }

  const c = el("div", { class:"controls" }, [
    btn("Back to Menu", {
      primary:false,
      onClick: () => {
        AppState.extraGameId = null;
        AppState.extraGameState = null;
        AppState.screen = "extraMenu";
        render();
      }
    })
  ]);

  screenRoot.appendChild(c);
  setSticky(false);
}



/* ---------- Restart ---------- */
function restart(){
  closeModal();
  resetAudioForNewPage();
  AppState.screen = "title";
  AppState.stepIndex = 0;
  AppState.hintCountFinal = 0;
  AppState.revealedOnFinal.clear();
  render();
}




/* Boot */
render();


</script>




</body>
</html>
