<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Emoji Hunt Quiz</title>
<style>
:root{
  --qaH: 120px;  /* JS keeps this synced with the height of the QA block */
  --bg:#fafafa; --ink:#222; --panel:#ffffff;
  --good:#16a34a; --bad:#dc2626; --muted:#f1f1f1;
}

html,body{height:100%}
body{
  margin:0; background:var(--bg); color:var(--ink);
  font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
  display:flex; justify-content:center;
}
.game{ width:min(1000px,100vw); height:100dvh; display:flex; flex-direction:column; }

header{
  display:flex; gap:12px; align-items:center; justify-content:space-between;
  padding:12px 16px; background:var(--panel); box-shadow:0 2px 10px rgba(0,0,0,.06);
  position:sticky; top:0; z-index:10;
}
.hud{display:flex; gap:16px; align-items:center; flex-wrap:wrap}
.pill{background:var(--muted); padding:6px 10px; border-radius:999px; font-weight:700}
.screen{ flex:1; position:relative; overflow:hidden; border-top:1px solid #eee;
         background: linear-gradient(#ffffff, #f6f8ff); }

/* Question & answers row */
.qa{
  position:absolute; left:50%; transform:translateX(-50%);
  top:10px; z-index:2; width:min(940px, 96%);
  display:flex; flex-direction:column; gap:10px;
  align-items:center;
}
.question{
  background:var(--panel); padding:10px 14px; border-radius:12px;
  box-shadow:0 2px 10px rgba(0,0,0,.08);
  font-size:clamp(16px,2.2vw,22px); text-align:center; line-height:1.25;
}
.answers{ display:grid; grid-template-columns:repeat(4, minmax(0,1fr)); gap:10px; width:100%; }
.ans{
  display:flex; align-items:center; justify-content:center; gap:8px;
  border-radius:12px; padding:10px 8px; font-weight:800; border:2px solid transparent;
  box-shadow:0 2px 8px rgba(0,0,0,.06); user-select:none; background:#fff;
}
.ans .num{ font-weight:900; opacity:.9 }
.ans .emoji{ font-size:1.2em; line-height:1; }
.ans .txt{ text-align:center; font-size:clamp(14px,1.8vw,18px); line-height:1.2 }

/* soft colored borders for variety (not gameplay) */
.c0{ border-color:#ffb3b3; background:#fff8f8; }
.c1{ border-color:#ffd166; background:#fff9ea; }
.c2{ border-color:#9be29b; background:#f4fff4; }
.c3{ border-color:#a7c4ff; background:#f4f7ff; }

/* Grid */
.gridWrap{
  position:absolute; inset:0; display:grid; place-items:center; padding:16px;
  padding-top: calc(var(--qaH) + 12px);
}
.grid{
  display:grid;
  gap:8px;
  width:min(880px, 92vw);
  grid-template-columns: repeat(var(--grid-cols, 10), 1fr);
}

.cell{
  /* square emoji tile */
  display:grid; place-items:center;
  border-radius:12px; height:0; padding-bottom:100%;
  position:relative; cursor:pointer;
  transition: transform 120ms ease, opacity 120ms ease, box-shadow 120ms ease;
  touch-action: manipulation; -webkit-tap-highlight-color: transparent;
  background:#ffffff; box-shadow:0 2px 8px rgba(0,0,0,.06);
  border:2px solid rgba(0,0,0,.06);
}
.cell .g{
  /* the emoji glyph itself */
  position:absolute; inset:0; display:grid; place-items:center;
  font-size: clamp(20px, 4.5vw, 38px); line-height:1;
}
.cell:active{ transform: scale(.96) }
.cell.hit{ opacity:.35; cursor:default; filter:saturate(.6) }
.cell.rightNow{ box-shadow:0 0 0 6px rgba(22,163,74,.22), 0 6px 18px rgba(0,0,0,.10) }
.cell.wrongNow{ box-shadow:0 0 0 6px rgba(220,38,38,.22), 0 6px 18px rgba(0,0,0,.10) }

/* Toast (center badge) */
.toast{
  position:absolute; left:50%; top:50%;
  transform: translate(-50%,-50%) scale(.92);
  background:#111; color:#fff; padding:14px 18px; border-radius:16px;
  font-weight:900; font-size:clamp(18px, 3.2vw, 32px); line-height:1.1;
  box-shadow:0 10px 30px rgba(0,0,0,.25); opacity:0; pointer-events:none;
  transition: opacity .18s ease, transform .18s ease; z-index:5;
}
.toast.show{ opacity:1; transform: translate(-50%,-50%) scale(1) }
.toast.success{ background:var(--good) }
.toast.error{ background:var(--bad) }
.toast.info{ background:#111 }

/* Overlays */
.overlay{
  position:absolute; inset:0; display:none; place-items:center; text-align:center;
  padding:24px; z-index:20; background:#fff;
}
.overlay.show{display:grid}
.stack{display:flex; flex-direction:column; gap:14px; align-items:center}
.btn{ border:none; background:#111; color:#fff; padding:12px 16px; border-radius:12px; font-weight:800; cursor:pointer}
.btn.secondary{background:#444}
.small{opacity:.75; font-size:14px}

/* Final stats / badge style */
.finalStats{ display:flex; flex-direction:column; gap:12px; align-items:center; margin-top:4px; }
@keyframes popIn{ 0%{ transform: translateY(6px) scale(.96); opacity:0 } 100%{ transform: translateY(0) scale(1); opacity:1 } }
.statBadge{
  display:inline-flex; align-items:center; gap:8px;
  padding:12px 16px; border-radius:16px; font-weight:900; font-size:clamp(18px,3.2vw,28px); line-height:1.1; color:#fff;
  box-shadow:0 10px 30px rgba(0,0,0,.22); animation: popIn 260ms ease-out both;
}
.statBadge.score   { background:#16a34a } /* green */
.statBadge.correct { background:#2563eb; animation-delay:.08s } /* blue */

/* Between-screen answer card */
.betweenAnswer{
  font-size: clamp(18px, 2.6vw, 28px);
  font-weight: 800;
  background: #fff;
  color: #111;
  padding: 12px 16px;
  border-radius: 14px;
  box-shadow: 0 6px 18px rgba(0,0,0,.10);
  max-width: 720px;
}

/* Tiny confetti */
.confetti{
  position:absolute; pointer-events:none; z-index:30; font-size:18px; opacity:0;
  transform: translate(-50%,-50%) scale(.8); animation: confettiPop 600ms ease-out forwards;
}
@keyframes confettiPop{
  0% { opacity:0; transform: translate(-50%,-50%) scale(.8) }
  25%{ opacity:1; transform: translate(-50%,-90%) scale(1) }
  100%{ opacity:0; transform: translate(-50%,-140%) scale(1.1) }
}
</style>
</head>
<body>
  <div class="game" id="game">
    <header>
      <div class="hud">
        <span class="pill" id="progress">Q 1 / 1</span>
        <span class="pill">Score: <span id="score">0</span></span>
        <span class="pill">Time: <span id="time">0</span>s</span>
      </div>
    </header>

    <main class="screen" id="screen" aria-live="polite">
      <!-- Question / Answers -->
      <div class="qa" id="qa" style="display:none">
        <div class="question" id="question">Loading‚Ä¶</div>
        <div class="answers" id="answers"></div>
      </div>

      <!-- Grid -->
      <div class="gridWrap">
        <div class="grid" id="grid" aria-label="emoji grid"></div>
      </div>

      <!-- Toast -->
      <div class="toast" id="toast" role="status" aria-live="assertive"></div>

      <!-- Start -->
      <!-- Rotate Notice (for mobile landscape) -->
<!-- Rotate Notice (for mobile landscape) -->
<section class="overlay" id="rotateNotice">
  <div class="stack">
    <div style="font-size:42px">üì± Use Vertical Mode</div>
    <div class="small">If using a phone or tablet, this game works best in <b>vertical (portrait)</b> mode.</div>
    <button class="btn" id="rotateOkBtn">OK</button>
  </div>
</section>



      <section class="overlay show" id="start">
        <div class="stack">
          <div style="font-size:42px">üòÄ Emoji Hunt Quiz</div>
          <div class="small">Tap the emojis that match the <b>correct answer‚Äôs emoji</b> before time runs out.</div>
          <div class="small">30 seconds per question ‚Ä¢ Mouse or touch</div>
          <div style="display:flex; gap:10px">
            <button class="btn" id="startBtn">Start</button>
            <button class="btn secondary" id="howBtn">How to Play</button>
          </div>
        </div>
      </section>

      <!-- How-to -->
      <section class="overlay" id="how">
        <div class="stack">
          <div style="font-size:36px">üìö How to Play</div>
          <div style="max-width:640px">
            A Bible question appears with four answers. Each answer has its own emoji.<br/>
            For 30 seconds, tap as many grid squares as you can that match the emoji of the <b>correct</b> answer.<br/>
            Correct tap: +3 points ‚Ä¢ Wrong tap: ‚àí1 point ‚Ä¢ Clear early = ‚ö° Speed Bonus
          </div>
          <button class="btn" id="backBtn">Back</button>
        </div>
      </section>

      <!-- Between-rounds -->
      <section class="overlay" id="between">
        <div class="stack">
          <div class="statBadge correct" role="status" aria-live="polite">‚úÖ Correct Answer</div>
          <div id="betweenText" class="betweenAnswer"></div>
          <div class="small" id="betweenCountdown">(next question in 7s)</div>
        </div>
      </section>

      <!-- Game over -->
      <section class="overlay" id="over">
        <div class="stack">
          <div style="font-size:34px">üèÅ Game Over</div>
          <div id="final"></div>
          <button class="btn" id="againBtn">Play Again</button>
        </div>
      </section>
    </main>
  </div>

<script>
/* ===== QUESTIONS (now with emojis per choice) =====
   Note: We keep isCorrect:true and add an emoji per choice.
   The grid for each round will be filled with these four emojis.
*/

// ===== START OF QUESTIONS =====
const QUESTIONS = [
  {
    q: "What would happen if they ate the fruit?",
    choices: [
      { text: "They'd die", isCorrect:true, emoji:"üíÄ" },
      { text: "They'd turn into angels", emoji:"üòá" },
      { text: "They'd live forever", emoji:"‚ôæÔ∏è" },
      { text: "They'd sleep for a week", emoji:"üò¥" }
    ]
  },
  {
    q: "Who was the serpent that came to Eve?",
    choices: [
      { text: "The devil", isCorrect:true, emoji:"üêç" },
      { text: "Just a snake", emoji:"ü™±" },
      { text: "An angel", emoji:"üëº" },
      { text: "Adam's pet", emoji:"üê∂" }
    ]
  },
  {
    q: "What did the serpent tell Eve?",
    choices: [
      { text: "You won't die; you'll be like God", isCorrect:true, emoji:"üó£Ô∏è" },
      { text: "Don't touch the fruit", emoji:"‚úã" },
      { text: "God doesn't love you", emoji:"üíî" },
      { text: "Run from Adam", emoji:"üèÉ‚Äç‚ôÄÔ∏è" }
    ]
  },
  {
    q: "After talking to the serpent, what did Eve do?",
    choices: [
      { text: "Ate it and gave some to Adam", isCorrect:true, emoji:"üçé" },
      { text: "Told God right away", emoji:"üôè" },
      { text: "Threw the fruit away", emoji:"üóëÔ∏è" },
      { text: "Named the serpent", emoji:"üè∑Ô∏è" }
    ]
  },
  {
    q: "After eating, what did Adam and Eve realize?",
    choices: [
      { text: "They were naked and hid", isCorrect:true, emoji:"üôà" },
      { text: "They could fly", emoji:"ü™Ω" },
      { text: "They were angels", emoji:"üòá" },
      { text: "They forgot their names", emoji:"‚ùì" }
    ]
  },
  {
    q: "What curse did God give the serpent?",
    choices: [
      { text: "Crawl; crushed by Eve's Son", isCorrect:true, emoji:"üêç" },
      { text: "Lose its voice", emoji:"ü§ê" },
      { text: "Turn to dust", emoji:"üß±" },
      { text: "Live in the ocean", emoji:"üåä" }
    ]
  },
  {
    q: "What curse did God give the woman?",
    choices: [
      { text: "Pain in childbirth; conflict", isCorrect:true, emoji:"üë∂" },
      { text: "Grow thorns", emoji:"üåµ" },
      { text: "Lose her voice", emoji:"ü§ê" },
      { text: "Never sleep", emoji:"ü´†" }
    ]
  },
  {
    q: "What curse did God give the man?",
    choices: [
      { text: "Hard work and death", isCorrect:true, emoji:"üßë‚Äçüåæ" },
      { text: "No more garden food", emoji:"ü•¶" },
      { text: "Forget Eve", emoji:"üß†" },
      { text: "Never rest", emoji:"‚è∞" }
    ]
  },
  {
    q: "After the curses, what did God do?",
    choices: [
      { text: "Clothed them; sent them out", isCorrect:true, emoji:"üß•" },
      { text: "Destroyed the garden", emoji:"üî•" },
      { text: "Made them build a city", emoji:"üèôÔ∏è" },
      { text: "Told them to swim away", emoji:"üèä" }
    ]
  },
  {
    q: "Who is the Son of Eve who crushed the serpent?",
    choices: [
      { text: "Jesus‚Äîdied and rose again", isCorrect:true, emoji:"‚úùÔ∏è" },
      { text: "Moses", emoji:"üìú" },
      { text: "Abraham", emoji:"üßî" },
      { text: "David", emoji:"ü™ï" }
    ]
  }
];
// ===== END OF QUESTIONS =====

/* ===== CONFIG ===== */
// Dynamically adjust grid size based on screen height
const GRID_SIZE = window.innerHeight > 850 ? 10 :
                  window.innerHeight > 700 ? 8 : 6;  // 10x10 desktop, 8x8 tablet, 6x6 phone

// Update grid columns in CSS to match GRID_SIZE
document.documentElement.style.setProperty('--grid-cols', GRID_SIZE);


const ROUND_TIME = 30;         // seconds per question
const CORRECT_POINTS = 3;
const WRONG_POINTS   = 1;      // deducted
const BETWEEN_SECONDS = 7;     // between-round display time

const SPEED_BONUS_PER_SECOND = 1;
const SPEED_BONUS_CAP = Infinity;

/* ===== STATE & ELEMENTS ===== */
let idx = 0, score = 0, correctSquares = 0, timeLeft = 0, timer = null;
let incorrectSquares = 0;

let targetEmoji = ""; // emoji string for the correct answer this round
let locked = false;
let currentCorrectText = "";
let betweenTimer = null;

let roundCorrectTotal = 0;
let roundCorrectHit   = 0;

const screen    = document.getElementById('screen');
const qaWrap    = document.getElementById('qa');
const questionEl= document.getElementById('question');
const answersEl = document.getElementById('answers');
const gridEl    = document.getElementById('grid');
const toast     = document.getElementById('toast');

const betweenOverlay = document.getElementById('between');
const betweenText    = document.getElementById('betweenText');
const betweenCountdown = document.getElementById('betweenCountdown');

const startOverlay = document.getElementById('start');
const overOverlay  = document.getElementById('over');
const howOverlay   = document.getElementById('how');
const finalEl      = document.getElementById('final');

const progressEl = document.getElementById('progress');
const scoreEl    = document.getElementById('score');
const timeEl     = document.getElementById('time');

document.getElementById('startBtn').addEventListener('click', startGame);

// Detect landscape orientation ‚Äî show only on touch devices (phones/tablets)
function checkOrientation() {
  const rotateNotice = document.getElementById('rotateNotice');
  const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  const isLandscape = window.innerWidth > window.innerHeight;

  if (isTouchDevice && isLandscape) {
    rotateNotice.classList.add('show');
  } else {
    rotateNotice.classList.remove('show');
  }
}


const rotateNotice = document.getElementById('rotateNotice');

if (rotateOkBtn) {
  rotateOkBtn.addEventListener('click', () => {
    rotateNotice.classList.remove('show');  // hide the rotate screen
    startOverlay.classList.add('show');     // show the title/start screen
  });
}




// Run on load and on resize
window.addEventListener('load', checkOrientation);
window.addEventListener('resize', checkOrientation);


document.getElementById('againBtn').addEventListener('click', startGame);
document.getElementById('howBtn').addEventListener('click', ()=>{ startOverlay.classList.remove('show'); howOverlay.classList.add('show'); });
document.getElementById('backBtn').addEventListener('click', ()=>{ howOverlay.classList.remove('show'); startOverlay.classList.add('show'); });

window.addEventListener('resize', updateGridOffset);

['startBtn','againBtn','howBtn','backBtn'].forEach(id=>{
  const el = document.getElementById(id);
  if (!el) return;
  el.addEventListener('pointerdown', ensureAudioReady, { once:true });
});

function startGame(){
  idx = 0; score = 0; correctSquares = 0; incorrectSquares = 0;
  scoreEl.textContent = score;
  startOverlay.classList.remove('show');
  overOverlay.classList.remove('show');
  howOverlay.classList.remove('show');
  qaWrap.style.display = 'block';
  updateGridOffset();
  nextQuestion();
}

function nextQuestion(){
  clearInterval(timer);
  gridEl.innerHTML = "";
  locked = false;

  if (idx >= QUESTIONS.length){ endGame(); return; }

  const item = QUESTIONS[idx];
  progressEl.textContent = `Q ${idx+1} / ${QUESTIONS.length}`;
  questionEl.textContent = item.q;

  // Build shuffled choices and assign soft color classes c0..c3 (for looks only)
  const choices = item.choices.map(c => ({ ...c })); // copy
  shuffleInPlace(choices);
  choices.forEach((c, i) => { c.skin = ['c0','c1','c2','c3'][i]; });

  // Render answers row with emoji + text
  answersEl.innerHTML = "";
  choices.forEach((c,i)=>{
    const div = document.createElement('div');
    div.className = `ans ${c.skin}`;
    div.innerHTML = `<span class="num">${i+1}.</span> <span class="emoji">${c.emoji || '‚ùì'}</span> <span class="txt">${c.text}</span>`;
    answersEl.appendChild(div);
  });
  updateGridOffset();

  // Determine target emoji from the correct choice
  const correctChoice = choices.find(c => c.isCorrect);
  targetEmoji = correctChoice ? (correctChoice.emoji || '') : '';
  currentCorrectText = (correctChoice ? `${correctChoice.emoji || ''} ${correctChoice.text}` : "");

  // Build an even-ish distribution of the 4 emojis for the grid
  const palette = choices.map(c => c.emoji || '‚ùì');        // 4 emojis for this round
  const cells = buildTokenBag(GRID_SIZE*GRID_SIZE, palette);
  shuffleInPlace(cells);

  // Count how many cells match the target emoji
  roundCorrectTotal = cells.filter(e => e === targetEmoji).length;
  roundCorrectHit   = 0;

  // Render grid of emoji buttons
  cells.forEach(emo=>{
    const btn = document.createElement('button');
    btn.className = 'cell';
    btn.setAttribute('aria-label', `emoji ${emo}`);
    const glyph = document.createElement('div');
    glyph.className = 'g';
    glyph.textContent = emo;
    btn.appendChild(glyph);
    btn.addEventListener('click', ()=>handleCellTap(btn, emo));
    gridEl.appendChild(btn);
  });

  // Timer
  timeLeft = ROUND_TIME;
  timeEl.textContent = timeLeft;
  timer = setInterval(()=>{
    timeLeft--;
    timeEl.textContent = Math.max(0, timeLeft);
    if (timeLeft <= 0){
      clearInterval(timer);
      locked = true;
      ping('‚è≥ Time up!', 'info');
      showBetweenAndAdvance();
    }
  }, 1000);
}

function handleCellTap(el, emo){
  if (locked || el.classList.contains('hit')) return;

  el.classList.add('hit');
  const right = (emo === targetEmoji);
  if (right){
    score += CORRECT_POINTS;
    correctSquares++;
    scoreEl.textContent = score;
    flashRight(el);
    confettiBurst(el);
    playTone('ok');
    ping(`‚úÖ +${CORRECT_POINTS}`, 'success');

    roundCorrectHit++;
    if (roundCorrectHit >= roundCorrectTotal) {
      // üéâ all correct emojis tapped ‚Äî grant Speed Bonus and finish early
      clearInterval(timer);
      locked = true;

      const rawBonus   = Math.max(0, timeLeft) * SPEED_BONUS_PER_SECOND;
      const bonus      = Math.min(rawBonus, SPEED_BONUS_CAP);
      score += bonus;
      scoreEl.textContent = score;

      ping(`‚ö° Speed Bonus! +${bonus}`, 'success');
      setTimeout(()=>{ showBetweenAndAdvance(); }, 650);
      return;
    }
  } else {
    score -= WRONG_POINTS;
    scoreEl.textContent = score;
    incorrectSquares++;
    flashWrong(el);
    playTone('bad');
    ping(`‚ùå ‚àí${WRONG_POINTS}`, 'error');
  }
}

/* ===== Helpers ===== */
function showBetweenAndAdvance(){
  betweenText.textContent = currentCorrectText || "(not available)";
  betweenOverlay.classList.add('show');

  let left = BETWEEN_SECONDS;
  betweenCountdown.textContent = `(next question in ${left}s)`;
  if (betweenTimer) { clearInterval(betweenTimer); betweenTimer = null; }
  betweenTimer = setInterval(()=>{
    left--;
    betweenCountdown.textContent = `(next question in ${Math.max(0,left)}s)`;
    if (left <= 0){
      clearInterval(betweenTimer);
      betweenTimer = null;
      betweenOverlay.classList.remove('show');
      idx++;
      if (idx >= QUESTIONS.length) endGame(); else nextQuestion();
    }
  }, 1000);
}

function updateGridOffset(){
  const h = qaWrap.offsetHeight || 0;
  screen.style.setProperty('--qaH', h + 'px');
}

function buildTokenBag(total, palette){
  // Distribute tokens (emojis) as evenly as possible
  const base = Math.floor(total / palette.length);
  let remainder = total % palette.length;
  const bag = [];
  palette.forEach(tok=>{
    const count = base + (remainder > 0 ? 1 : 0);
    for (let i=0;i<count;i++) bag.push(tok);
    remainder--;
  });
  return bag;
}
function shuffleInPlace(arr){
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function flashRight(el){
  el.classList.add('rightNow');
  setTimeout(()=> el.classList.remove('rightNow'), 220);
}
function flashWrong(el){
  el.classList.add('wrongNow');
  setTimeout(()=> el.classList.remove('wrongNow'), 220);
}

function ping(msg, kind='info'){
  toast.textContent = msg;
  toast.className = 'toast ' + (kind || 'info');
  void toast.offsetWidth;
  toast.classList.add('show');
  setTimeout(()=> toast.classList.remove('show'), 850);
}

function endGame(){
  qaWrap.style.display = 'none';
  finalEl.innerHTML = `
    <div class="finalStats">
      <div class="statBadge score">üèÜ Score: ${score}</div>
      <div class="statBadge correct">‚úÖ Correct taps: ${correctSquares}</div>
      <div class="statBadge correct" style="background:#ef4444">‚ùå Incorrect taps: ${incorrectSquares}</div>
    </div>
  `;
  overOverlay.classList.add('show');
}

/* Tiny confetti */
function confettiBurst(el){
  const rect = el.getBoundingClientRect();
  const cx = rect.left + rect.width/2;
  const cy = rect.top + rect.height/2;
  const pieces = ['üéâ','‚ú®','‚≠êÔ∏è','üéä'];
  for (let i=0;i<4;i++){
    const s = document.createElement('div');
    s.className = 'confetti';
    s.textContent = pieces[Math.floor(Math.random()*pieces.length)];
    s.style.left = (cx + (Math.random()*60 - 30)) + 'px';
    s.style.top  = (cy + (Math.random()*16 - 8)) + 'px';
    document.body.appendChild(s);
    s.addEventListener('animationend', ()=> s.remove(), { once:true });
  }
}

/* ---- Beeps with Web Audio (no files) ---- */
function playTone(type='ok'){
  const AC = window.AudioContext || window.webkitAudioContext;
  if (!AC) return;
  playTone.ctx = playTone.ctx || new AC();
  const ctx = playTone.ctx;

  if (type === 'ok') {
    const pops = ['short', 'soft', 'plucky'];
    const choice = pops[Math.floor(Math.random() * pops.length)];
    if (choice === 'short') return pop({type:'sine', f0:900, f1:650, dur:0.09, gain:0.8});
    if (choice === 'soft')  return pop({type:'triangle', f0:520, f1:320, dur:0.12, gain:0.7, lowpass:1200});
    if (choice === 'plucky')return pop({type:'sine', f0:500, f1:950, dur:0.10, gain:0.7});
  }
  if (type === 'bad'){ return tone({type:'sawtooth', f:220, dur:0.18, g:0.28}); }

  return tone({type:'sine', f:880, dur:0.14, g:0.28});

  function tone({type='sine', f=880, dur=0.14, g=0.28}){
    const o = ctx.createOscillator();
    const V = ctx.createGain();
    o.type = type; o.frequency.value = f;
    V.gain.setValueAtTime(0.0001, ctx.currentTime);
    V.gain.exponentialRampToValueAtTime(g, ctx.currentTime+0.01);
    V.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+dur);
    o.connect(V); V.connect(ctx.destination);
    o.start(); o.stop(ctx.currentTime + dur + 0.02);
  }
  function pop({type='sine', f0=900, f1=600, dur=0.1, gain=0.8, lowpass=null}={}){
    const o = ctx.createOscillator();
    const V = ctx.createGain();
    let out = V;
    o.type = type;
    o.frequency.setValueAtTime(f0, ctx.currentTime);
    o.frequency.exponentialRampToValueAtTime(Math.max(40,f1), ctx.currentTime + dur*0.85);
    V.gain.setValueAtTime(0.0001, ctx.currentTime);
    V.gain.exponentialRampToValueAtTime(gain, ctx.currentTime + 0.008);
    V.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + dur);
    if (lowpass){
      const lp = ctx.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.setValueAtTime(lowpass, ctx.currentTime);
      V.connect(lp); out = lp;
    }
    o.connect(V); out.connect(ctx.destination);
    o.start(); o.stop(ctx.currentTime + dur + 0.02);
  }
}

/* Create/resume + iOS unlock */
function ensureAudioReady(){
  const AC = window.AudioContext || window.webkitAudioContext;
  if (!AC) return;
  playTone.ctx = playTone.ctx || new AC();
  const ctx = playTone.ctx;
  if (ctx.state === 'suspended') ctx.resume();
  if (!ensureAudioReady.unlocked){
    try{
      const buffer = ctx.createBuffer(1, 1, 22050);
      const src = ctx.createBufferSource();
      src.buffer = buffer; src.connect(ctx.destination); src.start(0);
      ensureAudioReady.unlocked = true;
    }catch(e){}
  }
}
</script>
</body>
</html>
