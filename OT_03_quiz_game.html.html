<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Emoji Hunt Quiz</title>
<style>
:root{
  --qaH: 120px;  /* JS keeps this synced with the height of the QA block */
  --bg:#fafafa; --ink:#222; --panel:#ffffff;
  --good:#16a34a; --bad:#dc2626; --muted:#f1f1f1;
}

html,body{height:100%}
body{
  margin:0; background:var(--bg); color:var(--ink);
  font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
  display:flex; justify-content:center;
}
.game{
  width:100%;
  max-width:1000px;          /* optional upper limit */
  height:100vh;              /* fallback */
  height:100dvh;             /* dynamic viewport height */
  display:flex;
  flex-direction:column;
}


header{

  display:flex; gap:12px; align-items:center; justify-content:space-between;
  padding:12px 16px; background:var(--panel); box-shadow:0 2px 10px rgba(0,0,0,.06);
  position:sticky; top:0; z-index:10;
}

/* === Compact header for small screens === */
@media (max-width: 420px){
  header{
    padding:8px 10px;                 /* smaller padding */
  }
  .hud{
    gap:8px;
    flex-wrap:nowrap;                  /* keep it on one line */
  }
  .pill{
    padding:4px 8px;                   /* smaller chips */
    font-size:12px;                    /* smaller text */
    line-height:1;                     /* tighter */
    border-radius:999px;
    white-space:nowrap;                /* prevent wrapping inside the chip */
  }
}

/* Extra-tight for very narrow phones (e.g., iPhone mini) */
@media (max-width: 360px){
  header{
    padding:6px 8px;
  }
  .hud{ gap:6px; }
  .pill{
    padding:3px 6px;
    font-size:11px;
  }
}


.hud{display:flex; gap:16px; align-items:center; flex-wrap:wrap}
.pill{background:var(--muted); padding:6px 10px; border-radius:999px; font-weight:700}
.screen{ flex:1; position:relative; overflow:hidden; border-top:1px solid #eee;
         background: linear-gradient(#ffffff, #f6f8ff); }

/* Question & answers row */
.qa{
  position:absolute; left:50%; transform:translateX(-50%);
  top:10px; z-index:2; width:min(940px, 96%);
  display:flex; flex-direction:column; gap:10px;
  align-items:center;
}
.question{
  background:#333;                 /* dark gray background */
  color:#fff;                      /* white text */
  padding:14px 18px;
  border-radius:12px;
  box-shadow:0 2px 10px rgba(0,0,0,.3);
  font-size:clamp(16px,2.4vh,22px);
  text-align:center;
  line-height:1.25;
}

.answers{
  display:grid;
  grid-template-columns:repeat(2, minmax(0,1fr));  /* 2 columns instead of 4 */
  gap:12px 14px;                                  /* extra vertical spacing */
  width:100%;
  max-width:640px;                                /* keeps it tidy on large screens */
  margin:auto;
}

/* Spacers between question, answers, and grid */
.spacer{
  width:100%;
  height:clamp(6px, 1.5vh, 18px);
}
.spacer-top{ height:clamp(10px, 2vh, 24px); }
.spacer-bottom{ height:clamp(14px, 3vh, 32px); }



/* === Emoji left, text right (single line) === */
.ans{
  display:flex;
  flex-direction:row;         /* horizontal layout */
  align-items:center;
  justify-content:flex-start;
  text-align:left;
  gap:10px;
  padding:10px 12px;
}

.ans .emoji{
  font-size:1.6em;            /* a bit smaller than the stacked version */
  line-height:1;
  flex:0 0 auto;              /* don't stretch */
}

.ans .txt{
  font-weight:700;
  font-size:clamp(14px,1.8vw,18px);
  line-height:1.2;
  flex:1 1 auto;              /* allow the text to wrap nicely */
}



/* soft colored borders for variety (not gameplay) */
.c0{ border-color:#ffb3b3; background:#fff8f8; }
.c1{ border-color:#ffd166; background:#fff9ea; }
.c2{ border-color:#9be29b; background:#f4fff4; }
.c3{ border-color:#a7c4ff; background:#f4f7ff; }

/* Grid */
.gridWrap{
  position:absolute;
  inset:0;
  display:flex;
  justify-content:center;   /* keeps it centered vertically if needed */
  align-items:center;       /* <-- center the grid horizontally */
  padding:12px 16px;
  padding-top: calc(var(--qaH, 0px) + 12px); /* pushes grid below QA */
  box-sizing:border-box;
  flex-direction:column;
}



.grid{
  display:grid;
  grid-template-columns:repeat(6, 1fr);
  gap:6px;
    width: min(98%, var(--gridH, 900px));


  aspect-ratio:1 / 1;            /* keeps it square */
  margin:auto;
  flex-shrink:1;
}

@media (max-height:700px){
  .answers{ gap:10px; }
  .ans{ padding:8px 10px; }
  .ans .emoji{ font-size:1.4em; }
  .ans .txt{ font-size:clamp(12px,3.4vw,15px); line-height:1.15; }

  .spacer-top{ height:10px; }
  .spacer-bottom{ height:12px; }

  .grid{ gap:4px; }  /* packs the 6 rows a bit tighter */
}



.cell{
  /* square emoji tile */
  display:grid; place-items:center;
  border-radius:12px; height:0; padding-bottom:100%;
  position:relative; cursor:pointer;
  transition: transform 120ms ease, opacity 120ms ease, box-shadow 120ms ease;
  touch-action: manipulation; -webkit-tap-highlight-color: transparent;
  background:#ffffff; box-shadow:0 2px 8px rgba(0,0,0,.06);
  border:2px solid rgba(0,0,0,.06);
}
.cell .g{
  /* the emoji glyph itself */
  position:absolute; inset:0; display:grid; place-items:center;
    font-size: clamp(22px, 5vh, 42px);
 line-height:1;
}
.cell:active{ transform: scale(.96) }
.cell.hit{ opacity:.35; cursor:default; filter:saturate(.6) }
.cell.rightNow{ box-shadow:0 0 0 6px rgba(22,163,74,.22), 0 6px 18px rgba(0,0,0,.10) }
.cell.wrongNow{ box-shadow:0 0 0 6px rgba(220,38,38,.22), 0 6px 18px rgba(0,0,0,.10) }

/* Toast (center badge) */
.toast{
  position:absolute; left:50%; top:50%;
  transform: translate(-50%,-50%) scale(.92);
  background:#111; color:#fff; padding:14px 18px; border-radius:16px;
  font-weight:900; font-size:clamp(18px, 3.2vw, 32px); line-height:1.1;
  box-shadow:0 10px 30px rgba(0,0,0,.25); opacity:0; pointer-events:none;
  transition: opacity .18s ease, transform .18s ease; z-index:5;
}
.toast.show{ opacity:1; transform: translate(-50%,-50%) scale(1) }
.toast.success{ background:var(--good) }
.toast.error{ background:var(--bad) }
.toast.info{ background:#111 }

/* Overlays */
.overlay{
  position:absolute; inset:0; display:none; place-items:center; text-align:center;
  padding:24px; z-index:20; background:#fff;
}
.overlay.show{display:grid}
.stack{display:flex; flex-direction:column; gap:14px; align-items:center}
.btn{ border:none; background:#111; color:#fff; padding:12px 16px; border-radius:12px; font-weight:800; cursor:pointer}
.btn.secondary{background:#444}
.small{opacity:.75; font-size:14px}

/* Final stats / badge style */
.finalStats{ display:flex; flex-direction:column; gap:12px; align-items:center; margin-top:4px; }
@keyframes popIn{ 0%{ transform: translateY(6px) scale(.96); opacity:0 } 100%{ transform: translateY(0) scale(1); opacity:1 } }
.statBadge{
  display:inline-flex; align-items:center; gap:8px;
  padding:12px 16px; border-radius:16px; font-weight:900; font-size:clamp(18px,3.2vw,28px); line-height:1.1; color:#fff;
  box-shadow:0 10px 30px rgba(0,0,0,.22); animation: popIn 260ms ease-out both;
}
.statBadge.score   { background:#16a34a } /* green */
.statBadge.correct { background:#2563eb; animation-delay:.08s } /* blue */

/* Purple Bonus button to match the badges */
#bonusBtn{
  background:#7e22ce;                 /* rich purple */
  color:#fff;
  border:none;
  border-radius:16px;
  font-weight:800;
  padding:12px 20px;
  font-size:clamp(18px,3vw,24px);
  box-shadow:0 10px 30px rgba(0,0,0,.22);
  transition:transform .1s ease;
}
#bonusBtn:hover{ transform:scale(1.05); }


/* === Bonus slot machine === */
.bonusWrap{ display:grid; gap:14px; place-items:center; }
.reels{
  display:grid; grid-template-columns: repeat(3, 1fr);
  gap:12px; width:min(420px, 92vw);
}
.reel{
  background:#fff; color:#111; border:2px solid #ddd;
  border-radius:16px; box-shadow:0 6px 18px rgba(0,0,0,.10);
  cursor:pointer; padding:16px; height:100px;
  display:grid; place-items:center;
  font-size: clamp(28px, 8vw, 48px);
  user-select:none; -webkit-tap-highlight-color: transparent;
  transition: transform 120ms ease, box-shadow 120ms ease, border-color 120ms ease;
}
.reel:active{ transform: scale(.96) }
.reel.spinning{ border-color:#a0c4ff; box-shadow:0 0 0 6px rgba(37,99,235,.18), 0 6px 18px rgba(0,0,0,.10) }
.reel.stopped{ border-color:#9be29b; box-shadow:0 0 0 6px rgba(22,163,74,.18), 0 6px 18px rgba(0,0,0,.10) }
.bonusMsg{ font-weight:800; font-size:clamp(16px, 2.6vw, 20px); }


/* Between-screen answer card */
.betweenAnswer{
  font-size: clamp(18px, 2.6vw, 28px);
  font-weight: 800;
  background: #fff;
  color: #111;
  padding: 12px 16px;
  border-radius: 14px;
  box-shadow: 0 6px 18px rgba(0,0,0,.10);
  max-width: 720px;
}

/* Tiny confetti */
.confetti{
  position:absolute; pointer-events:none; z-index:30; font-size:18px; opacity:0;
  transform: translate(-50%,-50%) scale(.8); animation: confettiPop 600ms ease-out forwards;
}
@keyframes confettiPop{
  0% { opacity:0; transform: translate(-50%,-50%) scale(.8) }
  25%{ opacity:1; transform: translate(-50%,-90%) scale(1) }
  100%{ opacity:0; transform: translate(-50%,-140%) scale(1.1) }
}


/* === Tablet scaling === */
@media (min-width: 600px) and (max-width: 1024px) {
  html { font-size: 18px; }        /* slightly larger base font */
  .question { font-size: clamp(18px, 2.6vh, 24px); }
  .cell .g  { font-size: clamp(24px, 5.5vh, 46px); }
}


</style>
</head>
<body>
  <div class="game" id="game">
    <header>
      <div class="hud">
        <span class="pill" id="progress">Q 1 / 1</span>
        <span class="pill">Score: <span id="score">0</span></span>
        <span class="pill">Time: <span id="time">0</span>s</span>
      </div>
    </header>

    <main class="screen" id="screen" aria-live="polite">
      <!-- Question / Answers -->
<div class="qa" id="qa" style="display:none">
  <div class="question" id="question">Loading…</div>
  <div class="spacer spacer-top"></div>
  <div class="answers" id="answers"></div>
  <div class="spacer spacer-bottom"></div>
</div>


      <!-- Grid -->
      <div class="gridWrap">
        <div class="grid" id="grid" aria-label="emoji grid"></div>
      </div>

      <!-- Toast -->
      <div class="toast" id="toast" role="status" aria-live="assertive"></div>

      <!-- Start -->
<!-- Portrait Info Screen -->
<section class="overlay show" id="portraitNotice">
  <div class="stack">
    <div style="font-size:42px">📱 Best in Vertical Mode</div>
    <div class="small" style="max-width:600px">
      This game works best in <b>vertical (portrait)</b> mode.
    </div>
    <button class="btn" id="portraitOkBtn">OK</button>
  </div>
</section>

<!-- Title / Start Screen -->
<section class="overlay" id="start">

        <div class="stack">
          <div style="font-size:42px">😀 Emoji Hunt Quiz</div>
          <div class="small">Tap the emojis that match the <b>correct answer’s emoji</b> before time runs out.</div>
          <div class="small">30 seconds per question • Mouse or touch</div>
          <div style="display:flex; gap:10px">
            <button class="btn" id="startBtn">Start</button>
            <button class="btn secondary" id="howBtn">How to Play</button>
          </div>
        </div>
      </section>

      <!-- How-to -->
      <section class="overlay" id="how">
        <div class="stack">
          <div style="font-size:36px">📚 How to Play</div>
          <div style="max-width:640px">
            A Bible question appears with four answers. Each answer has its own emoji.<br/>
            For 30 seconds, tap as many grid squares as you can that match the emoji of the <b>correct</b> answer.<br/>
            Correct tap: +3 points • Wrong tap: −1 point • Clear early = ⚡ Speed Bonus
          </div>
          <button class="btn" id="backBtn">Back</button>
        </div>
      </section>

      <!-- Between-rounds -->
      <section class="overlay" id="between">
        <div class="stack">
          <div class="statBadge correct" role="status" aria-live="polite">✅ Correct Answer</div>
          <div id="betweenText" class="betweenAnswer"></div>
          <div class="small" id="betweenCountdown">(next question in 5s)</div>
        </div>
      </section>

<!-- Bonus Slot Machine -->
<section class="overlay" id="bonus">
  <div class="stack">
    <div style="font-size:34px">🎰 Bonus Round</div>
    <div class="small">Tap each reel to stop it. Match 3 = <b>x2 score</b>!</div>

    <div class="bonusWrap">
      <div class="reels">
        <button class="reel" id="reel0" aria-label="reel 1">🍎</button>
        <button class="reel" id="reel1" aria-label="reel 2">⭐️</button>
        <button class="reel" id="reel2" aria-label="reel 3">🎈</button>
      </div>
      <div class="bonusMsg" id="bonusMsg">Tap a reel to stop it…</div>
    </div>

    <div style="display:flex; gap:10px">
      <button class="btn secondary" id="bonusSkip">Skip</button>
      <button class="btn" id="bonusBack" style="display:none">Back to Results</button>
    </div>
  </div>
</section>


      <!-- Game over -->
      <section class="overlay" id="over">
        <div class="stack">
          <div style="font-size:34px">🏁 Game Over</div>
          <div id="final"></div>
          <button class="btn" id="bonusBtn">Bonus Round 🎰</button>

          <button class="btn" id="againBtn">Play Again</button>
        </div>
      </section>
    </main>
  </div>

<script>
/* ===== QUESTIONS (now with emojis per choice) =====
   Note: We keep isCorrect:true and add an emoji per choice.
   The grid for each round will be filled with these four emojis.
*/

// ===== START OF QUESTIONS =====
const QUESTIONS = [
  {
    q: "What would happen if Adam & Eve ate the fruit?",
    choices: [
      { text: "They'd die", isCorrect:true, emoji:"💀" },
      { text: "They'd turn into angels", emoji:"😇" },
      { text: "They'd live forever", emoji:"♾️" },
      { text: "They'd sleep for a week", emoji:"😴" }
    ]
  },
  {
    q: "Who was the serpent that came to Eve?",
    choices: [
      { text: "The devil", isCorrect:true, emoji:"🐍" },
      { text: "Just a snake", emoji:"🪱" },
      { text: "An angel", emoji:"👼" },
      { text: "Adam's pet", emoji:"🐶" }
    ]
  },
  {
    q: "What did the serpent tell Eve?",
    choices: [
      { text: "You won't die; you'll be like God", isCorrect:true, emoji:"🗣️" },
      { text: "Don't touch the fruit", emoji:"✋" },
      { text: "God doesn't love you", emoji:"💔" },
      { text: "Run from Adam", emoji:"🏃‍♀️" }
    ]
  },
  {
    q: "After talking to the serpent, what did Eve do?",
    choices: [
      { text: "Ate it and gave some to Adam", isCorrect:true, emoji:"🍎" },
      { text: "Told God right away", emoji:"🙏" },
      { text: "Threw the fruit away", emoji:"🗑️" },
      { text: "Named the serpent", emoji:"🏷️" }
    ]
  },
  {
    q: "After eating, what did Adam and Eve realize?",
    choices: [
      { text: "They were naked, so they hid", isCorrect:true, emoji:"🙈" },
      { text: "They could fly", emoji:"🪽" },
      { text: "They were angels", emoji:"😇" },
      { text: "They forgot their names", emoji:"❓" }
    ]
  },
  {
    q: "What curse did God give the serpent?",
    choices: [
      { text: "Crawl; crushed by Eve's Son", isCorrect:true, emoji:"🐍" },
      { text: "Lose its voice", emoji:"🤐" },
      { text: "Turn to dust", emoji:"🧱" },
      { text: "Live in the ocean", emoji:"🌊" }
    ]
  },
  {
    q: "What curse did God give the woman?",
    choices: [
      { text: "Pain in childbirth; conflict", isCorrect:true, emoji:"👶" },
      { text: "Grow thorns", emoji:"🌵" },
      { text: "Lose her voice", emoji:"🤐" },
      { text: "Never sleep", emoji:"🫠" }
    ]
  },
  {
    q: "What curse did God give the man?",
    choices: [
      { text: "Hard work and death", isCorrect:true, emoji:"🧑‍🌾" },
      { text: "No more garden food", emoji:"🥦" },
      { text: "Forget Eve", emoji:"🧠" },
      { text: "Never rest", emoji:"⏰" }
    ]
  },
  {
    q: "After the curses, what did God do?",
    choices: [
      { text: "Clothed them; sent them out", isCorrect:true, emoji:"🧥" },
      { text: "Destroyed the garden", emoji:"🔥" },
      { text: "Made them build a city", emoji:"🏙️" },
      { text: "Told them to swim away", emoji:"🏊" }
    ]
  },
  {
    q: "Who is the Son of Eve who crushed the serpent?",
    choices: [
      { text: "Jesus—died and rose again", isCorrect:true, emoji:"✝️" },
      { text: "Moses", emoji:"📜" },
      { text: "Abraham", emoji:"🧔" },
      { text: "David", emoji:"🪕" }
    ]
  }
];
// ===== END OF QUESTIONS =====



/* ===== CONFIG ===== */
const GRID_SIZE = 6;          // 6 x 6 
const ROUND_TIME = 30;         // seconds per question
const CORRECT_POINTS = 3;
const WRONG_POINTS   = 1;      // deducted
const BETWEEN_SECONDS = 5;     // between-round display time

const SPEED_BONUS_PER_SECOND = 1;
const SPEED_BONUS_CAP = Infinity;

/* ===== STATE & ELEMENTS ===== */
// --- Bonus round state ---
const bonusOverlay = document.getElementById('bonus');
const bonusMsg     = document.getElementById('bonusMsg');
const bonusSkip    = document.getElementById('bonusSkip');
const bonusBack    = document.getElementById('bonusBack');
const reelEls      = [document.getElementById('reel0'), document.getElementById('reel1'), document.getElementById('reel2')];

const BONUS_EMOJIS = ['🍎','⭐️','💎','🍀','🔥','🎈'];
let reelTimers = [null,null,null];
let reelStopped = [false,false,false];
let reelValues  = ['','',''];
let bonusApplied = false;   // prevent applying x2 more than once



let idx = 0, score = 0, correctSquares = 0, timeLeft = 0, timer = null;
let incorrectSquares = 0;

let targetEmoji = ""; // emoji string for the correct answer this round
let locked = false;
let currentCorrectText = "";
let betweenTimer = null;

let roundCorrectTotal = 0;
let roundCorrectHit   = 0;

const screen    = document.getElementById('screen');
const qaWrap    = document.getElementById('qa');
const questionEl= document.getElementById('question');
const answersEl = document.getElementById('answers');
const gridEl    = document.getElementById('grid');
const toast     = document.getElementById('toast');

const betweenOverlay = document.getElementById('between');
const betweenText    = document.getElementById('betweenText');
const betweenCountdown = document.getElementById('betweenCountdown');

const startOverlay = document.getElementById('start');
const overOverlay  = document.getElementById('over');
const howOverlay   = document.getElementById('how');
const finalEl      = document.getElementById('final');

const progressEl = document.getElementById('progress');
const scoreEl    = document.getElementById('score');
const timeEl     = document.getElementById('time');

document.getElementById('startBtn').addEventListener('click', startGame);
window.addEventListener('resize', updateGridOffset);

// Portrait notice logic
const portraitNotice = document.getElementById('portraitNotice');
// startOverlay is already defined above — don't redeclare it here
const portraitOkBtn = document.getElementById('portraitOkBtn');


if (portraitOkBtn) {
  portraitOkBtn.addEventListener('click', () => {
    portraitNotice.classList.remove('show');  // hide first screen
    startOverlay.classList.add('show');       // reveal title screen
  });
}


document.getElementById('againBtn').addEventListener('click', startGame);

// Open bonus round from Game Over
const bonusBtn = document.getElementById('bonusBtn');
if (bonusBtn){
  bonusBtn.addEventListener('click', openBonus);
}

// Bonus controls
if (bonusSkip){ bonusSkip.addEventListener('click', () => {
  bonusOverlay.classList.remove('show');
  overOverlay.classList.add('show');
});}
if (bonusBack){ bonusBack.addEventListener('click', () => {
  bonusOverlay.classList.remove('show');
  overOverlay.classList.add('show');
});}

// Tap to stop each reel
reelEls.forEach((el, i) => {
  el.addEventListener('click', () => stopReel(i));
});


document.getElementById('howBtn').addEventListener('click', ()=>{ startOverlay.classList.remove('show'); howOverlay.classList.add('show'); });
document.getElementById('backBtn').addEventListener('click', ()=>{ howOverlay.classList.remove('show'); startOverlay.classList.add('show'); });


['startBtn','againBtn','howBtn','backBtn'].forEach(id=>{
  const el = document.getElementById(id);
  if (!el) return;
  el.addEventListener('pointerdown', ensureAudioReady, { once:true });
});

function startGame(){
  idx = 0; score = 0; correctSquares = 0; incorrectSquares = 0;
  scoreEl.textContent = score;
  startOverlay.classList.remove('show');
  overOverlay.classList.remove('show');
  howOverlay.classList.remove('show');
  qaWrap.style.display = 'block';
answersEl.innerHTML = "";
  updateGridOffset();
  nextQuestion();
}

function nextQuestion(){
  clearInterval(timer);
  gridEl.innerHTML = "";
  locked = false;

  if (idx >= QUESTIONS.length){ endGame(); return; }

  const item = QUESTIONS[idx];
  progressEl.textContent = `Q ${idx+1} / ${QUESTIONS.length}`;
  questionEl.textContent = item.q;

  // Build shuffled choices and assign soft color classes c0..c3 (for looks only)
  const choices = item.choices.map(c => ({ ...c })); // copy
  shuffleInPlace(choices);
  choices.forEach((c, i) => { c.skin = ['c0','c1','c2','c3'][i]; });

  // Render answers row with emoji + text
  answersEl.innerHTML = "";
  choices.forEach((c,i)=>{
    const div = document.createElement('div');
    div.className = `ans ${c.skin}`;
    div.innerHTML = `<div class="emoji">${c.emoji}</div><div class="txt">${c.text}</div>`;

    answersEl.appendChild(div);
  });
  updateGridOffset();

  // Determine target emoji from the correct choice
  const correctChoice = choices.find(c => c.isCorrect);
  targetEmoji = correctChoice ? (correctChoice.emoji || '') : '';
  currentCorrectText = (correctChoice ? `${correctChoice.emoji || ''} ${correctChoice.text}` : "");

  // Build an even-ish distribution of the 4 emojis for the grid
  const palette = choices.map(c => c.emoji || '❓');        // 4 emojis for this round
  const cells = buildTokenBag(GRID_SIZE*GRID_SIZE, palette);
  shuffleInPlace(cells);

  // Count how many cells match the target emoji
  roundCorrectTotal = cells.filter(e => e === targetEmoji).length;
  roundCorrectHit   = 0;

  // Render grid of emoji buttons
  cells.forEach(emo=>{
    const btn = document.createElement('button');
    btn.className = 'cell';
    btn.setAttribute('aria-label', `emoji ${emo}`);
    const glyph = document.createElement('div');
    glyph.className = 'g';
    glyph.textContent = emo;
    btn.appendChild(glyph);
    btn.addEventListener('click', ()=>handleCellTap(btn, emo));
    gridEl.appendChild(btn);
  });

  // Timer
  timeLeft = ROUND_TIME;
  timeEl.textContent = timeLeft;
  timer = setInterval(()=>{
    timeLeft--;
    timeEl.textContent = Math.max(0, timeLeft);
    if (timeLeft <= 0){
      clearInterval(timer);
      locked = true;
      ping('⏳ Time up!', 'info');
      showBetweenAndAdvance();
    }
  }, 1000);
}

function handleCellTap(el, emo){
  if (locked || el.classList.contains('hit')) return;

  el.classList.add('hit');
  const right = (emo === targetEmoji);
  if (right){
    score += CORRECT_POINTS;
    correctSquares++;
    scoreEl.textContent = score;
    flashRight(el);
    confettiBurst(el);
    playTone('ok');
    ping(`✅ +${CORRECT_POINTS}`, 'success');

    roundCorrectHit++;
    if (roundCorrectHit >= roundCorrectTotal) {
      // 🎉 all correct emojis tapped — grant Speed Bonus and finish early
      clearInterval(timer);
      locked = true;

      const rawBonus   = Math.max(0, timeLeft) * SPEED_BONUS_PER_SECOND;
      const bonus      = Math.min(rawBonus, SPEED_BONUS_CAP);
      score += bonus;
      scoreEl.textContent = score;

      ping(`⚡ Speed Bonus! +${bonus}`, 'success');
      setTimeout(()=>{ showBetweenAndAdvance(); }, 650);
      return;
    }
  } else {
    score -= WRONG_POINTS;
    scoreEl.textContent = score;
    incorrectSquares++;
    flashWrong(el);
    playTone('bad');
    ping(`❌ −${WRONG_POINTS}`, 'error');
  }
}


// --- Bonus round functions ---
function openBonus(){
  overOverlay.classList.remove('show');
  bonusOverlay.classList.add('show');
  bonusMsg.textContent = 'Tap each reel to stop it. Match 3 = x2 score!';
  bonusBack.style.display = 'none';
  bonusApplied = false;

  // reset state
  reelStopped = [false,false,false];
  reelValues  = ['','',''];

  // start spinning
  startReels();
}

function startReels(){
  reelEls.forEach((el, i) => {
    el.classList.add('spinning');
    if (reelTimers[i]) clearInterval(reelTimers[i]);
let idx = 0;  // index to step through emojis in order
reelTimers[i] = setInterval(() => {
  el.textContent = BONUS_EMOJIS[idx];
  idx = (idx + 1) % BONUS_EMOJIS.length;  // loop back to start
}, 180 + i*30);


  });
}

function stopReel(i){
  if (reelStopped[i]) return;
  reelStopped[i] = true;
  const el = reelEls[i];
  el.classList.remove('spinning');
  el.classList.add('stopped');

  clearInterval(reelTimers[i]);
  reelTimers[i] = null;
  reelValues[i] = el.textContent;

  if (reelStopped.every(Boolean)){
    finishBonus();
  }
}

function finishBonus(){
  const [a,b,c] = reelValues;
  if (a && a === b && b === c){
    // JACKPOT! x2 total score (once)
    if (!bonusApplied){
      bonusApplied = true;
      const before = score;
      score = score * 2;
      scoreEl.textContent = score;
      bonusMsg.textContent = `🎉 JACKPOT! ${a}${b}${c}  — Score doubled: ${before} → ${score}`;
    } else {
      bonusMsg.textContent = `🎉 JACKPOT! ${a}${b}${c}`;
    }
  } else {
    bonusMsg.textContent = `No match. Final score: ${score}`;
  }

  // allow returning to results
  bonusBack.style.display = 'inline-block';
  // refresh the results panel so numbers match
  updateFinalStats();
}

// Rebuild the Game Over stats so they reflect any bonus change
function updateFinalStats(){
  finalEl.innerHTML = `
    <div class="finalStats">
      <div class="statBadge score">🏆 Score: ${score}</div>
      <div class="statBadge correct">✅ Correct taps: ${correctSquares}</div>
      <div class="statBadge correct" style="background:#ef4444">❌ Incorrect taps: ${incorrectSquares}</div>
    </div>
  `;
}



/* ===== Helpers ===== */
function updateGridOffset(){
  // Where is the QA area, and how tall is it?
  const qaTop = qaWrap.offsetTop || 0;                 // includes the 8–10px "top:" offset
  const qaH   = qaWrap.offsetHeight || 0;
  const qaBottom = qaTop + qaH;

  // 1) Push the grid below the visible bottom of the QA area
  screen.style.setProperty('--qaH', `${qaBottom + 8}px`); // +8px breathing room

  // 2) Limit grid size to the remaining vertical space so all 6 rows fit
  const screenH = screen.clientHeight || window.innerHeight;
  const available = Math.max(200, screenH - (qaBottom + 20) - 20);
 // (qa + gap + grid padding)
  const gridPx = Math.min(available, 440); // clamp so it doesn’t get huge
  screen.style.setProperty('--gridH', `${gridPx}px`);
}





function showBetweenAndAdvance(){
  betweenText.textContent = currentCorrectText || "(not available)";
  betweenOverlay.classList.add('show');

  let left = BETWEEN_SECONDS;
  betweenCountdown.textContent = `(next question in ${left}s)`;
  if (betweenTimer) { clearInterval(betweenTimer); betweenTimer = null; }
  betweenTimer = setInterval(()=>{
    left--;
    betweenCountdown.textContent = `(next question in ${Math.max(0,left)}s)`;
    if (left <= 0){
      clearInterval(betweenTimer);
      betweenTimer = null;
      betweenOverlay.classList.remove('show');
      idx++;
      if (idx >= QUESTIONS.length) endGame(); else nextQuestion();
    }
  }, 1000);
}


function buildTokenBag(total, palette){
  // Distribute tokens (emojis) as evenly as possible
  const base = Math.floor(total / palette.length);
  let remainder = total % palette.length;
  const bag = [];
  palette.forEach(tok=>{
    const count = base + (remainder > 0 ? 1 : 0);
    for (let i=0;i<count;i++) bag.push(tok);
    remainder--;
  });
  return bag;
}
function shuffleInPlace(arr){
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function flashRight(el){
  el.classList.add('rightNow');
  setTimeout(()=> el.classList.remove('rightNow'), 220);
}
function flashWrong(el){
  el.classList.add('wrongNow');
  setTimeout(()=> el.classList.remove('wrongNow'), 220);
}

function ping(msg, kind='info'){
  toast.textContent = msg;
  toast.className = 'toast ' + (kind || 'info');
  void toast.offsetWidth;
  toast.classList.add('show');
  setTimeout(()=> toast.classList.remove('show'), 850);
}

function endGame(){
  qaWrap.style.display = 'none';
  updateFinalStats();             // build stats in one place
  overOverlay.classList.add('show');
}

/* Tiny confetti */
function confettiBurst(el){
  const rect = el.getBoundingClientRect();
  const cx = rect.left + rect.width/2;
  const cy = rect.top + rect.height/2;
  const pieces = ['🎉','✨','⭐️','🎊'];
  for (let i=0;i<4;i++){
    const s = document.createElement('div');
    s.className = 'confetti';
    s.textContent = pieces[Math.floor(Math.random()*pieces.length)];
    s.style.left = (cx + (Math.random()*60 - 30)) + 'px';
    s.style.top  = (cy + (Math.random()*16 - 8)) + 'px';
    document.body.appendChild(s);
    s.addEventListener('animationend', ()=> s.remove(), { once:true });
  }
}

/* ---- Beeps with Web Audio (no files) ---- */
function playTone(type='ok'){
  const AC = window.AudioContext || window.webkitAudioContext;
  if (!AC) return;
  playTone.ctx = playTone.ctx || new AC();
  const ctx = playTone.ctx;

  if (type === 'ok') {
    const pops = ['short', 'soft', 'plucky'];
    const choice = pops[Math.floor(Math.random() * pops.length)];
    if (choice === 'short') return pop({type:'sine', f0:900, f1:650, dur:0.09, gain:0.8});
    if (choice === 'soft')  return pop({type:'triangle', f0:520, f1:320, dur:0.12, gain:0.7, lowpass:1200});
    if (choice === 'plucky')return pop({type:'sine', f0:500, f1:950, dur:0.10, gain:0.7});
  }
  if (type === 'bad'){ return tone({type:'sawtooth', f:220, dur:0.18, g:0.28}); }

  return tone({type:'sine', f:880, dur:0.14, g:0.28});

  function tone({type='sine', f=880, dur=0.14, g=0.28}){
    const o = ctx.createOscillator();
    const V = ctx.createGain();
    o.type = type; o.frequency.value = f;
    V.gain.setValueAtTime(0.0001, ctx.currentTime);
    V.gain.exponentialRampToValueAtTime(g, ctx.currentTime+0.01);
    V.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+dur);
    o.connect(V); V.connect(ctx.destination);
    o.start(); o.stop(ctx.currentTime + dur + 0.02);
  }
  function pop({type='sine', f0=900, f1=600, dur=0.1, gain=0.8, lowpass=null}={}){
    const o = ctx.createOscillator();
    const V = ctx.createGain();
    let out = V;
    o.type = type;
    o.frequency.setValueAtTime(f0, ctx.currentTime);
    o.frequency.exponentialRampToValueAtTime(Math.max(40,f1), ctx.currentTime + dur*0.85);
    V.gain.setValueAtTime(0.0001, ctx.currentTime);
    V.gain.exponentialRampToValueAtTime(gain, ctx.currentTime + 0.008);
    V.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + dur);
    if (lowpass){
      const lp = ctx.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.setValueAtTime(lowpass, ctx.currentTime);
      V.connect(lp); out = lp;
    }
    o.connect(V); out.connect(ctx.destination);
    o.start(); o.stop(ctx.currentTime + dur + 0.02);
  }
}

/* Create/resume + iOS unlock */
function ensureAudioReady(){
  const AC = window.AudioContext || window.webkitAudioContext;
  if (!AC) return;
  playTone.ctx = playTone.ctx || new AC();
  const ctx = playTone.ctx;
  if (ctx.state === 'suspended') ctx.resume();
  if (!ensureAudioReady.unlocked){
    try{
      const buffer = ctx.createBuffer(1, 1, 22050);
      const src = ctx.createBufferSource();
      src.buffer = buffer; src.connect(ctx.destination); src.start(0);
      ensureAudioReady.unlocked = true;
    }catch(e){}
  }
}


// --- Secret debug key: press "G" to jump straight to Game Over ---
window.addEventListener('keydown', (e)=>{
  if(e.key.toLowerCase() === 'g'){
    clearInterval(timer);
    qaWrap.style.display = 'none';
    updateFinalStats();
    overOverlay.classList.add('show');
    console.log('💀 Secret shortcut: jumped to Game Over screen.');
  }
});


</script>
</body>
</html>

