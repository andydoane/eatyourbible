<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>God Creates People Quiz</title>
<style>

/* === Confetti (on correct) === */
.confetti{
  position:absolute;
  pointer-events:none;
  z-index:6;                  /* above toast (z:5) */
  font-size:16px;
  opacity:0;
  transform: translate(-50%, -50%) scale(.8);
  animation: confettiPop 600ms ease-out forwards;
}
@keyframes confettiPop{
  0%   { opacity:0; transform: translate(-50%,-50%) scale(.8) }
  25%  { opacity:1; transform: translate(-50%,-90%) scale(1) }
  100% { opacity:0; transform: translate(-50%,-140%) scale(1.1) }
}



  :root{
    --bg:#fafafa; --ink:#222; --panel:#ffffff; --accent:#4caf50; --wrong:#e53935;
  }
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--ink);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
    display:flex; justify-content:center;
  }
  .game{ width:min(900px,100vw); height:100dvh; display:flex; flex-direction:column; }
  header{
    display:flex; gap:12px; align-items:center; justify-content:space-between;
    padding:12px 16px; background:var(--panel); box-shadow:0 2px 10px rgba(0,0,0,.06);
    position:sticky; top:0; z-index:10;
  }
  .hud{display:flex; gap:16px; align-items:center; flex-wrap:wrap}
  .pill{background:#f1f1f1; padding:6px 10px; border-radius:999px; font-weight:600}
  .hearts{font-size:20px; letter-spacing:2px}
  .screen{ flex:1; position:relative; overflow:hidden; border-top:1px solid #eee;
           background:
  radial-gradient(180px 180px at 12% -6%, #fff8d1 0%, transparent 70%),
  linear-gradient(#ffffff, #f3f7ff);
 --lane-step: 20%;}
  .question{
    position:absolute; left:50%; transform:translateX(-50%);
    top:10px; background:var(--panel); padding:10px 14px; border-radius:12px;
    box-shadow:0 2px 10px rgba(0,0,0,.08); z-index:2; max-width:92%;
    font-size:clamp(16px,2.4vw,22px); text-align:center; line-height:1.25;
    display:none; /* hidden until Start */
  }

  .balloon:focus{outline:3px solid #cde7ff}

/* number-on-top layout */

.balloon .num{
  font-weight: 800;
  font-size: clamp(18px, 3.6vw, 28px);
  line-height: 1;
  margin-bottom: -2px;   /* tiny lift so it "floats" above the answer */
}
.balloon .row{
  display: inline-flex;
  align-items: center;
  gap: 8px;
}


/* color variants for the 4 answer options */
.balloon.c0{ background:#ffe8e8; border-color:#ffb3b3; }
.balloon.c1{ background:#fff1cc; border-color:#ffd166; }
.balloon.c2{ background:#e7f7e7; border-color:#9be29b; }
.balloon.c3{ background:#e6f0ff; border-color:#a7c4ff; }

/* make the big number match the color a bit */
.balloon.c0 .num{ color:#c62828; }
.balloon.c1 .num{ color:#b26a00; }
.balloon.c2 .num{ color:#1b5e20; }
.balloon.c3 .num{ color:#1a237e; }

/* ensure good contrast for text row */
.balloon.c0 .txt,
.balloon.c1 .txt,
.balloon.c2 .txt,
.balloon.c3 .txt { color:#111; }




/* Glow ring for instant feedback */
.balloon.correct{
  border-color:var(--accent);
  box-shadow:
    0 0 0 6px rgba(22,163,74,.22),
    0 6px 18px rgba(0,0,0,.10);
}
.balloon.wrong{
  border-color:var(--wrong);
  box-shadow:
    0 0 0 6px rgba(220,38,38,.22),
    0 6px 18px rgba(0,0,0,.10);
}
@keyframes floatUp{
  from { transform: translate(-50%, 0); }
  to   { transform: translate(-50%, -120vh); }
}

/* === Wrapped balloon layout (Option B) === */
/* The wrapper is what floats upward */
.balloonWrap{
  position:absolute;
  bottom:-160px;               /* ‚Üì start further off-screen so any snap is invisible (was -80px) */
  animation: floatUp linear forwards;
  animation-fill-mode: both;   /* ‚Üê keep the first/last keyframe applied */
  z-index:1;

  width: var(--lane-step);
  padding: 0 6px;

  transform: translate(-50%, 0); /* ‚Üê baseline centering so there‚Äôs no horizontal snap */
  will-change: transform;        /* (optional) smoother start */
}




/* The actual button is centered and allowed to size naturally */
.balloon{
  position: relative;          /* ‚Üê add this */
  animation: none;
  display: flex;
  flex-direction: column;
  align-items: center;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  gap: 6px;

  width: 100%;
max-width: 240px;
box-sizing: border-box; /* you already have this ‚Äî keep it */

  white-space: normal;

  padding: 8px 12px;
  border-radius: 16px;
  border: 2px solid #ddd;
  background: #fff;
  font-weight: 600;
  cursor: pointer;
  user-select: none;
  box-shadow: 0 4px 16px rgba(0,0,0,.08);
  text-align: center;
}

/* Gentle bobble so balloons feel alive */
@keyframes bobble {
  0%   { transform: translateX(-2px) rotate(-1.4deg); }
  50%  { transform: translateX( 2px) rotate( 1.4deg); }
  100% { transform: translateX(-2px) rotate(-1.4deg); }
}

@keyframes stringSway{
  0%   { transform: translateX(-50%) rotate(-2deg); }
  50%  { transform: translateX(-50%) rotate( 2deg); }
  100% { transform: translateX(-50%) rotate(-2deg); }
}



.balloon {
  /* keep your existing properties‚Ä¶ */
  /* You already have: animation: none; ‚Äî leave it above */
  animation: bobble 3.6s ease-in-out infinite; /* ‚Üê add this line at the end of .balloon */
}

/* String/tether under the balloon */
.balloon::before{
  content:"";
  position:absolute;
  left:50%;
  bottom:-28px;                 /* was -18px ‚Üí pushes the string lower */
  width:2px;
  height:30px;                  /* was 26px ‚Üí keep the length */
  transform: translateX(-50%);  /* keep it centered */

  background: linear-gradient(#e5e5e5,#cfcfcf);
  border-radius:2px;
  opacity:.75;
  pointer-events:none;

  transform-origin: top center;
  animation: stringSway 3.6s ease-in-out infinite;
}

.balloon.pop::before{ opacity:0; }






.balloon .txt{
  font-size: clamp(14px, 2.4vw, 18px);
  line-height: 1.2;
  text-align: center;

  /* NEW: only break long words when necessary, not between letters */
  overflow-wrap: break-word;
  word-break: normal;
  hyphens: auto;
}



/* === Pop effect === */
.balloon.pop{
  animation: popBurst 280ms ease-out forwards !important; /* override float */
  border-color: transparent;
  background: transparent;
}
.balloon.pop > *{ opacity:0 } /* hide text while popping */
.balloon.pop::after{
  content: attr(data-icon); /* üéâ or üí• */
  position:absolute; left:50%; top:50%;
  transform: translate(-50%,-50%) scale(1);
  font-size:28px;
  pointer-events:none;
}
@keyframes popBurst{
  0%   { transform: scale(1); opacity:1 }
  40%  { transform: scale(1.18) }
  100% { transform: scale(0.2); opacity:0 }
}


/* Big center badge */
.toast{
  position:absolute;
  left:50%; top:50%;
  transform: translate(-50%,-50%) scale(.92);
  background:#111;
  color:#fff;
  padding:14px 18px;
  border-radius:16px;
  font-weight:800;
  font-size: clamp(18px, 3.2vw, 32px);
  line-height:1.1;
  box-shadow:0 10px 30px rgba(0,0,0,.25);
  opacity:0;
  pointer-events:none;
  transition: opacity .18s ease, transform .18s ease;
  z-index: 5;
}
.toast.show{
  opacity:1;
  transform: translate(-50%,-50%) scale(1);
}

/* Color variants */
.toast.success{
  background: #16a34a;            /* green 600 */
}
.toast.error{
  background: #dc2626;             /* red 600 */
}
.toast.info{
  background: #111;
}


@keyframes heartOuch{
  0%   { transform: scale(1);   filter:none; }
  35%  { transform: scale(1.18); filter: drop-shadow(0 0 6px rgba(220,38,38,.45)); }
  100% { transform: scale(1);   filter:none; }
}
.hearts.hurt{ animation: heartOuch 320ms ease; }



/* === Flying bonus emoji === */
.bonus{
  position:absolute;
  z-index:4;                /* above balloons, below overlays */
  font-size: clamp(34px, 6vw, 60px);  /* ‚Üê bigger & responsive */
  line-height:1;
  user-select:none;
  cursor:pointer;
  transition: left 900ms linear, top 900ms linear, transform 200ms ease, opacity 200ms ease;
  will-change: left, top, transform, opacity;
  text-shadow: 0 1px 0 #fff, 0 0 6px rgba(0,0,0,.25); /* readability */
}
.bonus:active{ transform: scale(.9) }
.bonus.hide{ opacity:0; transform: scale(.6) }


  /* Overlays (start/how/over) ‚Äî sit above everything in the playfield */
  .overlay{
    position:absolute; inset:0; display:none; place-items:center; text-align:center;
    padding:24px; z-index:20;   background:#fff; /* or rgba(255,255,255,.98) */;
  }
  .overlay.show{display:grid}
  .stack{display:flex; flex-direction:column; gap:14px; align-items:center}
  .btn{ border:none; background:#111; color:#fff; padding:12px 16px; border-radius:12px; font-weight:700; cursor:pointer}
  .btn.secondary{background:#444}
  .small{opacity:.75; font-size:14px}
</style>
</head>
<body>
  <div class="game" id="game">
    <header>
      <div class="hud">
        <span class="pill" id="progress">Q 1 / 1</span>
        <span class="pill">Score: <span id="score">0</span></span>
        <span class="pill">Time: <span id="time">0</span>s</span>
      </div>
      <div class="hearts" id="hearts" aria-label="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
    </header>

    <main class="screen" id="screen" aria-live="polite">
      <div class="question" id="question">Loading‚Ä¶</div>
      <div class="toast" id="toast" role="status" aria-live="assertive"></div>

      <!-- Start -->
      <section class="overlay show" id="start">
        <div class="stack">
          <div style="font-size:42px">üéà Balloon Pop Quiz</div>
          <div class="small">Pop the correct answer balloon before it floats away!</div>
          <div class="small">Keyboard: 1‚Äì4 ‚Ä¢ Mobile: tap</div>
          <div style="display:flex; gap:10px">
            <button class="btn" id="startBtn">Start</button>
            <button class="btn secondary" id="howBtn">How to Play</button>
          </div>
        </div>
      </section>

      <!-- How-to -->
      <section class="overlay" id="how">
        <div class="stack">
          <div style="font-size:36px">üìö How to Play</div>
          <div style="max-width:600px">
            Balloons float up with answer choices.<br/>
            Tap or click the correct one to score. Wrong pops cost a heart.
          </div>
          <button class="btn" id="backBtn">Back</button>
        </div>
      </section>

      <!-- Game over -->
      <section class="overlay" id="over">
        <div class="stack">
          <div style="font-size:34px">üèÅ Game Over</div>
          <div id="final"></div>
          <button class="btn" id="againBtn">Play Again</button>
        </div>
      </section>
    </main>
  </div>

<script>



/* ===== QUESTIONS START HERE ===== */
const QUESTIONS = [
  {
    q: "How did God create the first man?",
    choices: [
      "Formed from dust; God breathed life",
      "From water and clay",
      "Spoken into being only",
      "Formed from stars"
    ],
    correct: 0,
    emoji: "üå¨Ô∏è"
  },
  {
    q: "Where did God put the man? What job did He give him?",
    choices: [
      "Garden of Eden; take care of it",
      "City of Enoch; build it",
      "Wilderness; hunt for food",
      "Ark; feed the animals"
    ],
    correct: 0,
    emoji: "üåø"
  },
  {
    q: "What did God say was ‚Äúnot good‚Äù?",
    choices: [
      "For the man to be alone",
      "Working on the Sabbath",
      "Eating any fruit",
      "Naming the animals"
    ],
    correct: 0,
    emoji: "üôÖ"
  },
  {
    q: "What did God say He would make for the man?",
    choices: [
      "A helper suitable for him",
      "A great city",
      "A sword to protect the garden",
      "A temple to worship in"
    ],
    correct: 0,
    emoji: "ü§ù"
  },
  {
    q: "When God brought the animals to the man, what did he do?",
    choices: [
      "Named them",
      "Built an altar",
      "Counted them",
      "Set them free"
    ],
    correct: 0,
    emoji: "üêæ"
  },
  {
    q: "After naming all the animals, what did the man not find?",
    choices: [
      "A helper suitable for him",
      "Enough food",
      "A place to sleep",
      "A pet dog"
    ],
    correct: 0,
    emoji: "üïµÔ∏è"
  },
  {
    q: "How did God make a helper for the man?",
    choices: [
      "Put him to sleep, took a rib, formed a woman",
      "Shaped another from dust",
      "Spoke her into being only",
      "Made her from the animals"
    ],
    correct: 0,
    emoji: "ü¶¥"
  },
  {
    q: "When God brought the woman to the man, what did he say?",
    choices: [
      "Bone of my bones and flesh of my flesh",
      "At last, a friend for me",
      "You shall be called Eve",
      "Welcome, my sister"
    ],
    correct: 0,
    emoji: "üí¨"
  },
  {
    q: "Both the man and the woman were made in God‚Äôs‚Ä¶ what?",
    choices: [
      "Image and likeness",
      "Temple",
      "Garden",
      "Spirit only"
    ],
    correct: 0,
    emoji: "ü™û"
  },
  {
    q: "What did God tell the man and woman to do?",
    choices: [
      "Be fruitful, fill the earth, and rule over it",
      "Build a tower",
      "Stay in the garden forever",
      "Wander the earth"
    ],
    correct: 0,
    emoji: "üåç"
  }
];



/* ===== QUESTIONS END HERE ===== */



/* ===== 2) CONFIG ===== */
const START_LIVES = 3;
const BALLOON_TRAVEL_MS = 20000;
// timer = travel time + max random duration (+800ms) + max start delay (+600ms) + 1s grace
const PER_QUESTION_TIME = Math.ceil((BALLOON_TRAVEL_MS + 800 + 600) / 1000) + 1;
const COLUMNS = 4;
const BONUS_POINTS = 10; // ‚Üê set your bonus amount here


/* ===== 3) STATE & ELEMENTS ===== */
let idx = 0, score = 0, correctCount = 0, lives = START_LIVES, timer = null, timeLeft = 0, lock = false;
let bonusEl = null, bonusTimer = null, bonusPending = 0;
let activeBalloons = [];
const screen = document.getElementById('screen');
const questionEl = document.getElementById('question');
const progressEl = document.getElementById('progress');
const scoreEl = document.getElementById('score');
const timeEl = document.getElementById('time');
const heartsEl = document.getElementById('hearts');
const toast = document.getElementById('toast');

const startOverlay = document.getElementById('start');
const overOverlay  = document.getElementById('over');
const howOverlay   = document.getElementById('how');
const finalEl      = document.getElementById('final');

document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('againBtn').addEventListener('click', startGame);
document.getElementById('howBtn').addEventListener('click', ()=>{
  startOverlay.classList.remove('show');   // hide Start
  howOverlay.classList.add('show');        // show How-to
});

document.getElementById('backBtn').addEventListener('click', ()=>{
  howOverlay.classList.remove('show');     // hide How-to
  startOverlay.classList.add('show');      // show Start again
});


window.addEventListener('keydown', (e)=>{
  if(lock) return;
  const map = {'1':0,'2':1,'3':2,'4':3};
  if(e.key in map){
    const i = map[e.key];
    const b = activeBalloons.find(b=> +b.dataset.choiceIndex === i);
    if(b) b.click();
  }
});

function startGame(){
  // Reset state
  idx = 0; score = 0; correctCount = 0; lives = START_LIVES; updateHearts();
  scoreEl.textContent = score;
  overOverlay.classList.remove('show');
  howOverlay.classList.remove('show');
  startOverlay.classList.remove('show');
  // show question box now that game is active
  questionEl.style.display = 'block';
  nextQuestion();
}

function updateHearts(){
  const safeLives = Math.max(0, Math.min(START_LIVES, lives));
  heartsEl.textContent = '‚ù§Ô∏è'.repeat(safeLives) + 'üñ§'.repeat(START_LIVES - safeLives);
}


function shuffleIndices(n){
  const arr = Array.from({length: n}, (_, i) => i);
  for (let i = n - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}


function nextQuestion(){
  clearBalloons();
  clearBonus();

  if(idx >= QUESTIONS.length){ endGame(); return; }

  lock = false;
  const item = QUESTIONS[idx];
  timeLeft = item.seconds ?? PER_QUESTION_TIME;

  const order = shuffleIndices(item.choices.length);


  progressEl.textContent = `Q ${idx+1} / ${QUESTIONS.length}`;
  questionEl.textContent = (item.emoji? item.emoji+' ':'') + item.q;

  const cols = Math.min(COLUMNS, item.choices.length);
  const laneXs = layoutLanes(cols);
  screen.style.setProperty('--lane-step', (100 / (cols + 1)) + '%');

activeBalloons = order.map((choiceIdx, i) => {
  const text = item.choices[choiceIdx];
  const isCorrect = (choiceIdx === item.correct);

  // wrapper that animates up
  const wrap = document.createElement('div');
  wrap.className = 'balloonWrap';

  const x = laneXs[i % laneXs.length];
  wrap.style.left = `${x}%`;
wrap.style.transform = 'translate(-50%, 0)'; // baseline before animation

  const duration = BALLOON_TRAVEL_MS + rand(-800, 600);
  const delay = rand(0, 600);
  wrap.style.animationDuration = duration + 'ms';
  wrap.style.animationDelay = delay + 'ms';

  // the actual button (centered inside wrap)
  const b = document.createElement('button');
  b.className = 'balloon';
  b.classList.add(`c${i % 4}`);            // color by displayed slot 0‚Äì3
  b.setAttribute('aria-label', `Choice ${i+1}: ${text}`);
  b.dataset.choiceIndex = i;               // keyboard mapping uses this
b.style.animationDelay = rand(0, 1200) + 'ms';

  // Top: big number
  const num = document.createElement('span');
  num.className = 'num';
  num.textContent = (i + 1);

  // Bottom: answer text
  const row = document.createElement('span');
  row.className = 'row';

  const txt = document.createElement('span');
  txt.className = 'txt';
  txt.textContent = text;

  row.appendChild(txt);
  b.appendChild(num);
  b.appendChild(row);
  wrap.appendChild(b);

// Let clicks on the wrapper (the whole lane) count as clicking the button
wrap.addEventListener('click', (e) => {
  if (lock) return;
  // If the click wasn't directly on the button (or one of its children),
  // forward it to the button so we don't double-trigger.
  if (e.target !== b && !b.contains(e.target)) {
    b.click();
  }
});


  // CLICK -> pop & score
  b.addEventListener('click', () => {
    if (lock) return;
    lock = true;
    clearInterval(timer);

    // pause the floating wrapper, not the button
    wrap.style.animationPlayState = 'paused';

    b.classList.add(isCorrect ? 'correct' : 'wrong');
    b.dataset.icon = isCorrect ? 'üéâ' : 'üí•';
    b.classList.add('pop');

if (isCorrect){
  confettiBurst(b);


  const base = Math.max(10, 5 + timeLeft);
  const pts  = base + bonusPending;
  score += pts;
  correctCount++;
  scoreEl.textContent = score;

  let msg = `‚úÖ Correct! +${base}`;
  if (bonusPending) msg += ` (+${bonusPending} bonus)`;
  ping(msg, 'success');

  bonusPending = 0;
  clearBonus();           // remove bonus if still on screen
} else {
  if (lives > 0) lives--;
  updateHearts();
heartsEl.classList.add('hurt');
  heartsEl.addEventListener('animationend', () => heartsEl.classList.remove('hurt'), { once:true });
  bonusPending = 0;       // lose any stored bonus on wrong
  clearBonus();
  ping('‚ùå Oops!', 'error');
}


    // after pop finishes, move to next question
    b.addEventListener('animationend', (e) => {
      if (e.animationName !== 'popBurst') return;
      idx++;
      nextQuestion(); // keep going even if lives dropped to 0
    }, { once:true });
  });

  // When the FLOAT animation ends, remove the whole wrapper
  wrap.addEventListener('animationend', (e) => {
    if (e.animationName !== 'floatUp') return;
    wrap.remove();
  });

  screen.appendChild(wrap);
  return b; // keep the buttons in activeBalloons (keyboard still works)
});
spawnBonus();
startTimer();
 

}

function startTimer(){
  clearInterval(timer);
  timeEl.textContent = timeLeft;
  timer = setInterval(()=>{
    timeLeft--;
    timeEl.textContent = Math.max(0, timeLeft);
    if(timeLeft <= 0){
      clearInterval(timer);
      if(!lock){
        lock = true;
if (lives > 0) lives--;
updateHearts();
heartsEl.classList.add('hurt');
heartsEl.addEventListener('animationend', () => heartsEl.classList.remove('hurt'), { once:true });
ping('‚è≥ Time up!', 'error');
bonusPending = 0;
clearBonus();


        setTimeout(()=>{
idx++;
if (idx >= QUESTIONS.length) endGame(); else nextQuestion(); // only end after last question

        }, 500);
      }
    }
  }, 1000);
}

function endGame(){
  clearInterval(timer);
  clearBalloons();
clearBonus();
bonusPending = 0;

  finalEl.textContent = `Score: ${score} ‚Ä¢ Correct: ${correctCount} / ${QUESTIONS.length}`;
  overOverlay.classList.add('show');
  // hide question again so it doesn't cover overlays in a replay
  questionEl.style.display = 'none';
}

function clearBalloons(){
  document.querySelectorAll('.balloonWrap').forEach(w => w.remove());
  activeBalloons = [];
}



function spawnBonus(){
  clearBonus();
  bonusPending = 0; // reset each question

  const el = document.createElement('div');
  el.className = 'bonus';
  el.setAttribute('role','button');
  el.setAttribute('aria-label','Bonus');
  el.setAttribute('tabindex','0');
  el.textContent = '‚≠êÔ∏è';
  screen.appendChild(el);
  bonusEl = el;

  // place initial position
  const p0 = randomInsideScreen();
  setBonusPosition(p0.x, p0.y);

  // move periodically
  const move = () => {
    const p = randomInsideScreen();
    setBonusPosition(p.x, p.y);
  };
  move(); // first nudge
  bonusTimer = setInterval(move, 1000 + rand(0, 800));

  const claimBonus = (e) => {
    if (e) { e.stopPropagation(); e.preventDefault && e.preventDefault(); }
    if (lock || bonusPending > 0 || !bonusEl) return;
bonusPending = BONUS_POINTS;
ping('‚≠êÔ∏è Bonus +' + BONUS_POINTS + '!', 'success');

    el.classList.add('hide');
    setTimeout(clearBonus, 220);
  };

  el.addEventListener('click', claimBonus);
  el.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter' || e.key === ' '){
      claimBonus(e);
    }
  });
}

function setBonusPosition(x, y){
  if(!bonusEl) return;
  bonusEl.style.left = x + 'px';
  bonusEl.style.top  = y + 'px';
}

function randomInsideScreen(){
  const r = screen.getBoundingClientRect();
  const pad = 24;                                // edge padding
  const qh = (questionEl.offsetHeight || 0) + 20; // keep away from question bar

  // measure current star size (fallbacks if not yet laid out)
  const w = bonusEl ? bonusEl.offsetWidth  : 40;
  const h = bonusEl ? bonusEl.offsetHeight : 40;

  // coordinates in *screen local* space (since .bonus is appended to .screen)
  const x = rand(pad, r.width  - pad - w);
  const y = rand(Math.max(80, qh), r.height - pad - h);

  return { x, y };
}


function clearBonus(){
  if (bonusTimer){ clearInterval(bonusTimer); bonusTimer = null; }
  if (bonusEl){ bonusEl.remove(); bonusEl = null; }
}



function ping(msg, kind = 'info'){
  toast.textContent = msg;
  toast.className = 'toast ' + (kind || 'info'); // reset + apply kind
  // small reflow so the next classList.add triggers transition fresh
  void toast.offsetWidth;
  toast.classList.add('show');
  setTimeout(()=> toast.classList.remove('show'), 900);
}


function confettiBurst(el){
  const {left, top, width, height} = el.getBoundingClientRect();
  const cx = left + width / 2;
  const cy = top  + height / 2;

  const pieces = ['üéâ','‚ú®','üí•','üéä','‚≠êÔ∏è'];
  for (let i = 0; i < 6; i++){
    const s = document.createElement('div');
    s.className = 'confetti';
    s.textContent = pieces[Math.floor(Math.random() * pieces.length)];
    s.style.left = (cx + (Math.random()*80 - 40)) + 'px';
    s.style.top  = (cy + (Math.random()*20 - 10)) + 'px';
    document.body.appendChild(s);
    s.addEventListener('animationend', () => s.remove(), { once:true });
  }
}



function layoutLanes(cols){
  const step = 100/(cols+1);
  return Array.from({length: cols}, (_,i)=> step*(i+1));
}
function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
</script>
</body>
</html>
