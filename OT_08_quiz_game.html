<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Emoji Sort – Bible Trivia</title>
<style>
  :root{
    --bg:#0f172a;            /* slate-900 */
    --panel:#111827;         /* gray-900 */
    --panel-2:#1f2937;       /* gray-800 */
    --text:#e5e7eb;          /* gray-200 */
    --muted:#9ca3af;         /* gray-400 */
    --accent:#22c55e;        /* green-500 */
    --accent-2:#06b6d4;      /* cyan-500 */
    --wrong:#ef4444;         /* red-500 */
    --belt:#0b1024;
    --belt-line:#202a55;
    --ok:#3b82f6;            /* blue-500 */
    --shadow:0 10px 30px rgba(0,0,0,.35);
    --unit: min(1.9vh, 1.9vw); /* base scaler */
    --fontTitle: clamp(22px, 6.8vw, 48px);
    --fontH: clamp(18px, 5vw, 32px);
    --fontBody: clamp(14px, 3.4vw, 20px);
    --fontSmall: clamp(12px, 2.8vw, 16px);
    --btnPad: clamp(10px, 2.6vh, 18px);
    --radius: 16px;
  }
  html,body{
    height:100%; margin:0; background: radial-gradient(1200px 800px at 50% -10%, #1b2348 0%, #0f172a 50%, #0b1021 100%) fixed;
    color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji",sans-serif;
    overscroll-behavior:none;
    touch-action:none; /* we’ll handle panning to keep drags clean */
  }
  * { box-sizing:border-box; }
  .hidden{ display:none !important; }

  /* App shell */
  #app{
    position:relative; height:100svh; width:100vw; overflow:hidden;
  }
  .screen{
    position:absolute; inset:0; display:flex; flex-direction:column; justify-content:center; align-items:center; gap: clamp(10px, 3vh, 24px); padding: clamp(12px, 3vh, 28px);
  }
  .card{
    background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
    border:1px solid rgba(255,255,255,.06);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: clamp(16px, 3.4vh, 32px);
    max-width: 900px;
    width:min(94vw, 900px);
    text-align:center;
  }
  h1{ font-size: var(--fontTitle); margin:.2em 0 .2em; letter-spacing:.5px}
  h2{ font-size: var(--fontH); margin:.4em 0 .2em; }
  p{ font-size: var(--fontBody); color:var(--muted); margin:.4em 0 .2em; }
  .row{ display:flex; flex-wrap:wrap; gap: 10px; justify-content:center; }
  .btn{
    cursor:pointer; user-select:none;
    background: linear-gradient(180deg, #2b354f, #1b2340);
    color:var(--text); border:1px solid rgba(255,255,255,.08);
    padding: var(--btnPad) clamp(14px, 3vw, 22px);
    border-radius: 12px;
    font-weight:700; font-size: var(--fontBody);
    box-shadow: 0 6px 18px rgba(0,0,0,.25);
    transition: transform .08s ease, filter .2s ease, background .2s ease;
  }
  .btn:active{ transform:translateY(1px) scale(.98); filter:brightness(.95) }
  .btn.primary{ background: linear-gradient(180deg, #2563eb, #1d4ed8); }
  .btn.ok{ background: linear-gradient(180deg, var(--ok), #2563eb); }
  .btn.green{ background: linear-gradient(180deg, var(--accent), #16a34a); }
  .btn.cyan{ background: linear-gradient(180deg, var(--accent-2), #0891b2); }
  .kicker{ text-transform:uppercase; letter-spacing:1.5px; font-size:var(--fontSmall); color:#80d0ff }
  .statbar{
    display:flex; gap: 10px; align-items:center; justify-content:center;
    flex-wrap:wrap; font-size: var(--fontSmall);
    color: #cbd5e1;
  }
  .stat{
    background: rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.08);
    padding: 6px 10px; border-radius: 999px;
  }

  /* Question UI */
  .answers{
    color: var(--text);
    display:grid; gap:12px;
    grid-template-columns: 1fr 1fr;
    width: 100%;
    max-width: 900px;
    margin: 0 auto;

  }
  .answer{
    color: var(--text);
    -webkit-text-fill-color: var(--text); /* helps Safari on <button> */
    min-width: 0;
    word-break: break-word;
    display:flex; align-items:center; gap:12px; text-align:left;
    background: linear-gradient(180deg, #263055, #1a2140);
    padding: clamp(12px, 2.4vh, 18px);
    border:1px solid rgba(255,255,255,.08);
    border-radius: 14px; cursor:pointer;
    font-size: var(--fontBody); font-weight:700;
    transition: transform .08s ease, background .2s ease, border-color .2s ease;
  }
  .answer:active{ transform: translateY(1px) scale(.98) }

  .answer * { color: inherit; }


  .ans-emoji{ font-size: clamp(20px, 4.8vh, 34px); line-height:1 }

  /* Game field */
  #gamefield{
    position:relative;
    width: min(1100px, 98vw);
    height: calc(100svh - 140px);
    max-height: 82svh;
    border-radius: 18px;
    overflow:hidden;
    border:1px solid rgba(255,255,255,.08);
    background: linear-gradient(180deg, #0b1228, #0a0e1c);
    box-shadow: var(--shadow);
    margin: 0 auto;
  }
  /* Stat header inside gameplay */
  .gf-top{
    position:absolute; left:0; right:0; top:0;
    display:flex; gap:10px; justify-content:space-between; align-items:center;
    padding: 12px 14px; z-index:3;
    background: linear-gradient(180deg, rgba(0,0,0,.45), rgba(0,0,0,.1) 90%, rgba(0,0,0,0) 100%);
    backdrop-filter: blur(2px);
    font-size: var(--fontSmall);
  }
  .gf-badges{ display:flex; gap:8px; flex-wrap:wrap }
  .badge{
    background: rgba(255,255,255,.08);
    border:1px solid rgba(255,255,255,.1);
    padding:6px 10px; border-radius:999px;
  }

  /* Conveyor belt (center lane) */
.belt{
    position:relative;
    height:100%;
    /* center inside the middle grid track */
    justify-self:center;

    width:min(160px, 22vw);
    background:
      repeating-linear-gradient(
        to bottom,
        var(--belt) 0 28px,
        var(--belt-line) 28px 30px
      );
    border-left: none;
    border-right: none;
    box-shadow: inset 0 0 30px rgba(0,0,0,.65), inset 0 0 6px rgba(255,255,255,.08);
    z-index:1;
  }

/* Thin metal rails on both sides of the belt */
.belt::before,
.belt::after{
  content:"";
  position:absolute;
  top:0; bottom:0;
  width:8px;              /* thin metal edge */
  z-index:0;              /* sits beneath drops and above the belt background */
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,.35),  /* crisp highlight edge */
    inset 0 0 10px rgba(0,0,0,.35);         /* subtle depth */
  /* Layer 1/2: small dark rivets, staggered; Layer 3: brushed metal gradient */
  background-image:
    radial-gradient(circle at 50% 8px, rgba(0,0,0,.35) 0 2px, transparent 3px),
    radial-gradient(circle at 50% 22px, rgba(0,0,0,.35) 0 2px, transparent 3px),
    linear-gradient(180deg, #dcdcdc 0%, #c3c3c3 40%, #9f9f9f 50%, #cfcfcf 60%, #f3f3f3 100%);
  background-size:
    8px 28px,  /* rivet column 1 (repeats vertically) */
    8px 28px,  /* rivet column 2 (offset by 14px) */
    100% 100%; /* metal body */
  background-repeat: repeat-y, repeat-y, no-repeat;
  background-position: center 0, center 14px, 0 0;
}

.belt::before{ left:-6px; }   /* slightly outside belt for a crisp edge */
.belt::after { right:-6px; }


  /* Belt animation (just scroll the background) */
    .belt.scrolling{
    /* we’ll drive background-position with JS for perfectly smooth motion */
    will-change: background-position;
    }

  @keyframes beltMove{
    from{ background-position-y: 0 }
    to{ background-position-y: 60px }
  }

  /* Boxes */
  .boxes{
    position:absolute; inset:0; display:grid; grid-template-columns: 1fr minmax(160px, 22vw) 1fr;

    z-index:2;
  }
  .boxcol{ position:relative; display:flex; flex-direction:column; justify-content:space-evenly; padding: max(8px, 1.6vh); }
  /* Lock columns to the 3-grid layout */
   #leftCol  { grid-column: 1; }
   #belt     { grid-column: 2; } /* harmless even though it's absolutely positioned */
   #rightCol { grid-column: 3; }

 .box{
  position:relative;
  /* CRATE LOOK */
  background:
    /* wood slats */
    repeating-linear-gradient(
      180deg,
      #5c431f 0px,
      #6b4b22 16px,
      #5c431f 32px
    );
  border:2px solid #3b2a12;
  box-shadow:
    inset 0 0 24px rgba(0,0,0,.45),
    inset 0 6px 12px rgba(0,0,0,.35),
    0 10px 20px rgba(0,0,0,.2);
  border-radius: 14px;
  min-height: clamp(68px, 16vh, 160px);
  margin: 4px 0;
  display:flex; align-items:center; justify-content:center;
  transition: transform .12s ease, border-color .12s ease, box-shadow .12s ease;
}

/* corner braces */
.box::before,
.box::after{
  content:"";
  position:absolute; inset:8px;
  border:3px solid rgba(0,0,0,.35);
  border-radius:10px;
  pointer-events:none;
}

.box-label{
  position:absolute; inset:0;
  display:flex; align-items:center; justify-content:center;
  background: none; /* remove the pill */
  border: none;
  padding: 0;
  pointer-events: none; /* let drags pass through */
  color:#f3f4f6;
  text-shadow: 0 1px 0 rgba(0,0,0,.35), 0 2px 8px rgba(0,0,0,.25);
  font-weight:800;
  /* font-size is set by JS to 50% of min(box width/height) */
}

  .box.sink{ transform: scale(.97) }
  .box.good{ border-color: rgba(34,197,94,.85); box-shadow: 0 0 0 3px rgba(34,197,94,.25), inset 0 0 24px rgba(0,0,0,.4) }
  .box.bad{ border-color: rgba(239,68,68,.85); box-shadow: 0 0 0 3px rgba(239,68,68,.25), inset 0 0 24px rgba(0,0,0,.4) }

  /* Falling emojis */
  .drop{
    z-index: 3;
    position:absolute; left:0; top:0;
    font-size: clamp(24px, 5.6vh, 48px);
    line-height:1; user-select:none; cursor:grab;
    filter: drop-shadow(0 6px 10px rgba(0,0,0,.45));
    touch-action:none;
    transform: translateX(-50%) rotate(var(--rot, 0deg));
    transition: filter .12s ease;
  }
  .drop:active{ cursor:grabbing }
  .pop-good{
    animation: popGood .35s ease both;
  }
  @keyframes popGood{
    0%{ transform: scale(1) }
    60%{ transform: scale(1.35) }
    100%{ transform: scale(.0); opacity:0 }
  }
  .pop-bad{
    animation: popBad .45s ease both;
  }
  @keyframes popBad{
    0%{ transform: translateX(0) }
    25%{ transform: translateX(-10px) rotate(-6deg) }
    50%{ transform: translateX(8px) rotate(6deg) }
    75%{ transform: translateX(-6px) rotate(-4deg) }
    100%{ transform: translateX(0) }
  }

  /* Modal */
  .modal{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:5;
    background: linear-gradient(180deg, rgba(2,6,23,.6), rgba(2,6,23,.75));
    backdrop-filter: blur(2px);
  }
  .modal .card{ max-width:min(92vw, 640px) }
  .modal h3{ font-size: var(--fontH); margin:.2em 0 }
  .modal p{ font-size: var(--fontBody) }

  /* Helpers */
/* Points popup for correct sorts */
.points-pop{
  position:absolute;
  left:0; top:0;
  transform: translateX(-50%);
  font-weight: 900;
  font-size: clamp(14px, 2.8vh, 22px);
  color: #a7f3d0; /* minty green */
  text-shadow: 0 2px 8px rgba(0,0,0,.35);
  z-index: 6;
  pointer-events: none;
  animation: pointsUp .6s ease-out forwards;
}
@keyframes pointsUp{
  0%   { opacity: 0; transform: translate(-50%, 8px) scale(.9); }
  15%  { opacity: 1; transform: translate(-50%, 0)   scale(1.0); }
  100% { opacity: 0; transform: translate(-50%, -24px) scale(1.05); }
}


  .center{ text-align:center }
  .mono{ font-variant-numeric: tabular-nums }
  .tiny{ font-size: var(--fontSmall); color: var(--muted) }
  .spacer{ height:10px }
  .mt{ margin-top: 10px }
  .grow{ flex:1 }

  /* Small / narrow adjustments */
  @media (max-width: 700px){
    .answers{ grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
<div id="app">
  <!-- Splash Screen -->
  <section id="splash" class="screen">
    <div class="card">
      <div class="kicker">Welcome</div>
      <h1>📱 Best in Vertical Mode ↕️</h1>
      <p>Rotate your device to vertical for the best experience.</p>
      <div class="row">
        <button class="btn ok" id="btnSplashOk">Okay</button>
      </div>
    </div>
  </section>

  <!-- Title Screen -->
  <section id="title" class="screen hidden">
    <div class="card">
      <div class="kicker">From eatyourbible.com</div>
      <h1>♻️ Emoji Sort</h1>
      <p>Answer Bible questions, then sort emojis into the right boxes before they zoom past!</p>
      <div class="statbar">
        <span class="stat">10 Questions</span>
        <span class="stat">20-Second Sort Rounds</span>
        <span class="stat">Bonus Frenzy</span>
      </div>
      <div class="row" style="margin-top:14px">
        <button class="btn primary" id="btnStart">Start Game</button>
      </div>
      <div class="tiny mt">Tip: Drag emojis with your finger or mouse into their matching box.</div>
    </div>
  </section>

  <!-- Question Screen -->
  <section id="question" class="screen hidden">
    <div class="card">
      <div class="kicker">Question <span id="qNum">1</span> of 10</div>
      <h2 id="qText">Loading…</h2>
      <div class="answers" id="answers"></div>
      <div class="row" style="margin-top:10px">
        <div class="stat">Score: <span id="scoreQ" class="mono">0</span></div>
      </div>
    </div>
  </section>

  <!-- Gameplay Screen -->
  <section id="play" class="screen hidden">
    <div id="gamefield">
      <div class="gf-top">
        <div class="gf-badges">
          <div class="badge">Round <span id="roundBadge">1</span>/10</div>
          <div class="badge">Time <span id="timeBadge" class="mono">20.0</span>s</div>
          <div class="badge">Score <span id="scoreBadge" class="mono">0</span></div>
          <div class="badge" id="missBadgeWrap" style="display:none">Misses <span id="missBadge" class="mono">0</span>/5</div>
        </div>
      </div>

      <div class="boxes">
        <div class="boxcol" id="leftCol"></div>
        <div class="belt" id="belt"></div>
        <div class="boxcol" id="rightCol"></div>
      </div>
    </div>
  </section>

  <!-- End Screen -->
  <section id="end" class="screen hidden">
    <div class="card">
      <div class="kicker">All Done!</div>
      <h1>Great Sorting!</h1>
      <p>You finished all questions and the bonus round.</p>
      <h2>Final Score: <span id="finalScore" class="mono">0</span></h2>
      <div class="row" style="margin-top:14px">
        <button class="btn primary" id="btnReplay">Play Again</button>
      </div>
    </div>
  </section>

  <!-- Modal -->
  <div id="modal" class="modal hidden" aria-modal="true" role="dialog">
    <div class="card">
      <h3 id="modalTitle">Title</h3>
      <p id="modalMsg">Message</p>
      <div class="row" style="margin-top:12px">
        <button class="btn ok" id="modalOk">OK</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {

 /*

 #####     #     #    #######     #####     #######    ###    #######    #     #     #####  
#     #    #     #    #          #     #       #        #     #     #    ##    #    #     # 
#     #    #     #    #          #             #        #     #     #    # #   #    #       
#     #    #     #    #####       #####        #        #     #     #    #  #  #     #####  
#   # #    #     #    #                #       #        #     #     #    #   # #          # 
#    #     #     #    #          #     #       #        #     #     #    #    ##    #     # 
 #### #     #####     #######     #####        #       ###    #######    #     #     #####  

*/   


const ROUNDS = [
  {
    q: "Who was Abram married to? What problem did she have?",
    answers: [
      { emoji:"👰", text:"Sarai; she couldn’t have children" },
      { emoji:"👸", text:"Rebekah; she was blind" },
      { emoji:"👑", text:"Rachel; she was a queen" },
      { emoji:"🧕", text:"Hagar; she died" }
    ],
    correct: 0
  },
  {
    q: "What did God tell Abram to do?",
    answers: [
      { emoji:"🧭", text:"Go to a land God would show him" },
      { emoji:"🏰", text:"Build a great tower" },
      { emoji:"🔙", text:"Go back home" },
      { emoji:"👑", text:"Become king in Egypt" }
    ],
    correct: 0
  },
  {
    q: "God promised to grow Abram’s family into… what?",
    answers: [
      { emoji:"🌍", text:"A great nation" },
      { emoji:"🌱", text:"A small group" },
      { emoji:"🛡️", text:"A mighty army" },
      { emoji:"🏙️", text:"A rich city" }
    ],
    correct: 0
  },
  {
    q: "What did God promise to do to people who blessed or cursed Abram?",
    answers: [
      { emoji:"🤝", text:"Bless those who bless, curse those who curse" },
      { emoji:"⚖️", text:"Nothing" },
      { emoji:"🎁", text:"Bless everyone no matter what" },
      { emoji:"🕊️", text:"Only forgive those who cursed him" }
    ],
    correct: 0
  },
  {
    q: "What promise did God make about all the nations of the world?",
    answers: [
      { emoji:"🌎", text:"All nations would be blessed through Abram" },
      { emoji:"🧭", text:"All nations would move to Canaan" },
      { emoji:"👑", text:"All nations would serve Abram" },
      { emoji:"🗡️", text:"All nations would fight Abram" }
    ],
    correct: 0
  },
  {
    q: "How old was Abram when he left?",
    answers: [
      { emoji:"🎂", text:"75 years old" },
      { emoji:"⌛", text:"40 years old" },
      { emoji:"🕰️", text:"100 years old" },
      { emoji:"📅", text:"120 years old" }
    ],
    correct: 0
  },
  {
    q: "What was the name of the land God led Abram to?",
    answers: [
      { emoji:"🗺️", text:"Canaan" },
      { emoji:"🏜️", text:"Egypt" },
      { emoji:"🏛️", text:"Babylon" },
      { emoji:"🏙️", text:"Nineveh" }
    ],
    correct: 0
  },
  {
    q: "Who appeared to Abram in the land of Canaan?",
    answers: [
      { emoji:"✨", text:"God" },
      { emoji:"😇", text:"An angel" },
      { emoji:"👑", text:"Pharaoh" },
      { emoji:"🧙", text:"Moses" }
    ],
    correct: 0
  },
  {
    q: "What promise did God make to Abram in Canaan?",
    answers: [
      { emoji:"📜", text:"To give the land to him" },
      { emoji:"💰", text:"To make him the richest man ever" },
      { emoji:"⚔️", text:"To defeat all nearby kings" },
      { emoji:"🏗️", text:"To build a tower for him" }
    ],
    correct: 0
  },
  {
    q: "How did Abram’s family bless all nations?",
    answers: [
      { emoji:"✝️", text:"Through Abram's grandson Jesus" },
      { emoji:"📜", text:"Through the laws of Moses" },
      { emoji:"👑", text:"Through Solomon’s wisdom" },
      { emoji:"🛡️", text:"Through David’s victories" }
    ],
    correct: 0
  }
];



  /*

#######    #     #    ######     
#          ##    #    #     #    
#          # #   #    #     #    
#####      #  #  #    #     #    
#          #   # #    #     #    
#          #    ##    #     #    
#######    #     #    ######     


*/


  /* Bonus round categories (6 emoji) */
  const BONUS_EMOJI = ["🍞","🐟","🌈","🔥","💡","🧔‍♂️"];
  // ---- SPEED SETTINGS (edit these to tune game speed) ----
const SPEED = {
  NORMAL_START: 50,           // starting px/sec for standard rounds
  PER_ROUND: 12,              // added each round: NORMAL_START + PER_ROUND*roundIndex
  NORMAL_ACCEL_PER_SEC: 1,    // how much speed increases per second during a normal round
  BONUS_START: 70,           // starting px/sec for the bonus round
  BONUS_ACCEL_PER_SEC: 5     // how much speed increases per second during the bonus
};

// ---- SPAWN SETTINGS (edit these to tune spawn cadence) ----
const SPAWN = {
  NORMAL_EVERY_MS: 1400,            // base gap between spawns in normal rounds
  NORMAL_EVERY_MIN_MS: 900,        // don't go faster than this floor
  NORMAL_PER_ROUND_DELTA: 60,      // subtract this many ms per round (speeds up)
  NORMAL_JITTER_MS: 180,           // randomization for natural spacing

  BONUS_EVERY_MS: 1200,             // bonus base gap
  BONUS_JITTER_MS: 200             // a bit of jitter in bonus
};

// ---- POINT SETTINGS (emoji scoring) ----
const POINTS = {
  DROP_BASE: 10,          // points per emoji in Round 1
  DROP_PER_ROUND: 2,      // extra points added each round (Round N gets DROP_BASE + N*DROP_PER_ROUND)
  BONUS_DROP_BASE: 15     // flat points per emoji in the Bonus round
};
// ---------------------------------------


// ---- BELT SETTINGS ----
// One belt animation cycle in your CSS goes from background-position-y 0px to 60px.
// Keep this in sync with @keyframes beltMove.
const BELT = {
  CYCLE_PX: 60,     // must match the 60px in @keyframes beltMove
  MIN_MS: 120       // floor so the animation doesn't get too fast
};

// ---- DROP SETTINGS ----
const DROP = {
  X_JITTER_PX: 14,  // max random left/right offset from belt center (pixels)
  ROT_DEG: 45       // max random initial rotation (degrees)
};
// -----------------------




// -----------------------------------------------------------


// --------------------------------------------------------


  /*
    =========================
    STATE
    =========================
  */
  const el = (id)=>document.getElementById(id);
  const screens = {
    splash: el('splash'),
    title: el('title'),
    question: el('question'),
    play: el('play'),
    end: el('end'),
    modal: el('modal')
  };

  const beltEl = el('belt');
  const leftCol = el('leftCol');
  const rightCol = el('rightCol');

  const UI = {
    qNum: el('qNum'),
    qText: el('qText'),
    answers: el('answers'),
    scoreQ: el('scoreQ'),
    roundBadge: el('roundBadge'),
    timeBadge: el('timeBadge'),
    scoreBadge: el('scoreBadge'),
    missBadge: el('missBadge'),
    missWrap: el('missBadgeWrap'),
    finalScore: el('finalScore'),
    modalTitle: el('modalTitle'),
    modalMsg: el('modalMsg'),
    modalOk: el('modalOk')
  };

    const BTN = {
    splashOk: el('btnSplashOk'),
    start: el('btnStart'),
    replay: el('btnReplay')
    };


  let game = null;
  function newGame(){
    game = {
      roundIndex: 0,              // 0..9 (10 questions)
      score: 0,
      inBonus: false,
      misses: 0,
      // sorting round runtime
      running: false,
      drops: [],
      timer: 0,
      duration: 20,
      baseSpeed: SPEED.NORMAL_START, // px/sec starting speed
      speed: SPEED.NORMAL_START,
      beltAnimMs: 1000,
      beltOffset: 0,
      lastSpawn: 0,
      spawnEvery: SPAWN.NORMAL_EVERY_MS,
      spawnJitter: SPAWN.NORMAL_JITTER_MS,
      lastFrameTs: 0,
      grabbedId: null,
      idSeq: 1
    };
  }

  /*
    =========================
    NAVIGATION
    =========================
  */
  function show(id){
    for(const k of Object.keys(screens)){
      if(k === id) screens[k].classList.remove('hidden');
      else if(k !== 'modal') screens[k].classList.add('hidden'); // modal is overlay
    }
  }
  function showModal(title, msg, onOk){
    UI.modalTitle.textContent = title;
    UI.modalMsg.textContent = msg;
    screens.modal.classList.remove('hidden');
    const handler = ()=>{
      screens.modal.classList.add('hidden');
      UI.modalOk.removeEventListener('click', handler);
      if(onOk) onOk();
    };
    UI.modalOk.addEventListener('click', handler);
  }

// In-place Fisher–Yates shuffle for small arrays
function shuffleInPlace(arr){
  for(let i = arr.length - 1; i > 0; i--){
    const j = (Math.random() * (i + 1)) | 0;
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}



  /*
    =========================
    QUESTION PHASE
    =========================
  */
  function renderQuestion(){
    const rI = game.roundIndex;
    const data = ROUNDS[rI];
    UI.qNum.textContent = (rI+1);
    UI.qText.textContent = data.q;
    UI.scoreQ.textContent = game.score;
    // Render 4 answers
    UI.answers.innerHTML = "";

    // Build a shuffled order of indices [0,1,2,3]
    const order = shuffleInPlace([0,1,2,3]);

    order.forEach((origIndex, pos)=>{
    const ans = data.answers[origIndex];
    const btn = document.createElement('button');
    btn.className = 'answer';
    btn.innerHTML = `
        <span class="ans-emoji">${ans.emoji}</span>
        <span>${ans.text}</span>
    `;
    btn.addEventListener('click', ()=>{
        const correct = (origIndex === data.correct);
        if(correct){
        game.score += 100; // question bonus
        UI.scoreQ.textContent = game.score;
        showModal("Correct! ✅", `Nice! "${data.answers[data.correct].text}".`, ()=>{
            const go = ()=> startRound();
            if (game.roundIndex === 0) {
            showModal("♻️ Sort the Emojis!", "Use your mouse 🖱️ or your finger 👆 to drag each emoji from the conveyor belt into its matching box.", go);
            } else {
            go();
            }
        });
        }else{
        const right = data.answers[data.correct];
        showModal("Incorrect ❌", `Correct answer: ${right.emoji} ${right.text}`, ()=>{
            const go = ()=> startRound();
            if (game.roundIndex === 0) {
            showModal("♻️ Sort the Emojis!", "Use your mouse 🖱️ or your finger 👆 to drag each emoji from the conveyor belt into its matching box.", go);
            } else {
            go();
            }
        });
        }
    });
    UI.answers.appendChild(btn);
    });


    
    
  }

  /*
    =========================
    SORTING ROUND
    =========================
    - 4 boxes (2 left, 2 right) using the same emojis from answers
    - 20 seconds
    - speed accelerates during round + slight per-round increase
  */
  function clearBoxes(){
    leftCol.innerHTML = "";
    rightCol.innerHTML = "";
  }
  function makeBox(labelEmoji){
    const box = document.createElement('div');
    box.className = 'box';
    box.dataset.emoji = labelEmoji;
    const lab = document.createElement('div');
    lab.className = 'box-label';
    lab.innerHTML = `<span style="font-size:1.2em;line-height:1">${labelEmoji}</span>`;
    box.appendChild(lab);
    return box;
  }
  function layoutBoxesForRound(){
    clearBoxes();
    let labels;
    if(!game.inBonus){
      const ans = ROUNDS[game.roundIndex].answers.map(a=>a.emoji);
      labels = ans.slice(0,4);
    }else{
      labels = BONUS_EMOJI.slice(0,6);
    }

    // For normal: 2 per side; for bonus: 3 per side
    const perSide = game.inBonus ? 3 : 2;
    const left = labels.slice(0,perSide);
    const right = labels.slice(perSide, perSide*2);

    left.forEach(e=> leftCol.appendChild(makeBox(e)));
    right.forEach(e=> rightCol.appendChild(makeBox(e)));
  }

function updateBoxLabelSizes(){
  // Set emoji size to 50% of the smaller of box width/height
  const boxes = document.querySelectorAll('.box');
  boxes.forEach(box => {
    const lab = box.querySelector('.box-label');
    if(!lab) return;
    const span = lab.querySelector('span');
    if(!span) return;

    const r = box.getBoundingClientRect();
    const px = 0.5 * Math.min(r.width, r.height); // 50%
    // apply size
    span.style.fontSize = px + 'px';
    span.style.lineHeight = '1';
  });
}


function showPointsPop(x, y, amount){
  const gf = document.getElementById('gamefield');
  const pop = document.createElement('div');
  pop.className = 'points-pop';
  pop.textContent = `+${amount}`;
  // x,y are already in gamefield coordinates
  pop.style.left = x + 'px';
  pop.style.top  = (y - 10) + 'px'; // a hair above the emoji
  gf.appendChild(pop);
  setTimeout(()=> pop.remove(), 650);
}


  function boxesRect(){
    const rects = [];
    for(const col of [leftCol, rightCol]){
      for(const node of col.children){
        if(node.classList.contains('box')){
          const r = node.getBoundingClientRect();
          rects.push({node, r, emoji: node.dataset.emoji});
        }
      }
    }
    return rects;
  }

  function startRound(){
    show('play');
    // Setup HUD
    UI.roundBadge.textContent = String(game.inBonus ? "Bonus" : (game.roundIndex+1));
    UI.scoreBadge.textContent = game.score;
    UI.missWrap.style.display = game.inBonus ? '' : 'none';
    UI.missBadge.textContent = game.misses;

    // Boxes + belt
    layoutBoxesForRound();
    updateBoxLabelSizes();
    beltEl.classList.add('scrolling');

    // Timing + speed
    if(!game.inBonus){
      game.duration = 20;
      game.timer = game.duration;
      // per-round baseline speed increase
      const inc = SPEED.PER_ROUND * game.roundIndex;
      game.baseSpeed = SPEED.NORMAL_START + inc;
      game.speed = game.baseSpeed;
      game.beltAnimMs = Math.max(450 - 20*game.roundIndex, 220);
    }else{
      game.timer = Infinity; // bonus uses misses to stop
      game.misses = 0;
      game.baseSpeed = SPEED.BONUS_START; // bonus start
      game.speed = game.baseSpeed;
      game.beltAnimMs = 280;
    }
    // Reset the belt’s background scroll; JS will move it every frame.
    game.beltOffset = 0;
    beltEl.style.backgroundPositionY = '0px';



    // Spawning cadence
    if(!game.inBonus){
    game.spawnEvery  = Math.max(
        SPAWN.NORMAL_EVERY_MS - SPAWN.NORMAL_PER_ROUND_DELTA*game.roundIndex,
        SPAWN.NORMAL_EVERY_MIN_MS
    );
    game.spawnJitter = SPAWN.NORMAL_JITTER_MS;
    } else {
    game.spawnEvery  = SPAWN.BONUS_EVERY_MS;
    game.spawnJitter = SPAWN.BONUS_JITTER_MS;
    }


    // Clear drops
    for(const d of game.drops) d.el.remove();
    game.drops = [];
    game.lastFrameTs = performance.now();
    game.lastSpawn = 0;
    game.running = true;

    // Kick loop
    requestAnimationFrame(frame);
  }

  function endRound(){
    game.running = false;
    beltEl.classList.remove('scrolling');
    // cleanup drops
    for(const d of game.drops){ d.el.remove(); }
    game.drops = [];

    if(!game.inBonus){
      // Next question or bonus
      game.roundIndex++;
      if(game.roundIndex >= ROUNDS.length){
        // start bonus instructions
        showModal("⭐ Bonus Round!", "It's a sorting frenzy! Keep going until five fall off the belt. It will keep moving faster!", ()=>{
          game.inBonus = true;
          startRound();
        });
      }else{
        // go to next question
        show('question');
        renderQuestion();
      }
    }else{
      // Go to end screen
      UI.finalScore.textContent = game.score;
      show('end');
    }
  }

  /* Spawn a new falling emoji (picked from round labels) */
  function spawnDrop(){
    let choices = [];
    if(!game.inBonus){
      choices = ROUNDS[game.roundIndex].answers.map(a=>a.emoji);
    }else{
      choices = BONUS_EMOJI;
    }
    const emoji = choices[(Math.random()*choices.length)|0];

    const el = document.createElement('div');
    el.className = 'drop';
    el.textContent = emoji;
    // place in belt center x
    const gf = document.getElementById('gamefield').getBoundingClientRect();
    const beltR = beltEl.getBoundingClientRect();
    // center on the belt using CSS translateX(-50%)
    const cx = beltEl.getBoundingClientRect().left + beltEl.getBoundingClientRect().width/2;
    const jx  = (Math.random()*2 - 1) * DROP.X_JITTER_PX;   // horizontal jitter
    const rot = (Math.random()*2 - 1) * DROP.ROT_DEG;       // initial rotation

    const y  = beltEl.getBoundingClientRect().top - 40; // start just above field

    Object.assign(el.style, {
    left: (cx + jx - gf.left) + 'px',
    top:  (y       - gf.top)  + 'px'
    });

    el.style.setProperty('--rot', rot + 'deg');


    // attach
    document.getElementById('gamefield').appendChild(el);

    const drop = {
    id: game.idSeq++,
    el, emoji,
    x: (cx + jx - gf.left),  // include jitter in the stored center-x
    y: (y       - gf.top),
    vy: game.speed,          // px/sec
    dragging: false,
    grabbedOffsetX: 0,
    grabbedOffsetY: 0
    };



    // Pointer handlers
    el.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      drop.dragging = true;
      el.setPointerCapture(e.pointerId);
      el.style.transition = 'none';
      drop.grabbedOffsetX = (e.clientX - (document.getElementById('gamefield').getBoundingClientRect().left + drop.x));
      drop.grabbedOffsetY = (e.clientY - (document.getElementById('gamefield').getBoundingClientRect().top + drop.y));
    });
    el.addEventListener('pointermove', (e)=>{
      if(!drop.dragging) return;
      const gfR = document.getElementById('gamefield').getBoundingClientRect();
      drop.x = e.clientX - gfR.left - drop.grabbedOffsetX;
      drop.y = e.clientY - gfR.top - drop.grabbedOffsetY;
      applyDropTransform(drop);
    });
    el.addEventListener('pointerup', (e)=>{
      if(!drop.dragging) return;
      drop.dragging = false;
      // On release, check overlap with boxes
      tryPlaceIntoBox(drop);
    });

    game.drops.push(drop);
  }

  function applyDropTransform(d){
    d.el.style.left = d.x + 'px';
    d.el.style.top = d.y + 'px';
  }

  function rectOverlap(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function tryPlaceIntoBox(drop){
    const gfR = document.getElementById('gamefield').getBoundingClientRect();
    const myR = drop.el.getBoundingClientRect();
    const boxes = boxesRect();

    let best = null;
    for(const b of boxes){
      if(rectOverlap(myR.left,myR.top,myR.width,myR.height, b.r.left,b.r.top,b.r.width,b.r.height)){
        best = b; break;
      }
    }
    if(!best){
      // not over any box
      flashBox(null, false);
      // slight “bad” feedback
      drop.el.classList.remove('pop-bad','pop-good');
      drop.el.classList.add('pop-bad');
      setTimeout(()=>drop.el.classList.remove('pop-bad'), 450);
      return;
    }

    const good = best.emoji === drop.emoji;
    flashBox(best.node, good);

    if(good){
      // Score & remove
        const perDrop = game.inBonus
        ? POINTS.BONUS_DROP_BASE
        : (POINTS.DROP_BASE + (POINTS.DROP_PER_ROUND * game.roundIndex));
        game.score += perDrop;
        showPointsPop(drop.x, drop.y, perDrop);

      UI.scoreBadge.textContent = game.score;
      drop.el.classList.remove('pop-bad','pop-good');
      drop.el.classList.add('pop-good');
      // remove after anim
      setTimeout(()=>{
        drop.el.remove();
        game.drops = game.drops.filter(d=>d !== drop);
      }, 320);
        }else{
        // wrong: shake then remove from game
        drop.el.classList.remove('pop-bad','pop-good');
        drop.el.classList.add('pop-bad');
        setTimeout(()=>{
            drop.el.remove();
            game.drops = game.drops.filter(d=>d !== drop);
        }, 450); // match the shake duration so players see feedback
        }
}


  function flashBox(node, good){
    if(!node){
      // brief global nudge on wrong drop off-box
      return;
    }
    node.classList.remove('good','bad','sink');
    // small sink effect then feedback color
    node.classList.add('sink');
    setTimeout(()=>{
      node.classList.remove('sink');
      node.classList.add(good ? 'good' : 'bad');
      setTimeout(()=> node.classList.remove('good','bad'), 250);
    }, 80);
  }

  function frame(ts){
    if(!game.running) return;
    const dt = Math.min(0.032, (ts - game.lastFrameTs)/1000); // clamp dt
    game.lastFrameTs = ts;

    // Update timers
    if(!game.inBonus){
      game.timer -= dt;
      if(game.timer <= 0){
        UI.timeBadge.textContent = "0.0";
        endRound();
        return;
      }
      UI.timeBadge.textContent = game.timer.toFixed(1);
      // Accelerate a touch over time
      game.speed += SPEED.NORMAL_ACCEL_PER_SEC * dt;
    }else{
      // bonus never ends on timer; increases speed steadily
      game.speed += SPEED.BONUS_ACCEL_PER_SEC * dt;
      UI.timeBadge.textContent = "∞";
    }

    // Smooth, speed-synced belt scroll (px/sec matches emoji speed)
    game.beltOffset = (game.beltOffset + game.speed * dt) % BELT.CYCLE_PX;
    beltEl.style.backgroundPositionY = game.beltOffset + 'px';



    // Spawn logic
    game.lastSpawn += (dt*1000);
    const spawnEveryNow = game.spawnEvery - Math.random()*game.spawnJitter*0.5;
    if(game.lastSpawn >= spawnEveryNow){
      game.lastSpawn = 0;
      spawnDrop();
    }

    // Move drops
    const gfR = document.getElementById('gamefield').getBoundingClientRect();
    for(const d of game.drops.slice()){
      if(d.dragging) continue;
      d.y += game.speed * dt;
      applyDropTransform(d);

      // Fell off bottom?
      if(d.y > (gfR.height + 40)){
        d.el.remove();
        game.drops = game.drops.filter(x=>x!==d);
        if(game.inBonus){
          game.misses++;
          UI.missBadge.textContent = game.misses;
          if(game.misses >= 5){
            endRound();
            return;
          }
        }
      }
    }

    requestAnimationFrame(frame);
  }

  /*
    =========================
    INPUTS & BUTTONS
    =========================
  */
  BTN.splashOk.addEventListener('click', ()=>{
    show('title');
  });
  BTN.start.addEventListener('click', ()=>{
    newGame();
    show('question');
    renderQuestion();
  });

  
  BTN.replay.addEventListener('click', ()=>{
    newGame();
    show('title');
  });

  // Prevent page scrolling on touchmove within game (for smoother drags)
  window.addEventListener('resize', ()=>{
  // Recalculate emoji label sizes when the gamefield resizes
  updateBoxLabelSizes();
});

// Secret dev shortcut: press "b" to jump to Bonus Round
document.addEventListener('keydown', (e)=>{
  if ((e.key || '').toLowerCase() !== 'b') return;

  // Ensure game state exists
  if (!game) newGame();

  // If a normal round is running, stop and clean up current drops
  if (game.running) {
    game.running = false;
    beltEl.classList.remove('scrolling');
    for (const d of game.drops) d.el.remove();
    game.drops = [];
  }

  // Flag bonus and jump in
  game.inBonus = true;
  game.roundIndex = ROUNDS.length; // mark questions as finished
  game.misses = 0;

  showModal("Bonus Round!", "Testing shortcut: jumping to the bonus round.", ()=>{
    startRound();
  });
});



  document.addEventListener('touchmove', (e)=>{
    if(e.target.closest('#gamefield') || e.target.classList.contains('drop')){
      e.preventDefault();
    }
  }, {passive:false});

  // Start at splash
  show('splash');

})();
</script>
</body>
</html>
