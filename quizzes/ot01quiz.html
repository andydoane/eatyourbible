<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>OT 01 Quiz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg-gradient-top: #eef3ff;
      --bg-gradient-bottom: #d8e8ff;
      --card-bg: #ffffff;
      --accent: #3f6df6;
      --accent-dark: #2743a5;
      --text-main: #1f2933;
      --text-muted: #6b7280;
      --question-bg: #111827;

      --red: #ff5a51;
      --yellow: #ffc751;
      --blue: #40b9c5;
      --green: #a7cb6f;

      --button-radius: 0.9rem;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    html, body {
      height: 100%;
    }

    body {
      min-height: 100vh;
      min-height: 100svh; /* better fullscreen-ish on mobile browsers */
      display: flex;
      justify-content: center;
      align-items: stretch;
      background: radial-gradient(circle at top, var(--bg-gradient-top), var(--bg-gradient-bottom));
      background-size: 150% 150%;
      animation: bgDrift 20s ease-in-out infinite alternate;
      color: var(--text-main);
      overflow-y: auto; /* allow scrolling on small devices if needed */
    }

    @keyframes bgDrift {
      0% { background-position: 0% 0%; }
      100% { background-position: 100% 100%; }
    }

    #app {
      width: 100%;
      max-width: 1200px;
      height: 100%;
      display: flex;
      align-items: stretch;
      justify-content: center;
    }

body.mode-big #app {
  max-width: none;
  
}






    .screen-card {
      background: var(--card-bg);
      width: 100%;
      min-height: 100vh;
      min-height: 100svh;
      display: flex;
      flex-direction: column;
      padding: 18px 14px 22px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 0 30px rgba(15,23,42,0.20);
    }

    @media (min-width: 768px) {
      .screen-card {
        padding: 26px 32px 30px;
      }
    }

    #quiz-screen {
    position: relative;
    overflow: hidden;
    }


    .hidden {
      display: none !important;
    }

    /* ---------- INTRO SCREEN ---------- */

    #intro-screen {
    background: #ffffff;       /* was black */
    color: #000000;            /* default text color black */
    box-shadow: none;
    opacity: 1;
    transition: opacity 0.9s ease-out;
    }


    /* When this class is added, the intro screen fades away */
    #intro-screen.intro-fade-out {
      opacity: 0;
    }


     /* Make the whole background black during intro */
    body.intro-mode {
    background: #ffffff !important;  /* was black */
    animation: none !important;      /* keep this to stop gradient while intro shows */
    }



    .intro-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      gap: 8px;
    }

    .intro-line {
    opacity: 0;
    color: #000000;   /* was #ffffff */
    }


    .intro-line-1 {
      font-size: clamp(1rem, 2.5vw, 1.5rem);
      font-weight: 400;
      animation: introFadeIn 0.9s ease-out forwards;
      animation-delay: 0.2s;
    }

    .intro-line-2 {
      font-size: clamp(1.6rem, 4vw, 2.6rem);
      font-weight: 800;
      letter-spacing: 0.04em;
      animation: introFadeIn 0.9s ease-out forwards;
      animation-delay: 1.0s;
    }

    .intro-logo {
    margin-bottom: 16px;
    width: 160px;
    max-width: 60vw;
    opacity: 0;  /* start invisible */

    /* Fade in, then shake ‚Äì in one combined animation declaration */
    animation:
        introFadeIn 0.9s ease-out 0.1s forwards,
        introLogoShake 0.4s ease-in-out 2s 1;

    }



    /* Logo shake effect (used before swapping to bitten version) */
    .intro-logo-shake {
    animation: introLogoShake 0.4s ease-in-out 2;
    }

    /* Logo shake keyframes */
    @keyframes introLogoShake {
    0%   { transform: rotate(0deg); }
    25%  { transform: rotate(-4deg); }
    50%  { transform: rotate(4deg); }
    75%  { transform: rotate(-3deg); }
    100% { transform: rotate(0deg); }
    }





    @keyframes introFadeIn {
      from {
        opacity: 0;
        transform: translateY(4px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }


    /* ---------- TITLE SCREEN ---------- */

    #title-screen-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 24px;
      text-align: center;
    }

    .lesson-image-wrapper {
      width: 140px;
      height: 140px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    @media (min-width: 900px) {
      .lesson-image-wrapper {
        width: 200px;
        height: 200px;
      }
    }

    .lesson-image {
      width: 100%;
      height: 100%;
      object-fit: contain;
      animation: float 4.5s ease-in-out infinite;
    }

    @keyframes float {
      0% { transform: translateY(0); }
      50% { transform: translateY(6px); }
      100% { transform: translateY(0); }
    }

    .card-title {
      font-size: clamp(1.8rem, 4vw, 2.6rem);
      font-weight: 800;
      letter-spacing: 0.02em;
    }

    .card-subtitle {
      font-size: clamp(1rem, 2vw, 1.2rem);
      color: var(--text-muted);
    }

    .mode-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
      max-width: 420px;
    }

    @media (min-width: 600px) {
      .mode-buttons {
        flex-direction: row;
      }
    }

    .primary-button,
    .secondary-button {
      border-radius: 999px;
      border: none;
      padding: 12px 20px;
      font-size: clamp(1rem, 1.8vw, 1.2rem);
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: transform 0.1s ease, box-shadow 0.1s ease, filter 0.1s ease;
    }

    .primary-button {
      background: linear-gradient(135deg, var(--accent), var(--accent-dark));
      color: #ffffff;
      box-shadow: 0 10px 25px rgba(37, 99, 235, 0.4);
    }

    .secondary-button {
      background: #f3f4ff;
      color: var(--accent-dark);
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.18);
    }

    .primary-button:hover,
    .secondary-button:hover {
      transform: translateY(-1px);
      filter: brightness(1.05);
      box-shadow: 0 14px 30px rgba(15, 23, 42, 0.35);
    }

    .primary-button:active,
    .secondary-button:active {
      transform: translateY(0);
      filter: brightness(0.95);
      box-shadow: 0 6px 12px rgba(15, 23, 42, 0.25);
    }

    .mode-note {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-top: 6px;
      max-width: 420px;
      margin-left: auto;
      margin-right: auto;
    }

    /* ---------- TOP BAR + PROGRESS ---------- */

    .top-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: relative;
    font-size: clamp(0.95rem, 1.8vw, 1.15rem);
    margin-bottom: 4px;
    color: var(--text-muted);
    }


    .sound-toggle {
      border-radius: 999px;
      border: none;
      background: #edf2ff;
      padding: 6px 9px;
      font-size: 1.1rem;
      cursor: pointer;
      box-shadow: 0 3px 9px rgba(15,23,42,0.2);
      transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.08s ease;
    }

    .sound-toggle:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 14px rgba(15,23,42,0.25);
      filter: brightness(1.06);
    }

    .sound-toggle:active {
      transform: translateY(0);
      box-shadow: 0 3px 8px rgba(15,23,42,0.2);
      filter: brightness(0.96);
    }

    /* HOME BUTTON (center top) */
    .top-icon-button {
    border-radius: 999px;
    border: none;
    background: #edf2ff;
    padding: 6px 9px;
    font-size: 1.3rem;
    cursor: pointer;
    box-shadow: 0 3px 9px rgba(15,23,42,0.20);
    transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.08s ease;
    margin: 0 12px; /* spacing so it doesn't collide with text/sound button */
    }

    .top-icon-button:hover {
    transform: translateY(-1px);
    box-shadow: 0 6px 14px rgba(15,23,42,0.25);
    filter: brightness(1.06);
    }

    .top-icon-button:active {
    transform: translateY(0);
    box-shadow: 0 3px 8px rgba(15,23,42,0.20);
    filter: brightness(0.96);
    }


    /* Force HOME button to center */
    #home-button {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    }


    .progress-track {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: #e5e7eb;
      overflow: hidden;
      margin-top: 6px;
    }

    .progress-fill {
      height: 100%;
      width: 0%;
      border-radius: inherit;
      background: linear-gradient(120deg, #3f6df6, #22c55e, #3f6df6);
      background-size: 200% 100%;
      animation: progressFlow 2.5s linear infinite;
      transition: width 0.25s ease;
    }

    @keyframes progressFlow {
      0% { background-position: 0% 0%; }
      100% { background-position: 100% 0%; }
    }

    /* Timer ring (big-screen only visually) */
    .timer-ring-wrapper {
      position: relative;
      width: 180px;    /* bigger ring */
      height: 180px;
      display: none;   /* phone mode hides it */
      border-radius: 50%;
      box-shadow: 0 14px 30px rgba(15, 23, 42, 0.28);
      background: #ffffff;
    }

    body.mode-big .timer-ring-wrapper {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* When time runs out, make the timer ring "explode" */
    .timer-ring-wrapper.timer-explode {
    animation: timerExplode 0.7s ease-out forwards;
    }

    @keyframes timerExplode {
    0% {
        transform: scale(1);
        opacity: 1;
        box-shadow: 0 14px 30px rgba(15, 23, 42, 0.28);
    }
    40% {
        transform: scale(1.3);
        opacity: 1;
        box-shadow: 0 0 40px rgba(248, 113, 113, 0.9); /* bright red flash */
    }
    100% {
        transform: scale(0.6);
        opacity: 0;
        box-shadow: 0 0 0 rgba(0, 0, 0, 0);
    }
    }

    /* BIGGER, HOTTER, MORE IMPRESSIVE PARTICLES */
    .timer-particle {
    position: fixed;
    width: 22px;       /* was 10px */
    height: 22px;      /* was 10px */
    border-radius: 50%;
    pointer-events: none;
    z-index: 10002;      /* above everything */
    background: radial-gradient(circle, #fff4e6 0%, #ffb55a 40%, #ff6b3d 70%, #7f1d1d 100%);
    animation: timerParticle 1.2s ease-out forwards; /* longer, dramatic */
    --tx: 0px;
    --ty: 0px;
    }

    @keyframes timerParticle {
    0% {
        opacity: 1;
        transform: translate(0, 0) scale(1.3);
        filter: blur(0px);
    }
    40% {
        opacity: 1;
        transform: translate(var(--tx), var(--ty)) scale(1.0);
        filter: blur(1px);
    }
    100% {
        opacity: 0;
        transform: translate(calc(var(--tx) * 1.8), calc(var(--ty) * 1.8)) scale(0.3);
        filter: blur(4px);
    }
    }


    .timer-svg {
      width: 100%;
      height: 100%;
      transform: rotate(-90deg); /* start at top */
    }

    /* Ring base */
    .timer-ring-bg {
      fill: none;
      stroke: rgba(15, 23, 42, 0.12);  /* subtle dark outline */
      stroke-width: 10;
    }

    /* Foreground color is overridden by JS for green->yellow->red */
    .timer-ring-fg {
      fill: none;
      stroke: #3f6df6;
      stroke-width: 10;
      stroke-linecap: round;
      stroke-dasharray: 339.292;
      stroke-dashoffset: 0;
      transition: stroke-dashoffset 0.2s linear;
    }

    .timer-text {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2.2rem;  /* larger number */
      color: #111827;
      font-weight: 800;
    }





        /* Emoji host (right side) */
    .emoji-face {
      font-size: clamp(5rem, 9vw, 8rem); /* MUCH larger */
      filter: drop-shadow(0 14px 28px rgba(15, 23, 42, 0.35));
      opacity: 1;
      transition: transform 0.25s ease, opacity 0.25s ease;
    }



    .emoji-face.emoji-pop {
    transform: scale(1.1);
    opacity: 1;
    }


    /* ---------- QUIZ LAYOUT (shared) ---------- */

    .quiz-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 10px;
      min-height: 0;
    }

    .question-panel {
      display: flex;
      min-height: 0;
    }

    .answers-panel {
      display: flex;
      flex-direction: column;
      min-height: 0;
      position: relative;  /* NEW: so the suspense layer can anchor to this area */
    }


    .question-card {
    position: relative;            /* so we can attach an arrow to it */
    width: 100%;
    background: var(--question-bg);
    color: #ffffff;
    border-radius: 1.35rem;
    padding: 16px 18px;
    display: flex;
    flex-direction: column;        /* stack question + feedback + button */
    align-items: center;
    justify-content: center;
    text-align: center;
    box-shadow: 0 12px 30px rgba(15, 23, 42, 0.55);
    }


    .question-text {
      font-weight: 800;
      line-height: 1.3;
    }

    /* ----- Question Reveal Animation ----- */
    .question-text.question-reveal {
    animation: questionReveal 0.55s ease-out;
    }

    @keyframes questionReveal {
    0%   { opacity: 0; transform: translateY(12px) scale(0.98); }
    60%  { opacity: 1; transform: translateY(0) scale(1.02); }
    100% { opacity: 1; transform: translateY(0) scale(1); }
    }


    .answers-grid {
      display: grid;
      gap: 12px;
      flex: 1;
      min-height: 0;
    }

    @media (min-width: 640px) {
      .answers-grid {
        grid-template-columns: 1fr 1fr;
      }
    }

    .answer-button {
    position: relative;          /* ‚Üê add this line */
    width: 100%;
    border-radius: var(--button-radius);
    border: 3px solid rgba(255, 255, 255, 0.9);
    cursor: pointer;
    font-weight: 600;
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 10px 24px rgba(15,23,42,0.3);
    transition: transform 0.08s ease,
                box-shadow 0.08s ease,
                filter 0.08s ease,
                border-color 0.08s ease;
    padding: 14px 16px;
    }

    .answer-button.spotlight-chosen {
    position: relative;
    z-index: 60;
    }


    /* Hide keyboard hint numbers in phone mode */
    body.mode-phone .answer-key-hint {
    display: none !important;
    }


    .answer-key-hint {
    position: absolute;
    top: 6px;
    left: 8px;                   /* moved from right ‚Üí left */
    font-size: 1rem;             /* bigger number */
    font-weight: 700;
    background: rgba(255, 255, 255, 0.85);
    color: #111827;
    padding: 4px 8px;            /* slightly bigger pill */
    border-radius: 999px;
    pointer-events: none;
    }



    .answer-button:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 36px rgba(15,23,42,0.4);
      filter: brightness(1.05);
      border-color: rgba(255,255,255,1);
    }

    .answer-button:active {
      transform: translateY(0);
      box-shadow: 0 8px 18px rgba(15,23,42,0.3);
      filter: brightness(0.97);
    }

    .answer-button.disabled {
      pointer-events: none;
      opacity: 0.85;
      filter: none;
    }

    /* Visual states for correct / wrong answers */
    .answer-button.answer-correct {
    box-shadow:
        0 0 0 3px rgba(255, 255, 255, 1);  /* clean white outline */
    transform: translateY(-2px) scale(1.02);
    border-color: rgba(255, 255, 255, 1); /* white border */
    }

    .answer-button.answer-wrong {
      animation: shake 0.24s ease-in-out;
      opacity: 0.9;
    }

    .answer-button.answer-faded {
      filter: grayscale(1) brightness(0.8);
      opacity: 0.5;
    }


    @keyframes shake {
      0%   { transform: translateX(0); }
      25%  { transform: translateX(-4px); }
      50%  { transform: translateX(4px); }
      75%  { transform: translateX(-4px); }
      100% { transform: translateX(0); }
    }


    .answer-text {
      line-height: 1.3;
    }

    /* Slight glossy gradient on answer buttons */
    .color-red {
    background: linear-gradient(to bottom, rgba(255,255,255,0.18), rgba(0,0,0,0.18)), var(--red);
    color: #ffffff;
    }

    .color-yellow {
    background: linear-gradient(to bottom, rgba(255,255,255,0.18), rgba(0,0,0,0.18)), var(--yellow);
    color: #222222;
    }

    .color-blue {
    background: linear-gradient(to bottom, rgba(255,255,255,0.18), rgba(0,0,0,0.18)), var(--blue);
    color: #ffffff;
    }

    .color-green {
    background: linear-gradient(to bottom, rgba(255,255,255,0.18), rgba(0,0,0,0.18)), var(--green);
    color: #ffffff;
    }



    .score-row {
      display: flex;
      justify-content: space-between;
      font-size: clamp(0.95rem, 1.6vw, 1.2rem);
      padding-top: 10px;
      margin-top: 4px;
      border-top: 1px solid #e5e7eb;
      color: var(--text-muted);
    }

    .score-row strong {
      color: var(--text-main);
    }

    /* ---------- BIG-SCREEN MODE ---------- */

    body.mode-big .question-panel {
    /* Let the question area be only as tall as it needs */
    flex: 0 0 auto;
    }

    body.mode-big .answers-panel {
    /* Let the answers panel take the remaining height */
    flex: 1 1 auto;
    }


    body.mode-big .question-text {
      font-size: clamp(1.6rem, 3.2vw, 3.4rem);
    }

    body.mode-big .answer-button {
    font-size: clamp(1.2rem, 2.4vw, 2.6rem);

    /* Make the button 94% of its grid cell (‚âà47% of the whole area) */
    width: 94%;
    height: 94%;
    }


    /* Big-screen layout: timer | question | emoji */
    body.mode-big .question-panel {
      justify-content: center;
    }

    body.mode-big .question-layout {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      gap: 24px;
    }

    /* Side areas expand to fill leftover space, contents centered */
    body.mode-big .question-side {
      flex: 1 0 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Center block takes ~60% width, leaving ~20% on each side */
    body.mode-big .question-card {
      flex: 0 0 60%;
    }


    body.mode-big .answers-grid {
    grid-auto-rows: 1fr;

    /* Center the smaller buttons in their cells */
    justify-items: center;
    align-items: center;
    }

    /* ---------- QUESTION SLIDE TRANSITION ---------- */

    .quiz-main {
      position: relative; /* so the transform animations look smooth */
    }

    .quiz-main.question-slide-out {
      animation: questionSlideOut 0.55s ease-in forwards;
    }

    .quiz-main.question-slide-in {
      animation: questionSlideIn 0.55s cubic-bezier(0.22, 0.75, 0.25, 1.05) forwards;
    }

    @keyframes questionSlideOut {
      0% {
        transform: translateX(0) scale(1);
        opacity: 1;
      }
      15% {
        /* little "rev" to the right */
        transform: translateX(14px) scale(1.03);
      }
      100% {
        /* zoom off to the left */
        transform: translateX(-115%) scale(0.95);
        opacity: 0;
      }
    }

    @keyframes questionSlideIn {
      0% {
        transform: translateX(115%) scale(0.95);
        opacity: 0;
      }
      60% {
        /* snap into place */
        transform: translateX(0) scale(1.03);
        opacity: 1;
      }
      80% {
        /* tiny wiggle past center */
        transform: translateX(-8px) scale(0.99);
      }
      100% {
        transform: translateX(0) scale(1);
      }
    }


    /* ---------- PHONE MODE ---------- */

    body.mode-phone .quiz-main {
      gap: 6px;
    }

    body.mode-phone .question-panel {
    flex: 0 0 auto;
    display: block;       /* Stop using flex here on phone */
    }

    body.mode-phone .question-layout {
    width: 100%;          /* Make the layout span full width */
    }


    body.mode-phone .answers-panel {
      flex: 1 0 auto;
    }

    body.mode-phone .question-card {
      padding: 10px 12px;
    }

    body.mode-phone .question-text {
      font-size: clamp(1rem, 2.5vh, 1.5rem);
    }

    body.mode-phone .answers-grid {
      grid-template-columns: 1fr;
      grid-auto-rows: auto;
      gap: 8px;
    }

    body.mode-phone .answer-button {
      font-size: clamp(0.9rem, 2.2vh, 1.1rem);
      padding: 10px 12px;
    }

    /* Hide emoji entirely in phone mode */
    body.mode-phone .question-emoji,
    body.mode-phone #emoji-face {
    display: none !important;
    }

    /* ----- Streak Animations ----- */

    body.streak-tier-1 #emoji-face {
    animation: streakGlow 0.6s ease-out;
    }

    body.streak-tier-2 #emoji-face {
    animation: streakAura 0.9s ease-out;
    }

    body.streak-tier-3 #emoji-face {
    animation: streakFinal 1.2s ease-out;
    }

    @keyframes streakGlow {
    0%   { filter: drop-shadow(0 0 0 rgba(255,255,0,0)); }
    100% { filter: drop-shadow(0 0 18px rgba(255, 255, 135, 0.9)); }
    }

    @keyframes streakAura {
    0%   { filter: drop-shadow(0 0 0 rgba(255,215,0,0)); transform: scale(1); }
    50%  { filter: drop-shadow(0 0 25px rgba(255,215,0,0.9)); transform: scale(1.06); }
    100% { filter: drop-shadow(0 0 12px rgba(255,215,0,0.6)); transform: scale(1.02); }
    }

    @keyframes streakFinal {
    0%   { transform: scale(1) rotate(0);   filter: drop-shadow(0 0 0 rgba(255,180,0,0)); }
    40%  { transform: scale(1.15) rotate(3deg); filter: drop-shadow(0 0 45px rgba(255,200,0,1)); }
    70%  { transform: scale(1.1) rotate(-3deg); filter: drop-shadow(0 0 30px rgba(255,185,0,1)); }
    100% { transform: scale(1.05) rotate(0); filter: drop-shadow(0 0 18px rgba(255,180,0,0.7)); }
    }


    /* ---------- FULLSCREEN TWEAKS ---------- */

    :fullscreen .question-text,
    :-webkit-full-screen .question-text {
      font-size: clamp(2.2rem, 4vw, 5rem);
    }

    :fullscreen body.mode-big .answer-button,
    :-webkit-full-screen body.mode-big .answer-button {
       font-size: clamp(1.2rem, 2.4vw, 2.6rem);
    }



    /* ---------- FEEDBACK + STARS ---------- */

    /* Hidden by default, only shown when the card is in feedback mode */
    .feedback-bubble {
    display: none;
    width: 100%;
    }

    /* Question card becomes a ‚Äúspeech bubble‚Äù after answering */
    .question-card.feedback-mode {
    padding: 18px 22px 20px;
    }

    /* In feedback mode, hide the normal question text */
    .question-card.feedback-mode .question-text {
    display: none;
    }

    /* In feedback mode, show the feedback text area */
    .question-card.feedback-mode .feedback-bubble {
    display: block;
    }

    /* Arrow pointing from the right edge toward the emoji */
    .question-card.feedback-mode::after {
    content: "";
    position: absolute;
    top: 50%;
    right: -18px;
    transform: translateY(-50%);
    border-width: 12px 0 12px 18px;
    border-style: solid;
    border-color: transparent transparent transparent var(--question-bg);
    }

    /* Hide the arrow on phone since the emoji isn‚Äôt shown there */
    body.mode-phone .question-card.feedback-mode::after {
    display: none;
    }

    /* Title inside the ‚Äúbubble‚Äù */
    .feedback-title {
    font-size: clamp(3rem, 5vw, 4.2rem);
    font-weight: 900;
    letter-spacing: 0.16em;
    text-transform: uppercase;
    margin-bottom: 6px;
    text-align: center;
    }


    .feedback-title.correct-text { color: #a7cb6f; }
    .feedback-title.incorrect-text { color: #ff5a51; }

    /* Subtitle + Next row (in the white strip above the answers) */
    .feedback-subrow {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        margin: 18px 0 28px;  /* top, left/right, bottom */
        text-align: center;
    }



    .feedback-detail {
        font-size: clamp(1.6rem, 2.6vw, 2.1rem);
        line-height: 1.35;
        min-height: 1.8em; /* keep space even if empty */
    }



    .feedback-next-btn {
        align-self: center;
        font-size: clamp(1.1rem, 2.1vw, 1.5rem);
        padding: 14px 30px;
    }


    /* Falling stars for correct answers (unchanged) */
    .star {
    position: fixed;
    top: -40px;
    font-size: clamp(1.6rem, 2.6vw, 2.2rem);
    animation: fall 1.2s linear forwards;
    z-index: 60;
    pointer-events: none;
    }

    @keyframes fall {
    0% { transform: translateY(0) rotate(0deg); opacity: 1; }
    100% { transform: translateY(110vh) rotate(360deg); opacity: 0; }
    }


    /* ---------- SPOTLIGHT + SUSPENSE ---------- */

    .spotlight-overlay {
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.85);
    z-index: 40;
    pointer-events: none;
    }

    /* ---------- END REWARD SPOTLIGHT ---------- */

    .reward-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 10000; /* above everything else */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .reward-center {
      text-align: center;
      color: #ffffff;
    }

    .reward-present-big {
      font-size: clamp(5rem, 10vw, 8rem);
    }

    .reward-final-emoji {
        font-size: clamp(20rem, 44vw, 36rem); /* 4√ó bigger */
        margin-top: 8px;
        cursor: pointer;
        user-select: none;
        pointer-events: auto;
        position: relative;
        z-index: 10001;
    }



    /* Big present wiggle while we're in the spotlight */
    .reward-present-animate {
      animation: rewardPresentBigWiggle 1.2s ease-in-out infinite;
    }

    @keyframes rewardPresentBigWiggle {
      0%, 40%, 100% { transform: translateY(0) rotate(0deg); }
      10% { transform: translateY(-8px) rotate(-4deg); }
      20% { transform: translateY(4px) rotate(4deg); }
      30% { transform: translateY(-4px) rotate(-2deg); }
    }

    /* Giant emoji entrance (simple pop, for scores < 5) */
    .reward-emoji-pop {
      animation: rewardEmojiPop 0.7s ease-out forwards;
    }

    @keyframes rewardEmojiPop {
      0%   { transform: scale(0.6); opacity: 0; }
      60%  { transform: scale(1.1); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }

    /* Giant emoji dance (for scores >= 5) */
    .reward-emoji-dance {
      animation: rewardEmojiDance 2s ease-in-out forwards;
    }

    @keyframes rewardEmojiDance {
      0%   { transform: translateY(0) scale(1); }
      15%  { transform: translateY(-12px) scale(1.05); }
      30%  { transform: translateY(0) scale(1); }
      45%  { transform: rotate(-4deg) scale(1.05); }
      60%  { transform: rotate(4deg) scale(1.05); }
      75%  { transform: rotate(0deg) translateY(-8px) scale(1.05); }
      100% { transform: translateY(0) scale(1); }
    }


    .suspense-layer {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 80;
    pointer-events: none;
    }

    .suspense-thumb {
    /* EVEN bigger thumbs */
    font-size: clamp(7rem, 14vw, 11rem);

    /* Strong, soft shadow so it stands out on the dark overlay */
    filter: drop-shadow(0 22px 40px rgba(0, 0, 0, 0.9));
    }



    /* Particle explosion from the chosen button */
    .burst-star {
    position: fixed;
    font-size: 1.5rem;
    pointer-events: none;
    z-index: 70;
    animation: buttonBurst 0.7s ease-out forwards;
    }

    @keyframes buttonBurst {
    0% {
        transform: translate(0,0) scale(0);
        opacity: 1;
    }
    100% {
        transform: translate(var(--dx), var(--dy)) scale(1);
        opacity: 0;
    }
    }



    /* ---------- END SCREEN ---------- */

    /* Make the end screen center vertically */
    .card-header {
    flex: 1;
    display: flex;
    }


    .end-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 14px;
      text-align: center;
    }

    .end-trophy {
      font-size: clamp(3rem, 6vw, 4rem);
      cursor: pointer; /* make it look clickable */
    }

    /* Small present wiggle on the end screen */
    .end-present-wiggle {
      animation: endPresentWiggle 2s ease-in-out infinite;
    }

    @keyframes endPresentWiggle {
      0%, 20%, 100% { transform: rotate(0deg); }
      5%  { transform: rotate(-6deg); }
      10% { transform: rotate(6deg); }
      15% { transform: rotate(-3deg); }
    }


    .end-score {
      font-size: clamp(2.2rem, 3.3vw, 3rem);
      font-weight: 800;
      color: var(--accent-dark);
    }

    .end-detail {
      font-size: clamp(1.05rem, 1.8vw, 1.3rem);
      color: var(--text-muted);
    }

    .end-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin-top: 12px;
    }

    #end-screen.end-great {
      background: radial-gradient(circle at top, #fef9c3, #bbf7d0);
    }

    #end-screen.end-good {
      background: radial-gradient(circle at top, #dbeafe, #cffafe);
    }

    #end-screen.end-try {
      background: radial-gradient(circle at top, #fee2e2, #fef3c7);
    }

  /* ----- Dynamic Background Reactions (on quiz card) ----- */

    #quiz-screen.bg-correct {
    animation: bgCorrectPulse 0.6s ease-out;
    }

    #quiz-screen.bg-incorrect {
    animation: bgIncorrectPulse 0.6s ease-out;
    }

    @keyframes bgCorrectPulse {
    0%   { background: rgba(167, 203, 111, 0.25); }
    100% { background: var(--card-bg); }
    }

    @keyframes bgIncorrectPulse {
    0%   { background: rgba(255, 90, 81, 0.25); }
    100% { background: var(--card-bg); }
    }

    /* HIDE CURSOR IN BIG MODE (for all elements) */
    body.mode-big,
    body.mode-big * {
    cursor: none !important;
    }



    

    /* CUSTOM BIG POINTER */
    #big-pointer {
    position: fixed;
    top: 0;
    left: 0;
    z-index: 10001;
    font-size: 3.5rem;
    pointer-events: none;
    transform: translate(-38%, -15%);
    transition: transform 0.04s linear;
    }

    /* Little emoji "ghosts" that follow the big pointer */
    .pointer-trail-emoji {
    position: fixed;
    z-index: 9998; /* just under the main pointer */
    font-size: 2.5rem;
    pointer-events: none;
    transform: translate(-38%, -15%);
    opacity: 1;
    animation: pointerTrailFade 0.6s ease-out forwards;
    }

    @keyframes pointerTrailFade {
    0% {
        opacity: 1;
        transform: translate(-38%, -15%) scale(1);
    }
    100% {
        opacity: 0;
        transform: translate(-38%, -5%) scale(0.7);
    }
    }


    /* CLICK RIPPLE EFFECT (big-screen pointer) */
    .click-ripple {
    position: fixed;
    width: 80px;
    height: 80px;
    border-radius: 999px;
    border: 3px solid rgba(255, 255, 255, 0.85);
    pointer-events: none;
    z-index: 9998;
    transform: translate(-50%, -50%) scale(0.1);
    opacity: 0.9;
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.6);
    animation: clickRipple 0.45s ease-out forwards;
    }

    @keyframes clickRipple {
    0% {
        transform: translate(-50%, -50%) scale(0.1);
        opacity: 0.9;
    }
    70% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 0.5;
    }
    100% {
        transform: translate(-50%, -50%) scale(1.3);
        opacity: 0;
        box-shadow: 0 0 0 rgba(255, 255, 255, 0);
    }
    }

    
/* DEBUG: temporarily show the real mouse cursor */
body.show-real-cursor,
body.show-real-cursor * {
  cursor: auto !important;
}



  </style>
</head>
<body class="mode-title">
  <div id="app">

    <!-- INTRO SCREEN -->
    <div id="intro-screen" class="screen-card">
    <div class="intro-content">
        <!-- Logo FIRST -->
        <img
        id="intro-logo"
        class="intro-logo"
        src="quizimages/eyb_logo_1.png"
        alt="Eat Your Bible logo"
        />

        <!-- Then the text lines -->
        <div class="intro-line intro-line-1">Presented by</div>
        <div class="intro-line intro-line-2">eatyourbible.com</div>

        <!-- Load Quiz button -->
        <button
        id="load-quiz-btn"
        class="primary-button"
        style="margin-top: 20px; opacity: 0.5; pointer-events: none;"
        >
        Load Quiz
        </button>

    </div>
    </div>



    
    <!-- TITLE SCREEN -->
    <div id="title-screen" class="screen-card">
      <div id="title-screen-content">
        <div class="lesson-image-wrapper">
          <img
            id="lesson-image"
            class="lesson-image"
            alt="Lesson image"
          />
        </div>
        <div>
          <h1 id="lesson-title" class="card-title">Sample Devotional Quiz</h1>
          <p id="lesson-subtitle" class="card-subtitle">
            10 questions to see how well you know the story!
          </p>
        </div>
        <div class="mode-buttons">
          <button id="big-screen-btn" class="primary-button">
            <span>Big-Screen Mode</span> <span>üì∫</span>
          </button>
          <button id="phone-mode-btn" class="secondary-button">
            <span>Phone Mode</span> <span>üì±</span>
          </button>
        </div>
       <p class="mode-note">
  Big-Screen Mode is best for TVs and computers.<br>
  Phone Mode is sized to fit smaller screens.
</p>

      </div>
    </div>

    <!-- QUIZ SCREEN -->
    <div id="quiz-screen" class="screen-card hidden">
        <div class="top-bar">
            <span>Question <strong id="question-number">1</strong> of <strong id="total-questions">10</strong></span>

            <!-- CENTER HOME BUTTON -->
            <button id="home-button" class="top-icon-button" aria-label="Back to title">üè†</button>

            <button id="sound-toggle" class="sound-toggle" aria-label="Toggle sound">üîä</button>
        </div>

      <div class="progress-track">
        <div id="progress-fill" class="progress-fill"></div>
      </div>

      <div class="quiz-main">
        <div class="question-panel">
        <div class="question-layout">
            <!-- LEFT: Timer ring (big-screen only) -->
            <div class="question-side question-timer">
            <div class="timer-ring-wrapper">
                <svg class="timer-svg" viewBox="0 0 120 120">
                <circle
                    class="timer-ring-bg"
                    cx="60"
                    cy="60"
                    r="54"
                ></circle>
                <circle
                    id="timer-ring-fg"
                    class="timer-ring-fg"
                    cx="60"
                    cy="60"
                    r="54"
                ></circle>
                </svg>
                <div id="timer-text" class="timer-text">30</div>
            </div>
            </div>

            <!-- CENTER: Question -->
            <div class="question-card">
            <!-- Normal question text -->
            <div id="question-text" class="question-text">
                Question text here
            </div>

            <!-- Feedback bubble content (hidden until after answer) -->
            <div id="feedback-bubble" class="feedback-bubble">
                <div id="feedback-title" class="feedback-title">CORRECT</div>
                <!-- no subtitle here anymore -->
            </div>
            </div>



            <!-- RIGHT: Emoji host -->
            <div class="question-side question-emoji">
            <div id="emoji-face" class="emoji-face">üòÄ</div>
            </div>
        </div>
        </div>


                <div class="answers-panel">

            <!-- NEW: subtitle + Next Question strip -->
            <div id="feedback-subrow" class="feedback-subrow">
                <!-- Subtitle text will go here from JS -->
                <div id="feedback-detail" class="feedback-detail"></div>

                <!-- Next Question button (hidden until after reveal) -->
                <button
                id="next-question-btn"
                class="primary-button feedback-next-btn hidden"
                >
                Next Question
                </button>
            </div>

            <!-- Answer buttons -->
            <div class="answers-grid" id="answers-grid">
                <button class="answer-button color-red" data-button-index="0">
                <span class="answer-key-hint">1</span>
                <span class="answer-text"></span>
                </button>
                <button class="answer-button color-yellow" data-button-index="1">
                <span class="answer-key-hint">2</span>
                <span class="answer-text"></span>
                </button>
                <button class="answer-button color-blue" data-button-index="2">
                <span class="answer-key-hint">3</span>
                <span class="answer-text"></span>
                </button>
                <button class="answer-button color-green" data-button-index="3">
                <span class="answer-key-hint">4</span>
                <span class="answer-text"></span>
                </button>
            </div>

      <div class="score-row">
        <span>Score: <strong id="score-display">0</strong></span>
        <span>Streak: <strong id="streak-display">x0</strong></span>
      </div>

        <!-- Suspense thumbs / tick-tock layer -->
  <div id="suspense-layer" class="suspense-layer hidden">
    <div id="suspense-thumb" class="suspense-thumb">üëç</div>
  </div>

    </div>
  </div>

  <!-- Dark overlay for spotlight suspense -->
  <div id="spotlight-overlay" class="spotlight-overlay hidden"></div>


</div> <!-- end #quiz-screen -->



    <!-- END SCREEN -->
    <div id="end-screen" class="screen-card hidden">
      <div class="card-header">
        <div class="end-main">
          <div class="end-trophy" id="end-trophy">üèÜ</div>
          <h2 class="card-title" id="end-title">Quiz Complete!</h2>
          <p class="card-subtitle" id="end-subtitle">Here&rsquo;s how you did</p>
          <div class="end-score" id="final-score">0 points</div>
          <div class="end-detail" id="final-correct">
            You got 0 out of 10 correct
          </div>
          <div class="end-buttons">
            <button id="play-again-btn" class="primary-button">Play Again</button>
            <button id="back-to-title-btn" class="secondary-button">Back to Title</button>
          </div>
        </div>
      </div>
    </div>
  </div>

    <!-- Reward spotlight overlay for end screen -->
    <div id="reward-overlay" class="reward-overlay hidden">
        <div class="reward-center">
        <!-- Big present that wiggles before exploding -->
        <div id="reward-present-big" class="reward-present-big">üéÅ</div>
        <!-- Giant final emoji revealed after the present "explodes" -->
<div
  id="reward-emoji"
  class="reward-final-emoji hidden"
  onclick="handleRewardEmojiClick()"
></div>
        </div>
    </div>


<div id="big-pointer" class="hidden">üëÜ</div>



  <script>
    /***********************
     * CONFIG
     ***********************/
    const LESSON_ID = "ot01";
    const LESSON_TITLE_TEXT = "God Creates the World";
    const LESSON_SUBTITLE_TEXT = "Test how well you know this story";
    const LESSON_IMAGE_PATH = `quizimages/${LESSON_ID}image.png`;

    const QUESTIONS = [
      {
        text: "What did God create on day one?",
        answers: [
          "The heavens and the earth and light",
          "The sky and the sea",
          "Dry land and plants",
          "Sun, moon, and stars"
        ],
        correctIndex: 0
      },
      {
        text: "What did God create on day two?",
        answers: [
          "He separated the sky and the sea",
          "Dry land and plants",
          "Birds and fish",
          "Land animals and human beings"
        ],
        correctIndex: 0
      },
      {
        text: "What did God create on day three?",
        answers: [
          "Dry land and plants",
          "The sky and the sea",
          "Sun, moon, and stars",
          "Birds and fish"
        ],
        correctIndex: 0
      },
      {
        text: "What did God create on day four?",
        answers: [
          "Sun, moon, and stars",
          "Dry land and plants",
          "Land animals and people",
          "Birds and fish"
        ],
        correctIndex: 0
      },
      {
        text: "What did God create on day five?",
        answers: [
          "Birds and fish",
          "The sky and the sea",
          "Land animals and people",
          "Sun, moon, and stars"
        ],
        correctIndex: 0
      },
      {
        text: "What did God create on day six?",
        answers: [
          "Land animals and human beings",
          "Birds and fish",
          "Dry land and plants",
          "Nothing, He rested"
        ],
        correctIndex: 0
      },
      {
        text: "How are human beings different than everything else God made?",
        answers: [
          "We‚Äôre made in His likeness and given the job to rule over His creation",
          "We can swim and fly better than all animals",
          "We were created before light and water",
          "We live under the sea like fish"
        ],
        correctIndex: 0
      },
      {
        text: "What did God create on day seven?",
        answers: [
          "Nothing, He rested",
          "Birds and fish",
          "The sky and the sea",
          "Sun, moon, and stars"
        ],
        correctIndex: 0
      },
      {
        text: "How did God create everything?",
        answers: [
          "Out of nothing, just by speaking",
          "By using tools and machines",
          "By asking the angels to build it",
          "By finding pieces that were already there"
        ],
        correctIndex: 0
      },
      {
        text: "What did God say after seeing everything He made?",
        answers: [
          "It was very good",
          "It was almost good enough",
          "It needed to be fixed later",
          "He wasn‚Äôt sure He liked it"
        ],
        correctIndex: 0
      }
    ];

    // Detect iPads & Android tablets ‚Äî but NOT Windows touch laptops
    const ua = navigator.userAgent.toLowerCase();

    const isIpad = ua.includes("ipad") || 
                (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);

    const isAndroidTablet = ua.includes("android") && !ua.includes("mobile");

    // Final tablet detection
    const isRealTablet = isIpad || isAndroidTablet;


    /***********************
     * STATE
     ***********************/
    let currentMode = "phone"; // "big" or "phone"

    let currentQuestionIndex = 0;
    let score = 0;
    let streak = 0;
    let correctCount = 0;
    let soundEnabled = true;
    let isLocked = false;

    let audioCtx = null;
    let chompAudio = null;      // NEW: shared audio object for the chomp
    let isChompReady = false;   // NEW: tracks whether it's fully loaded

    const TIMER_DURATION = 30;

    const TIMER_RADIUS = 54;
    const TIMER_CIRCUMFERENCE = 2 * Math.PI * TIMER_RADIUS;

    let timeLeft = TIMER_DURATION;
    let timerIntervalId = null;

    const NEUTRAL_EMOJIS = [
    "üòÄ","üòÑ","üòä","üòÅ","ü§ó","üôÇ","ü§©","ü§™","ü•∏","ü§ì","üòß","üòµ‚Äçüí´","üôÉ","üò∫","üò∏","üòª",
    "üòé","üòá","üòÆ‚Äçüí®","üòå","üòÉ"
    ];

    
    const CORRECT_EMOJIS = [
    "ü§©","üòÑ","üéâ","ü•≥","üôå","üòé","üòÉ","üòÅ","üò∫","üéä","‚≠ê",
    "üëè","üî•","üí•","üåü","‚ú®","ü´∂","üòá","üí´","üèÜ","ü•á",
    "ü§ó","üòÜ","üòª","üíØ","üéà"
    ];
    const INCORRECT_EMOJIS = [
    "üò¢","üòÆ","üòØ","üòï","üòü","üôÅ","üòû","üòî","ü•∫",
    "üòø","üò£","üò´","ü§¢","üò•","ü´§","üòê","üôÑ"
    ];

    // Big reward emoji pools based on number of correct answers (0‚Äì10)
    // The more you get right, the "cooler" the emoji.
const FUNNY_EMOJIS = [
  "ü§™","ü•∏","ü§°","ü§†","üí©","ü¶Ü","üòπ","üçï","ü§§","üëΩ","üåÆ","üç©","ü•®","üçî","üê∏","üòè",
  "üôä","ü§Ø","ü§Æ","üêØ","ü¶Å","üê∂","üêº","üê∞","üê≥","üçü","üç™","üçø","üßÄ","üçé","üçç","üç∞"
];

const REWARD_EMOJI_POOLS = {
  0: FUNNY_EMOJIS,
  1: FUNNY_EMOJIS,
  2: FUNNY_EMOJIS,
  3: FUNNY_EMOJIS,
  4: FUNNY_EMOJIS,
  5: FUNNY_EMOJIS,
  6: FUNNY_EMOJIS,
  7: FUNNY_EMOJIS,
  8: FUNNY_EMOJIS,
  9: FUNNY_EMOJIS,
  10: FUNNY_EMOJIS
};

    function pickRewardEmoji() {
      const total = QUESTIONS.length || 10;
      let score = correctCount;

      if (score < 0) score = 0;
      if (score > total) score = total;
      if (score > 10) score = 10; // clamp to 10 for our table

      const pool = REWARD_EMOJI_POOLS[score] || REWARD_EMOJI_POOLS[0];
      const index = Math.floor(Math.random() * pool.length);
      return pool[index];
    }


    // Feedback phrases for the speech bubble
    const CORRECT_TITLES = [
      "Correct!",
      "Great work!",
      "You got it!",
      "Nice job!",
      "Well done!",
      "Awesome!"
    ];

    const INCORRECT_TITLES = [
      "Not quite!",
      "Incorrect!",
      "Nice try!",
      "Almost!",
      "Good effort!"
    ];

    // Streak-based encouragements (for correct answers)
    const STREAK_PHRASES_START = [
      "Keep going ‚Äì you got this!",
      "I knew you could do it!",
      "Let‚Äôs see if you can get the next one too."
    ];

    const STREAK_PHRASES_BUILDING = [
      "That's {{streak}} in a row!",
      "You're on a {{streak}}-question streak!",
      "Wow, {{streak}} correct answers back-to-back!"
    ];

    const STREAK_PHRASES_HOT = [
      "You're on fire with {{streak}} in a row!",
      "Unstoppable! {{streak}} straight correct answers!",
      "You're really mastering this story!"
    ];

    // Encouragements for incorrect answers
    const ENCOURAGE_PHRASES = [
      "Don‚Äôt give up ‚Äî try the next one!",
      "Everybody misses one sometimes. You‚Äôve got this!",
      "Take a breath and get the next one.",
      "You‚Äôre learning. Let‚Äôs see what happens on the next question.",
      "Keep going ‚Äì you'll get the next one!"
    ];

    let emojiIntervalId = null;
    let emojiLockedUntil = 0;
    let isTransitioningQuestion = false;

    let suspenseIntervalId = null;
    let lastSelectedButton = null;
    let lastAnswerWasCorrect = false;
    let lastSelectedAnswerIndex = null;
    let buttonBurstTimeoutId = null;

    let pointerTrailPending = false; // NEW: should we give a comet trail on the next question?
    let hasRevealedReward = false;   // NEW: has the end present already been opened?
    let rewardFinished = false;      // NEW: has the big reward emoji already exploded?


    /***********************
     * DOM
     ***********************/
    const body = document.body;

    const introScreen = document.getElementById("intro-screen");
    const titleScreen = document.getElementById("title-screen");
    const quizScreen = document.getElementById("quiz-screen");
    const endScreen = document.getElementById("end-screen");
    
    const introLogo = document.getElementById("intro-logo");
    const loadQuizBtn = document.getElementById("load-quiz-btn");


    const bigScreenBtn = document.getElementById("big-screen-btn");
    const phoneModeBtn = document.getElementById("phone-mode-btn");

    const lessonImageEl = document.getElementById("lesson-image");
    const lessonTitleEl = document.getElementById("lesson-title");
    const lessonSubtitleEl = document.getElementById("lesson-subtitle");

    const questionNumberEl = document.getElementById("question-number");
    const totalQuestionsEl = document.getElementById("total-questions");
    const progressFillEl = document.getElementById("progress-fill");

    const questionTextEl = document.getElementById("question-text");
    const answerButtons = Array.from(document.querySelectorAll(".answer-button"));

    const timerTextEl = document.getElementById("timer-text");
    const timerRingFgEl = document.getElementById("timer-ring-fg");
    const emojiFaceEl = document.getElementById("emoji-face");

    const timerRingWrapper = document.querySelector(".timer-ring-wrapper");
    const quizMain = document.querySelector(".quiz-main");  // <-- add this


    
    // DEBUG: Hold SHIFT to temporarily show the real cursor
    document.addEventListener("keydown", (e) => {
    if (e.key === "Shift") {
        document.body.classList.add("show-real-cursor");
    }
    });

    document.addEventListener("keyup", (e) => {
    if (e.key === "Shift") {
        document.body.classList.remove("show-real-cursor");
    }
    });


    const scoreDisplayEl = document.getElementById("score-display");
    const streakDisplayEl = document.getElementById("streak-display");

    const feedbackTitleEl = document.getElementById("feedback-title");
    const feedbackDetailEl = document.getElementById("feedback-detail");
    const feedbackBubble = document.getElementById("feedback-bubble");
    const questionCard = document.querySelector(".question-card");

    const spotlightOverlay = document.getElementById("spotlight-overlay");
    const suspenseLayer = document.getElementById("suspense-layer");
    const suspenseThumb = document.getElementById("suspense-thumb");


    const soundToggleBtn = document.getElementById("sound-toggle");

    const finalScoreEl = document.getElementById("final-score");
    const finalCorrectEl = document.getElementById("final-correct");

    const endTitleEl = document.getElementById("end-title");
    const endSubtitleEl = document.getElementById("end-subtitle");
    const endTrophyEl = document.getElementById("end-trophy");
    const rewardOverlay = document.getElementById("reward-overlay");
    const rewardPresentBig = document.getElementById("reward-present-big");
    const rewardEmojiEl = document.getElementById("reward-emoji");
    const playAgainBtn = document.getElementById("play-again-btn");
    const backToTitleBtn = document.getElementById("back-to-title-btn");


    totalQuestionsEl.textContent = QUESTIONS.length.toString();
    lessonImageEl.src = LESSON_IMAGE_PATH;
    lessonTitleEl.textContent = LESSON_TITLE_TEXT;
    lessonSubtitleEl.textContent = LESSON_SUBTITLE_TEXT;

    const bigPointer = document.getElementById("big-pointer");

    /***********************************
     * POINTER COMET TRAILS (NEW)
     ***********************************/
    const POINTER_HEAD = "üëÜ";

    const POINTER_TRAILS = [
    {
        id: "star_comet",
        emojis: ["‚≠ê", "‚ú®", "¬∑"],
        glowColor: "#f6c453", // warm golden yellow
    },
    {
        id: "ocean_comet",
        emojis: ["üåä", "üíß", "¬∑"],
        glowColor: "#34c3ff", // aqua / turquoise
    },
    {
        id: "garden_comet",
        emojis: ["üåø", "üå±", "üçÉ", "¬∑"],
        glowColor: "#4caf50", // fresh leaf green
    },
    {
        id: "fire_comet",
        emojis: ["üî•", "‚ú®", "¬∑"],
        glowColor: "#ff6a2f", // intense orange-red
    },
    {
        id: "galaxy_comet",
        emojis: ["üåô", "‚≠ê", "‚ú®", "¬∑"],
        glowColor: "#7e57c2", // deep purple / indigo
    },
    {
        id: "animal_comet",
        emojis: ["üêæ", "üêæ", "¬∑"],
        glowColor: "#a67c52", // warm brown
    },
    {
        id: "joy_comet",
        emojis: ["üòÑ", "üòä", "üôÇ", "¬∑"],
        glowColor: "#ffd54f", // bright cheerful yellow
    },
    {
        id: "heart_comet",
        emojis: ["‚ù§Ô∏è", "üíï", "üíñ", "¬∑"],
        glowColor: "#ff4081", // pink-red
    },
    {
        id: "rainbow_comet",
        emojis: ["üåà", "‚ú®", "¬∑"],
        glowColor: "#ffffff", // soft white
    },
    {
        id: "bible_light_comet",
        emojis: ["üìñ", "‚ú®", "¬∑"],
        glowColor: "#fff3cd", // gentle pale gold
    },
    ];

    let pointerTrailDeck = [];
    let currentPointerTrail = null;

    // NEW: for mouse trail behaviour
    let lastPointerTrailTime = 0;       // when we last created a ghost
    let pointerTrailEmojiIndex = 0;     // which emoji to use next in the comet's list

    function refillPointerTrailDeck() {
    // Fill the deck with all trail indexes and shuffle them
    pointerTrailDeck = POINTER_TRAILS.map((_, index) => index);

    for (let i = pointerTrailDeck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pointerTrailDeck[i], pointerTrailDeck[j]] = [pointerTrailDeck[j], pointerTrailDeck[i]];
    }
    }

    function getNextPointerTrail() {
    if (pointerTrailDeck.length === 0) {
        refillPointerTrailDeck();
    }
    const nextIndex = pointerTrailDeck.pop(); // no repeats until deck is empty
    return POINTER_TRAILS[nextIndex];
    }

    function applyPointerTrail(trail) {
    currentPointerTrail = trail;

    // The pointer itself stays just "üëÜ".
    // We only add a glow so it feels special.
    bigPointer.style.textShadow = `
        0 0 8px ${trail.glowColor},
        0 0 16px ${trail.glowColor}
    `;
    }

    function clearPointerTrail() {
    currentPointerTrail = null;
    bigPointer.textContent = POINTER_HEAD;
    bigPointer.style.textShadow = "none";
    }

    function schedulePointerTrailForNextQuestion() {
    // Called when a question is answered correctly
    pointerTrailPending = true;
    }

    // NEW: create one fading emoji "ghost" at (x, y)
    function spawnPointerTrailEmoji(x, y) {
    // If no comet is active, do nothing
    if (!currentPointerTrail) return;

    const now = performance.now ? performance.now() : Date.now();

    // Throttle: don't spawn on EVERY tiny movement (40ms gap)
    if (now - lastPointerTrailTime < 40) return;
    lastPointerTrailTime = now;

    const emojis = currentPointerTrail.emojis || [];
    if (!emojis.length) return;

    // Cycle through the comet's emoji list: ‚≠ê ‚Üí ‚ú® ‚Üí ¬∑ ‚Üí ‚≠ê ‚Üí ...
    const emoji = emojis[pointerTrailEmojiIndex % emojis.length];
    pointerTrailEmojiIndex++;

    const span = document.createElement("span");
    span.className = "pointer-trail-emoji";
    span.textContent = emoji;
    span.style.left = x + "px";
    span.style.top = y + "px";

    // Give the ghost a soft glow too
    if (currentPointerTrail.glowColor) {
        span.style.textShadow = `
        0 0 6px ${currentPointerTrail.glowColor}
        `;
    }

    document.body.appendChild(span);

    // Remove the element after its fade-out animation finishes
    span.addEventListener("animationend", () => {
        span.remove();
    });
    }

    // Start with a simple pointer (no trail)
    if (bigPointer) {
    clearPointerTrail();
    }




    // PRELOAD CHOMP SOUND (existing code continues)
    chompAudio = new Audio("quizsounds/sound_chomp.mp3");



    // PRELOAD CHOMP SOUND
    chompAudio = new Audio("quizsounds/sound_chomp.mp3");
    chompAudio.preload = "auto";

    // Start in "not ready" state ‚Äì keep button dim/unclickable
    if (loadQuizBtn) {
    loadQuizBtn.style.opacity = "0.5";
    loadQuizBtn.style.pointerEvents = "none";
    }

    // When the sound is fully buffered and can play through smoothly:
    chompAudio.addEventListener("canplaythrough", () => {
    isChompReady = true;
    if (loadQuizBtn) {
        loadQuizBtn.style.opacity = "1";
        loadQuizBtn.style.pointerEvents = "auto";
    }
    });

    // Kick off loading
    chompAudio.load();



    /***********************
     * AUDIO
     ***********************/
    function getAudioContext() {
      if (!audioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (AC) {
          audioCtx = new AC();
        }
      }
      return audioCtx;
    }

    function playBeepSequence(notes) {
      if (!soundEnabled) return;
      const ctx = getAudioContext();
      if (!ctx) return;
      const now = ctx.currentTime;
      notes.forEach((note, i) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.type = "triangle";
        osc.frequency.value = note.freq;
        const t0 = now + i * note.duration;
        const t1 = t0 + note.duration;
        gain.gain.setValueAtTime(0, t0);
        gain.gain.linearRampToValueAtTime(0.45, t0 + 0.02);
        gain.gain.linearRampToValueAtTime(0.0, t1);
        osc.start(t0);
        osc.stop(t1 + 0.02);
      });
    }

    function playCorrectSound() {
      playBeepSequence([
        { freq: 660, duration: 0.14 },
        { freq: 880, duration: 0.14 },
        { freq: 1040, duration: 0.16 }
      ]);
    }

    function playIncorrectSound() {
      playBeepSequence([
        { freq: 260, duration: 0.18 },
        { freq: 200, duration: 0.20 }
      ]);
    }

    function playChompSound() {
    // Only play if sounds are enabled and the audio is ready
    if (!soundEnabled || !chompAudio || !isChompReady) return;

    try {
        chompAudio.currentTime = 0; // always start at beginning
        chompAudio.play();
    } catch (e) {
        console.warn("Could not play chomp sound", e);
    }
    }

    function playTickTock(isThumbUp) {
    if (!soundEnabled) return;

    // Simple subtle tick/tock beeps
    const seq = isThumbUp
        ? [{ freq: 700, duration: 0.08 }]
        : [{ freq: 450, duration: 0.08 }];

    playBeepSequence(seq);
    }



    /***********************
     * HELPERS
     ***********************/
    function shuffledIndices(n) {
      const arr = Array.from({ length: n }, (_, i) => i);
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function chooseRandom(list) {
      if (!list || !list.length) return "";
      const idx = Math.floor(Math.random() * list.length);
      return list[idx];
    }

    function getStreakPhrase(streak) {
      if (streak <= 1) {
        return chooseRandom(STREAK_PHRASES_START);
      } else if (streak <= 4) {
        const tmpl = chooseRandom(STREAK_PHRASES_BUILDING);
        return tmpl.replace("{{streak}}", streak.toString());
      } else {
        const tmpl = chooseRandom(STREAK_PHRASES_HOT);
        return tmpl.replace("{{streak}}", streak.toString());
      }
    }

    function startSpotlight(selectedBtn) {
    if (spotlightOverlay) {
        spotlightOverlay.classList.remove("hidden");
    }
    if (selectedBtn) {
        selectedBtn.classList.add("spotlight-chosen");
    }
    }

    function stopSpotlight() {
    if (spotlightOverlay) {
        spotlightOverlay.classList.add("hidden");
    }
    answerButtons.forEach(btn => btn.classList.remove("spotlight-chosen"));
    }

    function startSuspenseSequence() {
    if (!suspenseLayer || !suspenseThumb || !spotlightOverlay) {
        // If something is missing, just skip suspense and reveal immediately
        revealAnswerAndFeedback();
        return;
    }

    suspenseLayer.classList.remove("hidden");
    let isThumbUp = true;
    let cycles = 0;
    const maxCycles = 8; // about ~4 seconds of suspense

    suspenseThumb.textContent = "üëç";

    suspenseIntervalId = setInterval(() => {
        isThumbUp = !isThumbUp;
        suspenseThumb.textContent = isThumbUp ? "üëç" : "üëé";
        playTickTock(isThumbUp);
        cycles += 1;

        if (cycles >= maxCycles) {
        clearInterval(suspenseIntervalId);
        suspenseIntervalId = null;

        setTimeout(() => {
            suspenseLayer.classList.add("hidden");
            stopSpotlight();
            revealAnswerAndFeedback();
        }, 200);
        }
    }, 450);
    }

    function stopSuspense() {
    if (suspenseIntervalId) {
        clearInterval(suspenseIntervalId);
        suspenseIntervalId = null;
    }
    if (suspenseLayer) suspenseLayer.classList.add("hidden");
    stopSpotlight();
    }

    // Highlight the correct answer and fade the others
    function highlightCorrectAnswer() {
    const q = QUESTIONS[currentQuestionIndex];

    answerButtons.forEach(b => {
        const bIndex = Number(b.dataset.answerIndex);
        if (bIndex === q.correctIndex) {
        b.classList.add("answer-correct");
        b.classList.remove("answer-faded");
        } else {
        b.classList.add("answer-faded");
        b.classList.remove("answer-correct");
        }
    });
    }

    // Particle explosion from the chosen button
    function spawnButtonBurst(buttonEl) {
    if (!buttonEl) return;
    const rect = buttonEl.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    const count = 14;

    for (let i = 0; i < count; i++) {
        const star = document.createElement("span");
        star.className = "burst-star";
        star.textContent = "‚≠ê";

        const angle = Math.random() * Math.PI * 2;
        const dist = 50 + Math.random() * 50;
        const dx = Math.cos(angle) * dist;
        const dy = Math.sin(angle) * dist;

        star.style.left = `${centerX}px`;
        star.style.top = `${centerY}px`;
        star.style.setProperty("--dx", `${dx}px`);
        star.style.setProperty("--dy", `${dy}px`);

        document.body.appendChild(star);

        star.addEventListener("animationend", () => {
        star.remove();
        });
    }
    }

    function startButtonBurstLoop() {
    stopButtonBurstLoop(); // clear any previous loop
    if (!lastSelectedButton || !lastAnswerWasCorrect) return;

    const burstOnce = () => {
        if (!lastSelectedButton || !lastAnswerWasCorrect) return;
        spawnButtonBurst(lastSelectedButton);
        buttonBurstTimeoutId = setTimeout(burstOnce, 900); // wait for previous particles to finish
    };

    burstOnce();
    }

    function stopButtonBurstLoop() {
    if (buttonBurstTimeoutId) {
        clearTimeout(buttonBurstTimeoutId);
        buttonBurstTimeoutId = null;
    }
    }

    // Reveal after suspense: highlight, scoring, feedback bubble, bursts
    function revealAnswerAndFeedback() {
    const q = QUESTIONS[currentQuestionIndex];

    // 1) Always highlight the correct answer and fade the rest
    highlightCorrectAnswer();

    // 2) Scoring + sounds + emoji + streak
    if (lastAnswerWasCorrect) {
        schedulePointerTrailForNextQuestion();
        let timeBonus = 0;
        if (currentMode === "big") {
        timeBonus = timeLeft * 5; // 5 points per remaining second
        }

        streak += 1;
        const base = 100 * streak;

        if (currentMode === "big") {
        body.classList.remove("streak-tier-1", "streak-tier-2", "streak-tier-3");

        if (streak >= 8) {
            body.classList.add("streak-tier-3");
        } else if (streak >= 5) {
            body.classList.add("streak-tier-2");
        } else if (streak >= 2) {
            body.classList.add("streak-tier-1");
        }
        }

        const earned = base + timeBonus;
        score += earned;
        correctCount += 1;
        updateScoreDisplays();
        playCorrectSound();
        spawnStarRain(20);
        showEmojiReaction(true);

        showFeedback(true);
        startButtonBurstLoop();
    } else {
        streak = 0;
        updateScoreDisplays();
        playIncorrectSound();
        showEmojiReaction(false);
        showFeedback(false);
    }
    }


    function showScreen(screenName) {
      // Hide all screens first
      introScreen.classList.add("hidden");
      titleScreen.classList.add("hidden");
      quizScreen.classList.add("hidden");
      endScreen.classList.add("hidden");

      if (screenName === "intro") {
        introScreen.classList.remove("hidden");
      } else if (screenName === "title") {
        titleScreen.classList.remove("hidden");
      } else if (screenName === "quiz") {
        quizScreen.classList.remove("hidden");
      } else if (screenName === "end") {
        endScreen.classList.remove("hidden");
      }
    }


    function updateScoreDisplays() {
      scoreDisplayEl.textContent = score.toString();
      streakDisplayEl.textContent = "x" + streak.toString();
    }

    function updateProgress() {
      const n = currentQuestionIndex;
      const pct = (n / QUESTIONS.length) * 100;
      progressFillEl.style.width = pct + "%";
      questionNumberEl.textContent = (n + 1).toString();
    }

    function spawnStarRain(count) {
      for (let i = 0; i < count; i++) {
        const star = document.createElement("div");
        star.className = "star";
        star.textContent = "‚≠ê";
        star.style.left = Math.random() * 100 + "vw";
        star.style.animationDelay = Math.random() * 0.5 + "s";
        document.body.appendChild(star);
        star.addEventListener("animationend", () => star.remove());
      }
    }

   
       // Reset and hide the reward overlay
    function hideRewardOverlay() {
      if (!rewardOverlay) return;

      rewardOverlay.classList.add("hidden");

      if (rewardPresentBig) {
        rewardPresentBig.classList.add("hidden");
        rewardPresentBig.classList.remove("reward-present-animate");
      }

      if (rewardEmojiEl) {
        rewardEmojiEl.classList.add("hidden");
        rewardEmojiEl.classList.remove("reward-emoji-dance", "reward-emoji-pop");
      }
    }

    // Start the reward spotlight sequence after clicking the present
    function startRewardSequence() {
      if (!rewardOverlay || !rewardPresentBig) return;

      // reset final-state flag every time we start fresh
      rewardFinished = false;

      // Show the dark overlay and big present
      rewardOverlay.classList.remove("hidden");
      rewardPresentBig.textContent = "üéÅ";
      rewardPresentBig.classList.remove("hidden");
      rewardPresentBig.classList.add("reward-present-animate");

      // Make sure the emoji is hidden at the start
      if (rewardEmojiEl) {
        rewardEmojiEl.classList.add("hidden");
        rewardEmojiEl.classList.remove("reward-emoji-dance", "reward-emoji-pop");
      }

      // After a short wiggle time, "explode" the present
      setTimeout(() => {
        explodeRewardPresent();
      }, 2000); // 2 seconds of wiggle feels nice
    }

    // Present explosion: hide box, show giant emoji, add particles + dance
    function explodeRewardPresent() {
      if (!rewardPresentBig || !rewardEmojiEl) return;

      // Stop showing the big present
      rewardPresentBig.classList.add("hidden");
      rewardPresentBig.classList.remove("reward-present-animate");

      // Pick an emoji based on how many questions were correct
      const emoji = pickRewardEmoji();
      rewardEmojiEl.textContent = emoji;

      // Scores 5 or higher get a little dance; below 5 just pop in
      if (correctCount >= 5) {
        rewardEmojiEl.classList.add("reward-emoji-dance");
      } else {
        rewardEmojiEl.classList.add("reward-emoji-pop");
      }

      rewardEmojiEl.classList.remove("hidden");

      // Particle "explosion" ‚Äì reuse the star rain for a big celebration
      spawnStarRain(40);

      // NEW: after 5 seconds, automatically explode the emoji and remove the dark overlay
      setTimeout(() => {
        // If the player already clicked and finished, do nothing
        if (rewardFinished) return;

        // Otherwise, run the same logic as a click
        handleRewardEmojiClick();
      }, 5000);
    }

    // NEW: When the big reward emoji is clicked, explode it and close the overlay
    function handleRewardEmojiClick() {
      if (!rewardEmojiEl) return;

      // If we've already exploded / finished, do nothing
      if (rewardFinished) return;
      rewardFinished = true;

      // Big particle blast from the emoji itself
      spawnRewardExplosionParticles(70);

      // Quick "pop out" effect on the emoji
      rewardEmojiEl.style.transition = "transform 0.25s ease-out, opacity 0.25s ease-out";
      rewardEmojiEl.style.transform = "scale(1.3)";
      rewardEmojiEl.style.opacity = "0";

      // After the pop, hide the dark overlay and reset styles for next game
      setTimeout(() => {
        hideRewardOverlay();

        // Reset inline styles so the emoji looks normal next time
        rewardEmojiEl.style.transition = "";
        rewardEmojiEl.style.transform = "";
        rewardEmojiEl.style.opacity = "";
      }, 250);
    }





    function updateTimerVisual() {
      if (!timerRingFgEl || !timerTextEl) return;

      const ratio = Math.max(0, Math.min(1, timeLeft / TIMER_DURATION));
      const offset = TIMER_CIRCUMFERENCE * (1 - ratio);

      // Update ring length
      timerRingFgEl.style.strokeDasharray = String(TIMER_CIRCUMFERENCE);
      timerRingFgEl.style.strokeDashoffset = String(offset);

      // Smooth color transition: green (full) -> yellow -> red (empty)
      const hue = ratio * 120; // 120 = green, 0 = red
      const color = `hsl(${hue}, 85%, 55%)`;
      timerRingFgEl.style.stroke = color;

      // Update number in middle
      timerTextEl.textContent = String(timeLeft);
    }

    function triggerTimerExplosion() {
    if (!timerRingWrapper) return;

    // Add the explode class to start the CSS animation
    timerRingWrapper.classList.add("timer-explode");

    // Remove the class after the animation so it's ready for the next question
    setTimeout(() => {
        timerRingWrapper.classList.remove("timer-explode");
    }, 700); // match animation duration
    }

    function spawnTimerExplosionParticles(count = 30) {
    if (!timerRingWrapper) return;

    const rect = timerRingWrapper.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;

    const colors = ["#ffedd5", "#fed7aa", "#fdba74", "#fb923c", "#f97316", "#ea580c", "#b91c1c"];

    for (let i = 0; i < count; i++) {
        const p = document.createElement("div");
        p.className = "timer-particle";

        // random angle + distance
        const angle = Math.random() * Math.PI * 2;
        const distance = 40 + Math.random() * 60; // how far it flies
        const dx = Math.cos(angle) * distance;
        const dy = Math.sin(angle) * distance;

        // position at center of ring
        p.style.left = cx + "px";
        p.style.top = cy + "px";

        // set custom properties for animation end position
        p.style.setProperty("--tx", dx + "px");
        p.style.setProperty("--ty", dy + "px");

        // fiery color
        const color = colors[Math.floor(Math.random() * colors.length)];
        p.style.background = `radial-gradient(circle, #fff7ed 0%, ${color} 55%, #7f1d1d 100%)`;

        document.body.appendChild(p);
        p.addEventListener("animationend", () => p.remove());
    }



    }


    // Big explosion when clicking the final reward emoji
    function spawnRewardExplosionParticles(count = 60) {
      if (!rewardEmojiEl) return;

      // Get the emoji's position on the screen
      const rect = rewardEmojiEl.getBoundingClientRect();
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;

      // Same fiery color palette as the timer explosion
      const colors = ["#ffedd5", "#fed7aa", "#fdba74", "#fb923c", "#f97316", "#ea580c", "#b91c1c"];

      for (let i = 0; i < count; i++) {
        const p = document.createElement("div");
        p.className = "timer-particle"; // reuse existing CSS + animation

        // random angle + distance (bigger blast than the timer)
        const angle = Math.random() * Math.PI * 2;
        const distance = 60 + Math.random() * 120;
        const dx = Math.cos(angle) * distance;
        const dy = Math.sin(angle) * distance;

        // start at center of the big emoji
        p.style.left = cx + "px";
        p.style.top = cy + "px";

        // custom properties for the end position (used by CSS animation)
        p.style.setProperty("--tx", dx + "px");
        p.style.setProperty("--ty", dy + "px");

        // fiery gradient color
        const color = colors[Math.floor(Math.random() * colors.length)];
        p.style.background = `radial-gradient(circle, #fff7ed 0%, ${color} 55%, #7f1d1d 100%)`;

        document.body.appendChild(p);
        p.addEventListener("animationend", () => p.remove());
      }
    }

        function spawnClickRipple(x, y) {
        // Only show in big-screen mode, not on iPad/Android tablets
        if (!body.classList.contains("mode-big")) return;
        if (isRealTablet) return;

        const ripple = document.createElement("div");
        ripple.className = "click-ripple";
        ripple.style.left = x + "px";
        ripple.style.top = y + "px";
        document.body.appendChild(ripple);

        ripple.addEventListener("animationend", () => {
            ripple.remove();
        });
        }


    function stopTimer() {
      if (timerIntervalId !== null) {
        clearInterval(timerIntervalId);
        timerIntervalId = null;
      }
    }

    function startTimer() {
    stopTimer();
    timeLeft = TIMER_DURATION;
    updateTimerVisual();

    // Only actually run timer in big-screen mode
    if (currentMode !== "big") return;

    timerIntervalId = setInterval(() => {
        if (timeLeft > 0) {
        timeLeft -= 1;
        updateTimerVisual();
        } else {
        // Time's up: show 0, explode the ring + spawn fiery particles, then stop
        timeLeft = 0;
        updateTimerVisual();
        triggerTimerExplosion();
        spawnTimerExplosionParticles(30);
        stopTimer();
        }
    }, 1000);
    }



    function setEmojiFromSet(list) {
      if (!emojiFaceEl || !list.length) return;
      const next = list[Math.floor(Math.random() * list.length)];
      emojiFaceEl.textContent = next;

      // small pop animation
      emojiFaceEl.classList.add("emoji-pop");
      setTimeout(() => {
        emojiFaceEl && emojiFaceEl.classList.remove("emoji-pop");
      }, 200);
    }

    function startEmojiLoop() {
      if (!emojiFaceEl) return;
      if (emojiIntervalId !== null) clearInterval(emojiIntervalId);

      // Start with a random neutral face
      setEmojiFromSet(NEUTRAL_EMOJIS);

      emojiIntervalId = setInterval(() => {
        const now = Date.now();
        if (now < emojiLockedUntil) return; // temporarily locked for answer reaction
        setEmojiFromSet(NEUTRAL_EMOJIS);
      }, 3000);
    }

    function showEmojiReaction(isCorrect) {
      const set = isCorrect ? CORRECT_EMOJIS : INCORRECT_EMOJIS;
      emojiLockedUntil = Date.now() + 2000; // lock for ~2 seconds
      setEmojiFromSet(set);
    }


    function showFeedback(isCorrect) {
    // 1) Pick a fun heading for the bubble
    const title = isCorrect
        ? chooseRandom(CORRECT_TITLES)
        : chooseRandom(INCORRECT_TITLES);

    feedbackTitleEl.textContent = title;
    feedbackTitleEl.classList.toggle("correct-text", isCorrect);
    feedbackTitleEl.classList.toggle("incorrect-text", !isCorrect);

    // 2) Pick the detail line (subtitle under the bubble)
    let detailText = "";
    if (isCorrect) {
        detailText = getStreakPhrase(streak);
    } else {
        detailText = chooseRandom(ENCOURAGE_PHRASES);
    }

    feedbackDetailEl.textContent = detailText || "";

    // 3) Background reaction pulse on the quiz card (big mode only)
    if (currentMode === "big") {
        quizScreen.classList.remove("bg-correct", "bg-incorrect");
        void quizScreen.offsetWidth; // restart CSS animation hack
        quizScreen.classList.add(isCorrect ? "bg-correct" : "bg-incorrect");
    }

    // 4) Switch the question bar into "feedback bubble" mode
    if (questionCard && feedbackBubble && questionTextEl) {
        questionCard.classList.add("feedback-mode");
        feedbackBubble.style.display = "block";
        questionTextEl.style.display = "none";
    }

    // 5) Big-screen vs phone behavior
    if (currentMode === "big") {
        // Show the Next Question button in the white strip
        nextQuestionBtn.classList.remove("hidden");
    } else {
        // Phone mode: auto-advance after a short delay
        nextQuestionBtn.classList.add("hidden");
        setTimeout(() => {
        // Only advance if we're still looking at feedback
        if (questionCard && questionCard.classList.contains("feedback-mode")) {
            goToNextQuestionAnimated();
        }
        }, 2000);
    }
    }





    function requestFullscreenIfAvailable() {
      const docEl = document.documentElement;
      const request =
        docEl.requestFullscreen ||
        docEl.webkitRequestFullscreen ||
        docEl.msRequestFullscreen;
      if (request) {
        try {
          request.call(docEl);
        } catch (e) {
          // ignore; some browsers (esp. iOS) just won't do it
        }
      }
    }

    /***********************
     * GAME FLOW
     ***********************/
    function startGame(mode) {
      currentMode = mode;
      body.classList.remove("mode-title", "mode-big", "mode-phone");
        if (mode === "big") {
            if (isRealTablet) {
                // Hide pointer on iPads & Android tablets
                bigPointer.classList.add("hidden");
            } else {
                // Show pointer on desktops + Windows touchscreens
                bigPointer.classList.remove("hidden");
            }
        } else {
            bigPointer.classList.add("hidden");
        }




      if (mode === "big") {
        body.classList.add("mode-big");
        requestFullscreenIfAvailable();
      } else {
        body.classList.add("mode-phone");
        // We still try fullscreen; on iOS this may be ignored.
        requestFullscreenIfAvailable();
      }

      startEmojiLoop();

      currentQuestionIndex = 0;
      score = 0;
      streak = 0;
      correctCount = 0;
      updateScoreDisplays();
      updateProgress();
      showScreen("quiz");
      loadQuestion();
    }

function loadQuestion() {
    if (currentQuestionIndex >= QUESTIONS.length) {
        endGame();
        return;
    }

    // NEW: handle pointer comet trail for this question
    if (currentMode === "big") {
        if (pointerTrailPending) {
            const trail = getNextPointerTrail();
            applyPointerTrail(trail);
            pointerTrailPending = false; // we used it
        } else {
            // No special trail scheduled -> plain pointer
            clearPointerTrail();
        }
    } else {
        // Phone mode (no big pointer on screen)
        clearPointerTrail();
    }

    // Stop any suspense / bursts from previous question
    stopSuspense();
    stopButtonBurstLoop();
    stopSpotlight();
    lastSelectedButton = null;
    lastAnswerWasCorrect = false;
    lastSelectedAnswerIndex = null;

    const q = QUESTIONS[currentQuestionIndex];
    questionTextEl.textContent = q.text;

    // Reset question card back to normal (question) mode
    if (questionCard && feedbackBubble) {
        questionCard.classList.remove("feedback-mode");
        feedbackBubble.style.display = "none";
        questionTextEl.style.display = "block";
    }
    nextQuestionBtn.classList.add("hidden");
    feedbackDetailEl.textContent = "";

    // Animated question reveal
    questionTextEl.classList.remove("question-reveal");
    void questionTextEl.offsetWidth;
    questionTextEl.classList.add("question-reveal");

    updateProgress();

    // Reset timer for each new question
    if (currentMode === "big") {
        startTimer();
    } else {
        stopTimer();
    }

    isLocked = false;
    answerButtons.forEach(btn => {
        // Remove any state from the previous question
        btn.classList.remove(
        "disabled",
        "answer-correct",
        "answer-wrong",
        "answer-faded",
        "spotlight-chosen"
        );
    });

    const order = shuffledIndices(q.answers.length);
    answerButtons.forEach((btn, pos) => {
        const idx = order[pos];
        btn.dataset.answerIndex = String(idx);
        const textSpan = btn.querySelector(".answer-text");
        textSpan.textContent = q.answers[idx];
    });
    }

    

    function goToNextQuestionAnimated() {
      // If we don't have the quiz container for some reason, just jump
      if (!quizMain) {
        currentQuestionIndex += 1;
        loadQuestion();
        return;
      }

      // Prevent double-triggers while animation is running
      if (isTransitioningQuestion) return;
      isTransitioningQuestion = true;

      // Start slide-out animation on the current question
      quizMain.classList.add("question-slide-out");

      const handleOutEnd = (event) => {
        // Make sure this is our slide-out animation
        if (event.animationName !== "questionSlideOut") return;

        quizMain.removeEventListener("animationend", handleOutEnd);
        quizMain.classList.remove("question-slide-out");

        // Move to the next question
        currentQuestionIndex += 1;
        loadQuestion();

        // Animate the new question sliding in
        quizMain.classList.add("question-slide-in");

        const handleInEnd = (evt) => {
          if (evt.animationName !== "questionSlideIn") return;

          quizMain.removeEventListener("animationend", handleInEnd);
          quizMain.classList.remove("question-slide-in");
          isTransitioningQuestion = false;
        };

        quizMain.addEventListener("animationend", handleInEnd);
      };

      quizMain.addEventListener("animationend", handleOutEnd);
    }



function handleAnswerClick(e) {
  if (isLocked) return;
  isLocked = true;

  // Stop timer as soon as an answer is chosen
  stopTimer();

  const btn = e.currentTarget;
  const answerIndex = Number(btn.dataset.answerIndex);
  const q = QUESTIONS[currentQuestionIndex];

  lastSelectedButton = btn;
  lastSelectedAnswerIndex = answerIndex;
  lastAnswerWasCorrect = answerIndex === q.correctIndex;

  // Stop any more clicks on the answers
  answerButtons.forEach(b => b.classList.add("disabled"));

  // Start spotlight + suspense thumbs
  startSpotlight(btn);
  startSuspenseSequence();

  // Big mode: we will reveal after suspense, no auto-advance here
}




    function endGame() {
      updateProgress();
      finalScoreEl.textContent = `${score} points`;
      finalCorrectEl.textContent = `You got ${correctCount} out of ${QUESTIONS.length} correct`;

      const ratio = correctCount / QUESTIONS.length;
      endScreen.classList.remove("end-great", "end-good", "end-try");

      if (ratio >= 0.8) {
        endScreen.classList.add("end-great");
        endTitleEl.textContent = "Amazing Job!";
        endSubtitleEl.textContent = "You really know this story.";
      } else if (ratio >= 0.5) {
        endScreen.classList.add("end-good");
        endTitleEl.textContent = "Nice Work!";
        endSubtitleEl.textContent = "You did well. Keep learning!";
      } else {
        endScreen.classList.add("end-try");
        endTitleEl.textContent = "Keep Practicing!";
        endSubtitleEl.textContent = "Try again and watch your score grow.";
      }

      // Always show the present on the end screen, with a gentle wiggle
      endTrophyEl.textContent = "üéÅ";
      endTrophyEl.classList.add("end-present-wiggle");

      // Reset reward state and hide overlay in case this is a replay
      hasRevealedReward = false;
      hideRewardOverlay();

      showScreen("end");
    }


    function handleEndPresentClick() {
      if (hasRevealedReward) {
        // Don't run the animation twice
        return;
      }

      hasRevealedReward = true;

      // Stop the small idle wiggle on the end screen icon
      endTrophyEl.classList.remove("end-present-wiggle");

      // Start the full-screen reward sequence
      startRewardSequence();
    }


    /***********************
     * EVENT LISTENERS
     ***********************/
    bigScreenBtn.addEventListener("click", () => startGame("big"));
    phoneModeBtn.addEventListener("click", () => startGame("phone"));

    answerButtons.forEach(btn => {
      btn.addEventListener("click", handleAnswerClick);
    });

    // Clicking the end-screen present triggers the reward spotlight
    endTrophyEl.addEventListener("click", handleEndPresentClick);

    // NEW: Clicking the giant reward emoji closes the spotlight with a big explosion
    if (rewardEmojiEl) {
      rewardEmojiEl.addEventListener("click", handleRewardEmojiClick);
    }

    // EXTRA SAFETY: also listen on the whole reward overlay,
    // but only react when the click is actually on the big emoji.
    if (rewardOverlay && rewardEmojiEl) {
    rewardOverlay.addEventListener("click", (event) => {
        // If the click wasn't on the emoji (or its children), do nothing.
        if (!rewardEmojiEl.contains(event.target)) return;

        // Run the same explosion + undarken logic
        handleRewardEmojiClick();
    });
    }


    // Keyboard controls: 1, 2, 3, 4 to choose the answers
    document.addEventListener("keydown", (e) => {
    // Only react when the quiz screen is visible
    if (quizScreen.classList.contains("hidden")) return;

    // If we're showing feedback in the question bar, ignore number keys
    if (questionCard && questionCard.classList.contains("feedback-mode")) return;


    // If the question is already locked, ignore further input
    if (isLocked) return;

    const key = e.key; // this will be "1", "2", "3", "4", etc.

    // Map keys "1"‚Äì"4" to button indices 0‚Äì3
    let index = null;
    if (key === "1") index = 0;
    else if (key === "2") index = 1;
    else if (key === "3") index = 2;
    else if (key === "4") index = 3;

    if (index === null) return; // some other key pressed

    const btn = answerButtons[index];
    if (!btn) return;

    // Simulate a click on that button
    btn.click();
    });

    // DEBUG: quick skip to the end screen with a chosen score
    // Press 0 or 5‚Äì9 on the keyboard to jump to the end.
    // (1‚Äì4 are left alone so they still answer questions.)
    document.addEventListener("keydown", (e) => {
      const key = e.key;

      // Only care about digit keys 0‚Äì9
      if (key < "0" || key > "9") return;

      const n = parseInt(key, 10);

      // Keep 1‚Äì4 for normal answering
      if (n >= 1 && n <= 4) return;

      // Pretend you finished the quiz with "n" correct answers
      correctCount = n;

      // Move us to "after" the last question
      currentQuestionIndex = QUESTIONS.length;

      // Jump straight to the end screen (present, spotlight, etc.)
      endGame();
    });


    soundToggleBtn.addEventListener("click", () => {
      soundEnabled = !soundEnabled;
      soundToggleBtn.textContent = soundEnabled ? "üîä" : "üîà";
    });

    const nextQuestionBtn = document.getElementById("next-question-btn");

    nextQuestionBtn.addEventListener("click", () => {
    // Hide the button itself; the card will reset when the next question loads
    nextQuestionBtn.classList.add("hidden");
    goToNextQuestionAnimated();
    });




    playAgainBtn.addEventListener("click", () => startGame(currentMode));
    backToTitleBtn.addEventListener("click", () => {
      body.classList.remove("mode-big", "mode-phone");
      body.classList.add("mode-title");
      showScreen("title");
    });

    // Start on intro screen with full background
    body.classList.add("mode-title");
    body.classList.add("intro-mode");
    showScreen("intro");

    // Handle Load Quiz button click
    if (loadQuizBtn) {
    loadQuizBtn.addEventListener("click", () => {
        // Prevent double-clicks
        loadQuizBtn.disabled = true;

        // Swap to the bitten-bible logo
        if (introLogo) {
        introLogo.src = "quizimages/eyb_logo_2.png";
        }

        // Play chomp sound ‚Äì this is allowed because it happens on a click
        playChompSound();

        // Wait 0.5 seconds before starting the fade
        setTimeout(() => {
        // Start fading out the intro screen
        introScreen.classList.add("intro-fade-out");
        }, 500);

        // After 0.5s delay + 1.0s fade = 1.5s total, show the title screen
        setTimeout(() => {
        body.classList.remove("intro-mode");
        showScreen("title");
        introScreen.classList.remove("intro-fade-out");
        }, 1500);
    });
    }






    document.addEventListener("mousemove", (e) => {
    // Only show the big pointer in Big Screen mode
    if (!body.classList.contains("mode-big")) return;
    if (isRealTablet) return;

    const x = e.clientX;
    const y = e.clientY;

    // Move the main pointer to follow the mouse
    bigPointer.style.left = x + "px";
    bigPointer.style.top = y + "px";

    // If a comet trail is active, spawn emoji ghosts
    if (currentPointerTrail) {
        spawnPointerTrailEmoji(x, y);
    }
    });


    document.addEventListener("mousedown", (e) => {
    spawnClickRipple(e.clientX, e.clientY);
    });



    const homeButton = document.getElementById("home-button");

    homeButton.addEventListener("click", () => {
        stopTimer(); // stop timer if running
        bigPointer.classList.add("hidden"); // hide big pointer when leaving quiz
        body.classList.remove("mode-big", "mode-phone");
        body.classList.add("mode-title");
        showScreen("title");
    });




  </script>
</body>
</html>
