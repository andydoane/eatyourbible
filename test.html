<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Emoji Bible Plinko</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <style>
    :root {
      --bg: #0f172a;
      --panel: rgba(15, 23, 42, 0.95);
      --accent: #f97316;
      --correct: #22c55e;
      --incorrect: #ef4444;
      --text: #e2e8f0;
      --well1: #0ea5e9;
      --well2: #fbbf24;
      --well3: #f43f5e;
      --ui-z: 100;
      --game-z: 50;
    }
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    body {
      margin: 0;
      background: var(--bg);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: var(--text);
      height: 100vh;
      overflow: hidden;
    }
    #app {
      position: relative;
      width: 100vw;
      height: 100vh;
      max-width: 650px; /* PC just scales up, centered */
      margin: 0 auto;
      background: radial-gradient(circle at top, #1f2937 0%, #020617 50%, #000 100%);
    }
    .screen {
      position: absolute;
      inset: 0;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 1.2rem;
      gap: 1rem;
    }
    .screen.active {
      display: flex;
    }
    .card {
      background: var(--panel);
      border: 2px solid rgba(248, 250, 252, 0.05);
      border-radius: 1.25rem;
      padding: 1.25rem 1.5rem;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
      text-align: center;
      width: min(92vw, 500px);
    }
    h1, h2, h3 {
      margin: 0.2rem 0;
    }
    button {
      background: var(--accent);
      border: none;
      color: white;
      padding: 0.8rem 1.2rem;
      border-radius: 0.85rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.1s;
      width: 100%;
      max-width: 420px;
    }
    button:active {
      transform: scale(0.97);
    }
    .question-options {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      width: 100%;
    }
    .answer-btn {
      background: rgba(15, 118, 110, 0.2);
      border: 1px solid rgba(148, 163, 184, 0.3);
      display: flex;
      align-items: center;
      gap: 0.6rem;
      justify-content: flex-start;
    }
    .answer-emoji {
      font-size: 1.4rem;
    }

    /* Game screen */
    #gameScreen {
      background: transparent;
      align-items: stretch;
      justify-content: flex-start;
      padding: 0;
    }
    #gameHUD {
      position: absolute;
      top: 0.35rem;
      left: 0.35rem;
      right: 0.35rem;
      display: flex;
      justify-content: space-between;
      gap: 0.35rem;
      z-index: var(--ui-z);
      font-size: 0.7rem;
    }
    .hud-box {
      background: rgba(15, 23, 42, 0.4);
      border: 1px solid rgba(248, 250, 252, 0.05);
      border-radius: 0.75rem;
      padding: 0.4rem 0.55rem;
      min-width: 4.5rem;
      text-align: center;
    }
    #gameField {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
    }

    .peg {
    position: absolute;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    transition: transform 0.25s, opacity 0.25s;
    }


    .peg.hit {
      transform: scale(0.1) rotate(35deg);
      opacity: 0;
    }

    .debug-peg-hitbox {
    outline: 2px dashed rgba(255, 0, 0, 0.6);
    border-radius: 999px;
    }

    .debug-ball-hitbox {
    outline: 2px solid rgba(0, 255, 0, 0.7);
    border-radius: 999px;
    }



    .ball {
      position: absolute;
      width: 1.8rem;
      height: 1.8rem;
      border-radius: 999px;
      background: radial-gradient(circle, #f8fafc 0%, #94a3b8 65%, #020617 90%);
      box-shadow: 0 6px 14px rgba(0, 0, 0, 0.6);
      z-index: calc(var(--game-z) + 5);
    }
    #arrow {
      position: absolute;
      top: 3.2rem;
      width: 1.25rem;
      height: 1.25rem;
      z-index: calc(var(--game-z) + 6);
      font-size: 1.4rem;
      text-shadow: 0 2px 5px rgba(0,0,0,.5);
    }

    #bottomWells {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 2.6rem;           /* shorter bar */
    min-height: 0;            /* we control it now */
    display: flex;
    z-index: calc(var(--game-z) + 2);
    }

    .well {
    border-top: 3px solid rgba(248, 250, 252, 0.4);
    display: flex;
    align-items: center;              /* center vertically */
    justify-content: center;
    color: #0f172a;
    font-size: 0.75rem;
    font-weight: 700;
    position: relative;
    overflow: hidden;
    line-height: 1;                   /* tighter text */
    }


/* special / bomb pegs glow */
.peg-special,
.peg-bomb {
}
.peg-special::before,
.peg-bomb::before {
  content: "";
  position: absolute;
  inset: -6px;
  border-radius: 999px;
  background: radial-gradient(circle, rgba(255,255,255,0.35) 0%, rgba(255,255,255,0) 70%);
  animation: pegPulse 1.1s ease-in-out infinite;
  z-index: -1;
}
@keyframes pegPulse {
  0% { transform: scale(0.85); opacity: 0.6; }
  50% { transform: scale(1.15); opacity: 1; }
  100% { transform: scale(0.85); opacity: 0.6; }
}

/* moving platform */
.moving-platform {
  position: absolute;
  background: rgba(248, 250, 252, 0.9);
  border: 1px solid rgba(15, 23, 42, 0.35);
  border-radius: 0.5rem;
  z-index: calc(var(--game-z) + 4);
  pointer-events: none;
}

/* big confetti */
.confetti-piece {
  position: absolute;
  width: 10px;
  height: 14px;
  opacity: 0;
  animation: confettiPop 0.7s ease-out forwards;
}
@keyframes confettiPop {
  0% { transform: translate(0,0) rotate(0deg); opacity: 1; }
  100% { transform: translate(var(--tx), var(--ty)) rotate(var(--rot)); opacity: 0; }
}


    .well-score-burst {
      position: absolute;
      bottom: 0.35rem;
      font-weight: 700;
      color: #fff;
      text-shadow: 0 3px 10px rgba(0,0,0,0.6);
      animation: popUp 0.7s ease-out forwards;
      left: 50%;
      transform: translateX(-50%);
    }
    @keyframes popUp {
      0% {transform: translate(-50%, 40%); opacity: 0;}
      50% {opacity: 1;}
      100% {transform: translate(-50%, -120%); opacity: 0;}
    }

    .popup {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999;
      background: rgba(0, 0, 0, 0.5);
      padding: 1rem;
    }
    .popup.active {
      display: flex;
    }
    .popup-content {
      background: #1f2937;
      border: 2px solid rgba(226, 232, 240, 0.1);
      border-radius: 1.2rem;
      padding: 1.1rem 1.2rem 1rem;
      text-align: center;
      width: min(90vw, 350px);
    }

    #emojiRainContainer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: 9999;
    }
    .rain-emoji {
      position: absolute;
      top: -5rem;
      font-size: 2rem;
      animation: fall 2.2s linear forwards;
    }
    @keyframes fall {
      to { transform: translateY(110vh); opacity: 0; }
    }

    /* orientation helper (just visual hint) */
    @media (orientation: landscape) {
      .landscape-hint {
        display: block;
      }
    }
    .landscape-hint {
      display: none;
      position: absolute;
      top: .5rem;
      right: .5rem;
      background: rgba(248,113,113,.18);
      border: 1px solid rgba(248, 113, 113, .6);
      padding: .25rem .5rem;
      border-radius: .5rem;
      font-size: .65rem;
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Splash -->
    <div id="splashScreen" class="screen active">
      <div class="card">
        <h1>ğŸ“± Vertical Mode</h1>
        <p>This game is best in vertical (portrait) mode.</p>
        <button id="splashOkayBtn">Okay!</button>
      </div>
    </div>

    <!-- Title -->
    <div id="titleScreen" class="screen">
      <div class="card">
        <h1>Emoji Bible Plinko</h1>
        <p>Answer Bible questions âœ drop balls âœ smash emoji âœ score big.</p>
        <button id="startBtn">Go fullscreen and start</button>
      </div>
    </div>

    <!-- Question -->
    <div id="questionScreen" class="screen">
      <div class="card" id="questionCard">
        <h2 id="questionText">Question goes here</h2>
        <div id="questionNumber" style="margin-bottom:.5rem;font-size:.75rem;opacity:.7;">Question 1 of 10</div>
        <div class="question-options" id="answerOptions"></div>
      </div>
    </div>

    <!-- Game -->
    <div id="gameScreen" class="screen">
      <div id="gameHUD">
        <div class="hud-box" id="hudRound">Round 1 / 10</div>
        <div class="hud-box" id="hudBalls">Balls: 5</div>
        <div class="hud-box" id="hudScore">Score: 0</div>
      </div>
      <div id="gameField"></div>

        <div id="bottomWells">
        <div class="well" data-score="1000" style="flex: 1; background: rgba(14,165,233,0.85);">1K</div>
        <div class="well" data-score="5000" style="flex: 1; background: rgba(251,191,36,0.85);">5K</div>
        <div class="well" data-score="10000" data-extraball="1" style="flex: .5; background: rgba(244,63,94,0.85);">10K</div>
        <div class="well" data-score="5000" style="flex: 1; background: rgba(251,191,36,0.85);">5K</div>
        <div class="well" data-score="1000" style="flex: 1; background: rgba(14,165,233,0.85);">1K</div>
        </div>

      

      <div class="landscape-hint">portrait game</div>
    </div>

    <!-- End Screen -->
    <div id="endScreen" class="screen">
      <div class="card">
        <h1>Game Over</h1>
        <p id="finalScoreText">You scored 0 points.</p>
        <p id="finalQA">Correct: 0 Â· Incorrect: 0</p>
        <button onclick="location.reload()">Play again</button>
      </div>
    </div>

    <!-- Popup -->
    <div id="popup" class="popup">
      <div class="popup-content">
        <h3 id="popupTitle">Popup</h3>
        <p id="popupMessage">Popup text</p>
        <button id="popupBtn">OK</button>
      </div>
    </div>

    <!-- Emoji rain -->
    <div id="emojiRainContainer"></div>
  </div>

  <script>
    /**********************
     * TWEAKABLE SETTINGS *
     **********************/
    const SETTINGS = {
      arrowSpeed: 1.6,           // how fast the arrow sweeps left-right
      gravity: 1200,             // px / s^2
      bounceStrength: 420,       // how hard balls bounce off pegs
      pegRadius: 20,             // match .peg size
      ballRadius: 15,
      rows: 8,                   // number of emoji rows
      rowSpacing: 70,            // vertical spacing
      topOffset: 110,            // where pegs start
      ballCountPerRound: 5,
      scorePerHit: 300,          // per emoji hit
      emojiHitFX: ["âœ¨","ğŸ’¥","ğŸ‰","âš¡","ğŸŒˆ"],
        emojiRainCount: 30,
        launchSpeed: 520,
        launchStartY: 50,
        specialEmoji: "ğŸ’",
        bombEmoji: "ğŸ’£",
        bombRadius: 120,
        platformSpeed: 90
};


    /**********************
     * GAME DATA
     **********************/
    const QUESTIONS = [
      {
        text: "Who created the heavens and the earth?",
        answers: [
          { label: "God", emoji: "âœ¨", correct: true },
          { label: "Moses", emoji: "ğŸª„", correct: false },
          { label: "Noah", emoji: "ğŸ›¶", correct: false },
          { label: "David", emoji: "ğŸµ", correct: false }
        ]
      },
      {
        text: "Where was Jesus born?",
        answers: [
          { label: "Bethlehem", emoji: "â­", correct: true },
          { label: "Nazareth", emoji: "ğŸ˜ï¸", correct: false },
          { label: "Jerusalem", emoji: "ğŸ›ï¸", correct: false },
          { label: "Rome", emoji: "ğŸŸï¸", correct: false }
        ]
      },
      {
        text: "Which prophet was swallowed by a big fish?",
        answers: [
          { label: "Jonah", emoji: "ğŸŸ", correct: true },
          { label: "Elijah", emoji: "ğŸ”¥", correct: false },
          { label: "Isaiah", emoji: "ğŸ“œ", correct: false },
          { label: "Daniel", emoji: "ğŸ¦", correct: false }
        ]
      },
      {
        text: "Who led Israel out of Egypt?",
        answers: [
          { label: "Moses", emoji: "ğŸª„", correct: true },
          { label: "Aaron", emoji: "ğŸ“¯", correct: false },
          { label: "Joshua", emoji: "âš”ï¸", correct: false },
          { label: "Solomon", emoji: "ğŸ‘‘", correct: false }
        ]
      },
      {
        text: "What is the first book of the Bible?",
        answers: [
          { label: "Genesis", emoji: "ğŸ“–", correct: true },
          { label: "Exodus", emoji: "ğŸŒŠ", correct: false },
          { label: "Psalms", emoji: "ğŸ¶", correct: false },
          { label: "Matthew", emoji: "ğŸ“œ", correct: false }
        ]
      },
      {
        text: "Who is God's Son?",
        answers: [
          { label: "Jesus", emoji: "âœï¸", correct: true },
          { label: "Peter", emoji: "ğŸŸ", correct: false },
          { label: "Paul", emoji: "ğŸ“", correct: false },
          { label: "John", emoji: "ğŸ•Šï¸", correct: false }
        ]
      },
      {
        text: "God saved Noah and his family with a...",
        answers: [
          { label: "Boat/Ark", emoji: "ğŸ›¶", correct: true },
          { label: "Chariot", emoji: "ğŸ‡", correct: false },
          { label: "Castle", emoji: "ğŸ°", correct: false },
          { label: "Dragon", emoji: "ğŸ‰", correct: false }
        ]
      },
      {
        text: "Who fought Goliath with a sling?",
        answers: [
          { label: "David", emoji: "ğŸª¨", correct: true },
          { label: "Saul", emoji: "ğŸ—¡ï¸", correct: false },
          { label: "Samuel", emoji: "ğŸ“¯", correct: false },
          { label: "Joseph", emoji: "ğŸ¨", correct: false }
        ]
      },
      {
        text: "What did God make on day 1?",
        answers: [
          { label: "Light", emoji: "ğŸ’¡", correct: true },
          { label: "Animals", emoji: "ğŸ˜", correct: false },
          { label: "People", emoji: "ğŸ§", correct: false },
          { label: "Birds", emoji: "ğŸ•Šï¸", correct: false }
        ]
      },
      {
        text: "What did Jesus die on?",
        answers: [
          { label: "A cross", emoji: "âœï¸", correct: true },
          { label: "A ship", emoji: "â›µ", correct: false },
          { label: "A tower", emoji: "ğŸ—¼", correct: false },
          { label: "A mountain", emoji: "â›°ï¸", correct: false }
        ]
      }
    ];

    const ROUND_EMOJI_SETS = [
      ["ğŸ","ğŸŠ","ğŸ‡","ğŸ‰","ğŸ“","ğŸ¥","ğŸ’","ğŸ"],
      ["ğŸ¶","ğŸ±","ğŸ­","ğŸ¦Š","ğŸ»","ğŸ¼","ğŸ¨","ğŸ¸"],
      ["ğŸš—","ğŸš•","ğŸšŒ","ğŸš“","ğŸš‘","ğŸš’","ğŸšœ","ğŸï¸"],
      ["âš½","ğŸ€","ğŸˆ","ğŸ¾","ğŸ","ğŸ¥","ğŸ‰","ğŸ¥"],
      ["ğŸŒˆ","â­","â˜ï¸","ğŸŒ™","âš¡","â˜€ï¸","ğŸŒ¤ï¸","ğŸŒ§ï¸"],
      ["ğŸˆ","ğŸ‰","ğŸŠ","ğŸ","ğŸª…","ğŸ¯","ğŸ®","ğŸµ"],
      ["ğŸ”","ğŸŸ","ğŸ•","ğŸŒ­","ğŸ—","ğŸ¥","ğŸ¥¨","ğŸª"],
      ["ğŸŒ¸","ğŸŒ¼","ğŸŒ»","ğŸŒ·","ğŸŒ¹","ğŸ€","ğŸŒµ","ğŸ"],
      ["ğŸ‡ºğŸ‡¸","ğŸ‡¬ğŸ‡§","ğŸ‡¨ğŸ‡¦","ğŸ‡®ğŸ‡¹","ğŸ‡¯ğŸ‡µ","ğŸ‡«ğŸ‡·","ğŸ‡©ğŸ‡ª","ğŸ‡§ğŸ‡·"],
      ["ğŸ§±","ğŸª™","ğŸ””","ğŸ","ğŸ’","ğŸ§Š","ğŸ§ƒ","ğŸ§ "]
    ];

    /**********************
     * STATE
     **********************/
    let currentQuestionIndex = 0;
    let totalScore = 0;
    let correctCount = 0;
    let incorrectCount = 0;

    let lastTimestamp = 0; 

    let ballsLeft = SETTINGS.ballCountPerRound;
    let activeBalls = []; 
    let pegs = [];
    let gameWidth = 0;
    let gameHeight = 0;
    let gameFieldEl = null;
    let wells = [];
    let gameRunning = false;
    let awaitingDrop = false;
    let debugHitboxes = false;
    let currentPegSize = 32; // will be updated each round
    let roundEnding = false; // <-- prevents multiple finishRound calls




    /**********************
     * ELEMENTS
     **********************/
    const splashScreen = document.getElementById("splashScreen");
    const titleScreen = document.getElementById("titleScreen");
    const questionScreen = document.getElementById("questionScreen");
    const gameScreen = document.getElementById("gameScreen");
    const endScreen = document.getElementById("endScreen");
    const questionTextEl = document.getElementById("questionText");
    const questionNumberEl = document.getElementById("questionNumber");
    const answerOptionsEl = document.getElementById("answerOptions");
    const popup = document.getElementById("popup");
    const popupTitle = document.getElementById("popupTitle");
    const popupMessage = document.getElementById("popupMessage");
    const popupBtn = document.getElementById("popupBtn");
    const hudRound = document.getElementById("hudRound");
    const hudBalls = document.getElementById("hudBalls");
    const hudScore = document.getElementById("hudScore");
    const emojiRainContainer = document.getElementById("emojiRainContainer");

    /**********************
     * SCREEN CONTROLS
     **********************/
    function showScreen(screenEl) {
      [splashScreen, titleScreen, questionScreen, gameScreen, endScreen].forEach(s => s.classList.remove("active"));
      screenEl.classList.add("active");
    }

    document.getElementById("splashOkayBtn").addEventListener("click", () => {
      showScreen(titleScreen);
    });

    document.getElementById("startBtn").addEventListener("click", async () => {
      // try fullscreen (may fail quietly)
      const el = document.documentElement;
      if (el.requestFullscreen) {
        try { await el.requestFullscreen(); } catch (e) {}
      }
      startQuestions();
    });

    popupBtn.addEventListener("click", () => {
      popup.classList.remove("active");
      if (popup.dataset.next === "startGame") {
        beginGameRound();
      }
    });

    function showPopup(title, msg, next = "") {
      popupTitle.textContent = title;
      popupMessage.textContent = msg;
      popup.dataset.next = next;
      popup.classList.add("active");
    }

    /**********************
     * QUESTIONS
     **********************/
    function startQuestions() {
      currentQuestionIndex = 0;
      showNextQuestion();
    }

    function showNextQuestion() {
      if (currentQuestionIndex >= QUESTIONS.length) {
        endGame();
        return;
      }
      const q = QUESTIONS[currentQuestionIndex];
      questionTextEl.textContent = q.text;
      questionNumberEl.textContent = `Question ${currentQuestionIndex + 1} of ${QUESTIONS.length}`;
      answerOptionsEl.innerHTML = "";
      // create a shuffled copy
      const shuffled = q.answers.slice().sort(() => Math.random() - 0.5);
      shuffled.forEach(ans => {
        const btn = document.createElement("button");
        btn.className = "answer-btn";
        btn.innerHTML = `<span class="answer-emoji">${ans.emoji}</span> ${ans.label}`;
        btn.addEventListener("click", () => handleAnswer(ans.correct, q.answers.find(a => a.correct).label));
        answerOptionsEl.appendChild(btn);
      });
      showScreen(questionScreen);
    }

    function handleAnswer(isCorrect, rightAnswerLabel) {
      if (isCorrect) {
        correctCount++;
        totalScore += 500; // bonus for correct question
        showPopup("Correct âœ…", "Nice job! Now smash some emoji!", "startGame");
      } else {
        incorrectCount++;
        showPopup("Not quite âŒ", "The right answer was: " + rightAnswerLabel, "startGame");
      }
    }

    /**********************
     * GAME ROUND
     **********************/
    function beginGameRound() {
    showScreen(gameScreen);
    setupGameForRound(currentQuestionIndex);
    ballsLeft = SETTINGS.ballCountPerRound;
    activeBalls = [];             // <â€” instead of activeBall = null
    updateHUD();
    gameRunning = true;
    awaitingDrop = true;
    roundEnding = false;
    showPopup("Drop time!", "Tap or click to release the ball. Break as many emoji as you can with five balls.", "");
    }


     


    function setupGameForRound(roundIndex) {
      gameFieldEl = document.getElementById("gameField");
      gameWidth = gameFieldEl.clientWidth;
      gameHeight = gameFieldEl.clientHeight;
      gameFieldEl.innerHTML = ""; // clear any old pegs / balls
      pegs = [];

        const pegSize = gameWidth / 13;
        currentPegSize = pegSize;
        SETTINGS.pegRadius = pegSize / 2;


      // make pegs
      const emojiSet = ROUND_EMOJI_SETS[roundIndex % ROUND_EMOJI_SETS.length];
      for (let r = 0; r < SETTINGS.rows; r++) {
        const isEven = r % 2 === 0;
        const cols = isEven ? 6 : 5;
        const y = SETTINGS.topOffset + r * SETTINGS.rowSpacing;
        for (let c = 0; c < cols; c++) {
          const xGap = gameWidth / (cols + 1);
          const x = xGap * (c + 1);
          const pegEl = document.createElement("div");
          pegEl.className = "peg";
          pegEl.style.width = pegSize + "px";
          pegEl.style.height = pegSize + "px";
          pegEl.style.fontSize = (pegSize * 0.8) + "px";
          pegEl.style.left = (x - pegSize / 2) + "px";
          pegEl.style.top = (y - pegSize / 2) + "px";
          pegEl.textContent = emojiSet[(r * 7 + c) % emojiSet.length];
          gameFieldEl.appendChild(pegEl);
          pegs.push({ x, y, el: pegEl, hit: false });
        }
      }

  // after we have all pegs, mark 1 special and 1 bomb
  if (pegs.length > 1) {
    const specialIndex = Math.floor(Math.random() * pegs.length);
    let bombIndex = Math.floor(Math.random() * pegs.length);
    while (bombIndex === specialIndex) {
      bombIndex = Math.floor(Math.random() * pegs.length);
    }

    // special
    const sp = pegs[specialIndex];
    sp.type = "special";
    sp.el.textContent = SETTINGS.specialEmoji;
    sp.el.classList.add("peg-special");

    // bomb
    const bp = pegs[bombIndex];
    bp.type = "bomb";
    bp.el.textContent = SETTINGS.bombEmoji;
    bp.el.classList.add("peg-bomb");
  }

  // get wells
  wells = Array.from(document.querySelectorAll("#bottomWells .well"));

  // build moving platform above wells
  const wellsBar = document.getElementById("bottomWells");
  const wellsBarRect = wellsBar.getBoundingClientRect();
  const wellsBarHeight = wellsBarRect.height;
  const totalFlex = wells.reduce((acc, w) => acc + parseFloat(w.style.flex), 0);
  const wideWellWidth = gameWidth * (1 / totalFlex); // width of a flex:1 well
  const platformHeight = wellsBarHeight / 2;

  const platformEl = document.createElement("div");
  platformEl.className = "moving-platform";
  platformEl.style.width = wideWellWidth + "px";
  platformEl.style.height = platformHeight + "px";
  platformEl.style.left = (gameWidth / 2 - wideWellWidth / 2) + "px";
  platformEl.style.bottom = (wellsBarHeight + wellsBarHeight / 2 - platformHeight / 2) + "px";
  gameFieldEl.appendChild(platformEl);

  movingPlatform = {
    x: gameWidth / 2 - wideWellWidth / 2,
    y: gameHeight - wellsBarHeight - (wellsBarHeight / 2),
    width: wideWellWidth,
    height: platformHeight,
    el: platformEl,
    dir: 1
  };
}





    function updateHUD() {
      hudRound.textContent = `Round ${currentQuestionIndex + 1} / ${QUESTIONS.length}`;
      hudBalls.textContent = `Balls: ${ballsLeft}`;
      hudScore.textContent = `Score: ${totalScore}`;
    }

    // drop ball when player taps
    gameScreen.addEventListener("pointerdown", (e) => {
      if (!gameRunning) return;
      if (!awaitingDrop) return;
      if (ballsLeft <= 0) return;

      const rect = gameFieldEl.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;

      spawnBallToward(clickX, clickY);
    });


    function spawnBallToward(targetX, targetY) {
    const startX = gameWidth / 2;
    const startY = SETTINGS.launchStartY;

    const ballEl = document.createElement("div");
    ballEl.className = "ball";
    gameFieldEl.appendChild(ballEl);

    const dx = targetX - startX;
    const dy = targetY - startY;
    const len = Math.sqrt(dx * dx + dy * dy) || 1;
    const speed = SETTINGS.launchSpeed;

    const vx = (dx / len) * speed;
    const vy = (dy / len) * speed;

    const ball = {
        x: startX,
        y: startY,
        vx: vx,
        vy: vy,
        el: ballEl
    };

    activeBalls.push(ball);

    ballsLeft -= 1;
    awaitingDrop = false;
    updateHUD();
    if (debugHitboxes) updateDebugVisuals();
    }


function spawnBonusBallAtTop() {
  if (!gameFieldEl) return;
  const randX = Math.random() * (gameWidth - SETTINGS.ballRadius * 2) + SETTINGS.ballRadius;
  const ballEl = document.createElement("div");
  ballEl.className = "ball";
  gameFieldEl.appendChild(ballEl);

  const ball = {
    x: randX,
    y: SETTINGS.launchStartY,
    vx: (Math.random() - 0.5) * 90,
    vy: 140,
    el: ballEl
  };

  activeBalls.push(ball);
  if (debugHitboxes) updateDebugVisuals();
}


    /**********************
     * MAIN LOOP
     **********************/
    function loop(timestamp) {
      if (!lastTimestamp) lastTimestamp = timestamp;
      const dt = Math.min((timestamp - lastTimestamp) / 1000, 0.035);
      lastTimestamp = timestamp;

    if (gameRunning) {
    // move platform
    if (movingPlatform) {
        movingPlatform.x += movingPlatform.dir * SETTINGS.platformSpeed * dt;
        if (movingPlatform.x < 0) {
        movingPlatform.x = 0;
        movingPlatform.dir = 1;
        } else if (movingPlatform.x + movingPlatform.width > gameWidth) {
        movingPlatform.x = gameWidth - movingPlatform.width;
        movingPlatform.dir = -1;
        }
        movingPlatform.el.style.left = movingPlatform.x + "px";
    }

    // update all balls
    for (let i = activeBalls.length - 1; i >= 0; i--) {
        const b = activeBalls[i];
        updateBall(b, dt);
    }

    // if we have no balls flying AND no balls left to drop, end the round (once)
    if (activeBalls.length === 0 && ballsLeft <= 0 && !roundEnding) {
        roundEnding = true;
        setTimeout(() => {
        finishRound();
        }, 350);
    }
    }



      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    function updateBall(ball, dt) {
      // physics
      ball.vy += SETTINGS.gravity * dt;

      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;

      // walls
      if (ball.x < SETTINGS.ballRadius) {
        ball.x = SETTINGS.ballRadius;
        ball.vx *= -0.7;
      } else if (ball.x > gameWidth - SETTINGS.ballRadius) {
        ball.x = gameWidth - SETTINGS.ballRadius;
        ball.vx *= -0.7;
      }

      // moving platform collision
if (movingPlatform) {
  const topY = movingPlatform.y;
  const bottomY = movingPlatform.y + movingPlatform.height;
  if (ball.vy > 0) {
    const nextBottom = ball.y + SETTINGS.ballRadius;
    if (nextBottom >= topY && nextBottom <= bottomY) {
      if (ball.x >= movingPlatform.x - SETTINGS.ballRadius &&
          ball.x <= movingPlatform.x + movingPlatform.width + SETTINGS.ballRadius) {
        ball.y = topY - SETTINGS.ballRadius;
        ball.vy = -SETTINGS.bounceStrength * 0.85;
      }
    }
  }
}








    // collisions with pegs
    for (let i = 0; i < pegs.length; i++) {
    const peg = pegs[i];
    if (peg.hit) continue;
    const dx = ball.x - peg.x;
    const dy = ball.y - peg.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < SETTINGS.ballRadius + SETTINGS.pegRadius * 0.6) {
        // bounce like before
        ball.vy = -SETTINGS.bounceStrength;
        ball.vx += dx * 2;

        peg.hit = true;
        peg.el.classList.add("hit");

        // score for any peg
        totalScore += SETTINGS.scorePerHit;
        updateHUD();

        // special behaviors
        if (peg.type === "special") {
        makeBigConfetti(peg.x, peg.y);
        spawnBonusBallAtTop();
        } else if (peg.type === "bomb") {
        makeBigConfetti(peg.x, peg.y);
        explodeBombAt(peg.x, peg.y);
        } else {
        makeSpark(peg.x, peg.y);
        }

        setTimeout(() => {
        if (peg.el && peg.el.parentNode) peg.el.parentNode.removeChild(peg.el);
        }, 300);
    }
    }

      // update DOM
      if (ball.el) {
        ball.el.style.left = (ball.x - SETTINGS.ballRadius) + "px";
        ball.el.style.top = (ball.y - SETTINGS.ballRadius) + "px";
      }

      if (debugHitboxes) updateDebugVisuals();


      // bottom / wells
      if (ball.y > gameHeight - 10) {
        landInWell(ball);
      }
    }

   function landInWell(ball) {
  if (!ball.el) return;
  ball.el.remove();

  // remove from activeBalls
  const idx = activeBalls.indexOf(ball);
  if (idx !== -1) {
    activeBalls.splice(idx, 1);
  }

  // figure out which well we landed in
  const x = ball.x;
  const totalFlex = wells.reduce((acc, w) => acc + parseFloat(w.style.flex), 0);
  const width = gameWidth;
  let cumulative = 0;
  let chosen = wells[0];
  for (let w of wells) {
    const f = parseFloat(w.style.flex);
    const segmentWidth = width * (f / totalFlex);
    if (x >= cumulative && x <= cumulative + segmentWidth) {
      chosen = w;
      break;
    }
    cumulative += segmentWidth;
  }
  const score = parseInt(chosen.dataset.score || "0", 10);
  totalScore += score;

  // score popup
  const burst = document.createElement("div");
  burst.className = "well-score-burst";
  burst.textContent = "+" + score;
  chosen.appendChild(burst);
  setTimeout(() => {
    burst.remove();
  }, 800);

  // extra ball from middle
  if (chosen.dataset.extraball === "1") {
    ballsLeft += 1;
  }

  updateHUD();

  // if we still have balls to drop AND there are no balls flying, let player drop again
  if (ballsLeft > 0 && activeBalls.length === 0) {
    awaitingDrop = true;
  }
}

    

    function finishRound() {
      // move to next question
      currentQuestionIndex++;
      gameRunning = false;
      showNextQuestion();
    }

    /**********************
     * FX
     **********************/
    function makeSpark(x, y) {
      const fx = document.createElement("div");
      fx.style.position = "absolute";
      fx.style.left = (x - 14) + "px";
      fx.style.top = (y - 14) + "px";
      fx.style.zIndex = 9999;
      fx.textContent = SETTINGS.emojiHitFX[Math.floor(Math.random() * SETTINGS.emojiHitFX.length)];
      fx.style.transition = "transform .4s, opacity .4s";
      gameFieldEl.appendChild(fx);
      requestAnimationFrame(() => {
        fx.style.transform = "translateY(-18px) scale(1.5)";
        fx.style.opacity = "0";
      });
      setTimeout(() => fx.remove(), 450);
    }

function makeBigConfetti(x, y) {
  for (let i = 0; i < 18; i++) {
    const piece = document.createElement("div");
    piece.className = "confetti-piece";
    piece.style.left = (x - 6) + "px";
    piece.style.top = (y - 6) + "px";
    const dx = (Math.random() - 0.5) * 160;
    const dy = (Math.random() - 0.5) * 160;
    const rot = (Math.random() * 360) + "deg";
    piece.style.setProperty("--tx", dx + "px");
    piece.style.setProperty("--ty", dy + "px");
    piece.style.setProperty("--rot", rot);
    piece.style.background = ["#f97316","#f43f5e","#3b82f6","#22c55e","#eab308"][i % 5];
    gameFieldEl.appendChild(piece);
    setTimeout(() => piece.remove(), 750);
  }
}

function explodeBombAt(x, y) {
  for (let i = 0; i < pegs.length; i++) {
    const p = pegs[i];
    if (p.hit) continue;
    const dx = p.x - x;
    const dy = p.y - y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist <= SETTINGS.bombRadius) {
      p.hit = true;
      p.el.classList.add("hit");
      totalScore += SETTINGS.scorePerHit;
      makeSpark(p.x, p.y);
      setTimeout(() => {
        if (p.el && p.el.parentNode) p.el.parentNode.removeChild(p.el);
      }, 300);
    }
  }
  updateHUD();
}


    function endGame() {
      showScreen(endScreen);
      document.getElementById("finalScoreText").textContent = "You scored " + totalScore.toLocaleString() + " points.";
      document.getElementById("finalQA").textContent = "Correct: " + correctCount + " Â· Incorrect: " + incorrectCount;

      // emoji rain
      for (let i = 0; i < SETTINGS.emojiRainCount; i++) {
        const re = document.createElement("div");
        re.className = "rain-emoji";
        re.textContent = ROUND_EMOJI_SETS[Math.floor(Math.random() * ROUND_EMOJI_SETS.length)][0];
        re.style.left = Math.random() * 100 + "vw";
        re.style.animationDelay = (Math.random() * 1.2) + "s";
        emojiRainContainer.appendChild(re);
        setTimeout(() => re.remove(), 2500);
      }
    }

    /**********************
     * RESIZE
     **********************/
    document.addEventListener("keydown", (e) => {
    if (e.key === "h" || e.key === "H") {
        debugHitboxes = !debugHitboxes;
        updateDebugVisuals();
    }
    });

    function updateDebugVisuals() {
    // pegs
    pegs.forEach(p => {
        if (!p.el) return;
        if (debugHitboxes) {
        p.el.classList.add("debug-peg-hitbox");
        } else {
        p.el.classList.remove("debug-peg-hitbox");
        }
    });

    // balls
    activeBalls.forEach(b => {
    if (debugHitboxes) {
        b.el.classList.add("debug-ball-hitbox");
    } else {
        b.el.classList.remove("debug-ball-hitbox");
    }
    });

    }




    window.addEventListener("resize", () => {
      // if we are currently in a game, rebuild pegs to match new size
      if (gameScreen.classList.contains("active")) {
        setupGameForRound(currentQuestionIndex);
      }
    });
  </script>
</body>
</html>
